// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)\/[^/]+$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"../node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"../node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"css/main.scss":[function(require,module,exports) {
var reloadCSS = require('_css_loader');

module.hot.dispose(reloadCSS);
module.hot.accept(reloadCSS);
},{"./..\\images\\bg_ps2_v2.jpg":[["bg_ps2_v2.db21af73.jpg","images/bg_ps2_v2.jpg"],"images/bg_ps2_v2.jpg"],"_css_loader":"../node_modules/parcel-bundler/src/builtins/css-loader.js"}],"../node_modules/@material/drawer/dist/mdc.drawer.js":[function(require,module,exports) {
var define;
/*!
 Material Components for the Web
 Copyright (c) 2019 Google Inc.
 License: MIT
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["drawer"] = factory();
	else
		root["mdc"] = root["mdc"] || {}, root["mdc"]["drawer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 106);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
var MDCFoundation = function () {
  _createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }

    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }

    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }

    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }

    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  _createClass(MDCFoundation, [{
    key: "init",
    value: function init() {
      // Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);

  return MDCFoundation;
}();

/* harmony default export */ __webpack_exports__["a"] = (MDCFoundation);

/***/ }),

/***/ 1:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foundation__ = __webpack_require__(0);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * @template F
 */

var MDCComponent = function () {
  _createClass(MDCComponent, null, [{
    key: 'attachTo',

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new __WEBPACK_IMPORTED_MODULE_0__foundation__["a" /* default */]());
    }

    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args);
    // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.
    /** @protected {!F} */
    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  _createClass(MDCComponent, [{
    key: 'initialize',
    value: function initialize() /* ...args */{}
    // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.


    /**
     * @return {!F} foundation
     */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      // Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }

    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'listen',
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }

    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'unlisten',
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }

    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: 'emit',
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var evt = void 0;
      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);

  return MDCComponent;
}();

/* harmony default export */ __webpack_exports__["a"] = (MDCComponent);

/***/ }),

/***/ 10:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC List. Provides an interface for managing focus.
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCListAdapter = function () {
  function MDCListAdapter() {
    _classCallCheck(this, MDCListAdapter);
  }

  _createClass(MDCListAdapter, [{
    key: "getListItemCount",

    /** @return {number} */
    value: function getListItemCount() {}

    /**
     * @return {number} */

  }, {
    key: "getFocusedElementIndex",
    value: function getFocusedElementIndex() {}

    /**
     * @param {number} index
     * @param {string} attribute
     * @param {string} value
     */

  }, {
    key: "setAttributeForElementIndex",
    value: function setAttributeForElementIndex(index, attribute, value) {}

    /**
     * @param {number} index
     * @param {string} attribute
     */

  }, {
    key: "removeAttributeForElementIndex",
    value: function removeAttributeForElementIndex(index, attribute) {}

    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "addClassForElementIndex",
    value: function addClassForElementIndex(index, className) {}

    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "removeClassForElementIndex",
    value: function removeClassForElementIndex(index, className) {}

    /**
     * Focuses list item at the index specified.
     * @param {number} index
     */

  }, {
    key: "focusItemAtIndex",
    value: function focusItemAtIndex(index) {}

    /**
     * Sets the tabindex to the value specified for all button/a element children of
     * the list item at the index specified.
     * @param {number} listItemIndex
     * @param {number} tabIndexValue
     */

  }, {
    key: "setTabIndexForListItemChildren",
    value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}

    /**
     * @param {number} index
     * @return {boolean} Returns true if radio button is present at given list item index.
     */

  }, {
    key: "hasRadioAtIndex",
    value: function hasRadioAtIndex(index) {}

    /**
     * @param {number} index
     * @return {boolean} Returns true if checkbox is present at given list item index.
     */

  }, {
    key: "hasCheckboxAtIndex",
    value: function hasCheckboxAtIndex(index) {}

    /**
     * @param {number} index
     * @return {boolean} Returns true if checkbox inside a list item is checked.
     */

  }, {
    key: "isCheckboxCheckedAtIndex",
    value: function isCheckboxCheckedAtIndex(index) {}

    /**
     * Sets the checked status of checkbox or radio at given list item index.
     * @param {number} index
     * @param {boolean} isChecked
     */

  }, {
    key: "setCheckedCheckboxOrRadioAtIndex",
    value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}

    /**
     * Notifies user action on list item.
     */

  }, {
    key: "notifyAction",
    value: function notifyAction(index) {}

    /**
     * @return {boolean} Returns true when the current focused element is inside list root.
     */

  }, {
    key: "isFocusInsideList",
    value: function isFocusInsideList() {}
  }]);

  return MDCListAdapter;
}();

/* unused harmony default export */ var _unused_webpack_default_export = (MDCListAdapter);

/***/ }),

/***/ 106:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MDCDrawer", function() { return MDCDrawer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_component__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modal_foundation__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__adapter__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__material_list_index__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__material_list_foundation__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__constants__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_focus_trap__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_focus_trap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_focus_trap__);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCDismissibleDrawerFoundation", function() { return __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCModalDrawerFoundation", function() { return __WEBPACK_IMPORTED_MODULE_2__modal_foundation__["a"]; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "util", function() { return __WEBPACK_IMPORTED_MODULE_7__util__; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */










/**
 * @extends {MDCComponent<!MDCDismissibleDrawerFoundation>}
 * @final
 */

var MDCDrawer = function (_MDCComponent) {
  _inherits(MDCDrawer, _MDCComponent);

  /**
   * @param {...?} args
   */
  function MDCDrawer() {
    var _ref;

    _classCallCheck(this, MDCDrawer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @private {!Element} */
    var _this = _possibleConstructorReturn(this, (_ref = MDCDrawer.__proto__ || Object.getPrototypeOf(MDCDrawer)).call.apply(_ref, [this].concat(args)));

    _this.previousFocus_;

    /** @private {!Function} */
    _this.handleKeydown_;

    /** @private {!Function} */
    _this.handleTransitionEnd_;

    /** @private {!Function} */
    _this.focusTrapFactory_;

    /** @private {!FocusTrapInstance} */
    _this.focusTrap_;

    /** @private {?Element} */
    _this.scrim_;

    /** @private {?Function} */
    _this.handleScrimClick_;

    /** @private {?MDCList} */
    _this.list_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @return {!MDCDrawer}
   */


  _createClass(MDCDrawer, [{
    key: 'initialize',
    value: function initialize() {
      var focusTrapFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : __WEBPACK_IMPORTED_MODULE_8_focus_trap___default.a;
      var listFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
        return new __WEBPACK_IMPORTED_MODULE_4__material_list_index__["MDCList"](el);
      };

      var listEl = /** @type {!Element} */this.root_.querySelector('.' + __WEBPACK_IMPORTED_MODULE_5__material_list_foundation__["a" /* default */].cssClasses.ROOT);
      if (listEl) {
        this.list_ = listFactory(listEl);
        this.list_.wrapFocus = true;
      }
      this.focusTrapFactory_ = focusTrapFactory;
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      var _this2 = this;

      var MODAL = __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__["a" /* default */].cssClasses.MODAL;


      if (this.root_.classList.contains(MODAL)) {
        var SCRIM_SELECTOR = __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__["a" /* default */].strings.SCRIM_SELECTOR;

        this.scrim_ = /** @type {!Element} */this.root_.parentNode.querySelector(SCRIM_SELECTOR);
        this.handleScrimClick_ = function () {
          return (/** @type {!MDCModalDrawerFoundation} */_this2.foundation_.handleScrimClick()
          );
        };
        this.scrim_.addEventListener('click', this.handleScrimClick_);
        this.focusTrap_ = __WEBPACK_IMPORTED_MODULE_7__util__["createFocusTrapInstance"](this.root_, this.focusTrapFactory_);
      }

      this.handleKeydown_ = function (evt) {
        return _this2.foundation_.handleKeydown(evt);
      };
      this.handleTransitionEnd_ = function (evt) {
        return _this2.foundation_.handleTransitionEnd(evt);
      };

      this.root_.addEventListener('keydown', this.handleKeydown_);
      this.root_.addEventListener('transitionend', this.handleTransitionEnd_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.root_.removeEventListener('keydown', this.handleKeydown_);
      this.root_.removeEventListener('transitionend', this.handleTransitionEnd_);

      if (this.list_) {
        this.list_.destroy();
      }

      var MODAL = __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__["a" /* default */].cssClasses.MODAL;

      if (this.root_.classList.contains(MODAL)) {
        this.scrim_.removeEventListener('click', /** @type {!Function} */this.handleScrimClick_);
        // Ensure drawer is closed to hide scrim and release focus
        this.open = false;
      }
    }
  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      var _this3 = this;

      /** @type {!MDCDrawerAdapter} */
      var adapter = /** @type {!MDCDrawerAdapter} */_extends({
        addClass: function addClass(className) {
          return _this3.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this3.root_.classList.remove(className);
        },
        hasClass: function hasClass(className) {
          return _this3.root_.classList.contains(className);
        },
        elementHasClass: function elementHasClass(element, className) {
          return element.classList.contains(className);
        },
        saveFocus: function saveFocus() {
          _this3.previousFocus_ = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          var previousFocus = _this3.previousFocus_ && _this3.previousFocus_.focus;
          if (_this3.root_.contains(document.activeElement) && previousFocus) {
            _this3.previousFocus_.focus();
          }
        },
        focusActiveNavigationItem: function focusActiveNavigationItem() {
          var activeNavItemEl = _this3.root_.querySelector('.' + __WEBPACK_IMPORTED_MODULE_5__material_list_foundation__["a" /* default */].cssClasses.LIST_ITEM_ACTIVATED_CLASS);
          if (activeNavItemEl) {
            activeNavItemEl.focus();
          }
        },
        notifyClose: function notifyClose() {
          return _this3.emit(__WEBPACK_IMPORTED_MODULE_6__constants__["b" /* strings */].CLOSE_EVENT, {}, true /* shouldBubble */);
        },
        notifyOpen: function notifyOpen() {
          return _this3.emit(__WEBPACK_IMPORTED_MODULE_6__constants__["b" /* strings */].OPEN_EVENT, {}, true /* shouldBubble */);
        },
        trapFocus: function trapFocus() {
          return _this3.focusTrap_.activate();
        },
        releaseFocus: function releaseFocus() {
          return _this3.focusTrap_.deactivate();
        }
      });

      var _MDCDismissibleDrawer = __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__["a" /* default */].cssClasses,
          DISMISSIBLE = _MDCDismissibleDrawer.DISMISSIBLE,
          MODAL = _MDCDismissibleDrawer.MODAL;

      if (this.root_.classList.contains(DISMISSIBLE)) {
        return new __WEBPACK_IMPORTED_MODULE_1__dismissible_foundation__["a" /* default */](adapter);
      } else if (this.root_.classList.contains(MODAL)) {
        return new __WEBPACK_IMPORTED_MODULE_2__modal_foundation__["a" /* default */](adapter);
      } else {
        throw new Error('MDCDrawer: Failed to instantiate component. Supported variants are ' + DISMISSIBLE + ' and ' + MODAL + '.');
      }
    }
  }, {
    key: 'open',


    /**
     * Returns true if drawer is in the open position.
     * @return {boolean}
     */
    get: function get() {
      return this.foundation_.isOpen();
    }

    /**
     * Toggles the drawer open and closed.
     * @param {boolean} isOpen
     */
    ,
    set: function set(isOpen) {
      if (isOpen) {
        this.foundation_.open();
      } else {
        this.foundation_.close();
      }
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      return new MDCDrawer(root);
    }
  }]);

  return MDCDrawer;
}(__WEBPACK_IMPORTED_MODULE_0__material_base_component__["a" /* default */]);



/***/ }),

/***/ 107:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dismissible_foundation__ = __webpack_require__(69);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * @extends {MDCDismissibleDrawerFoundation}
 */

var MDCModalDrawerFoundation = function (_MDCDismissibleDrawer) {
  _inherits(MDCModalDrawerFoundation, _MDCDismissibleDrawer);

  function MDCModalDrawerFoundation() {
    _classCallCheck(this, MDCModalDrawerFoundation);

    return _possibleConstructorReturn(this, (MDCModalDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCModalDrawerFoundation)).apply(this, arguments));
  }

  _createClass(MDCModalDrawerFoundation, [{
    key: 'opened',

    /**
     * Called when drawer finishes open animation.
     * @override
     */
    value: function opened() {
      this.adapter_.trapFocus();
    }

    /**
     * Called when drawer finishes close animation.
     * @override
     */

  }, {
    key: 'closed',
    value: function closed() {
      this.adapter_.releaseFocus();
    }

    /**
     * Handles click event on scrim.
     */

  }, {
    key: 'handleScrimClick',
    value: function handleScrimClick() {
      this.close();
    }
  }]);

  return MDCModalDrawerFoundation;
}(__WEBPACK_IMPORTED_MODULE_0__dismissible_foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCModalDrawerFoundation);

/***/ }),

/***/ 108:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFocusTrapInstance", function() { return createFocusTrapInstance; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_focus_trap__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_focus_trap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_focus_trap__);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * @param {!Element} surfaceEl
 * @param {!Function} focusTrapFactory
 * @return {!FocusTrapInstance}
 */
function createFocusTrapInstance(surfaceEl) {
  var focusTrapFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0_focus_trap___default.a;

  return focusTrapFactory(surfaceEl, {
    clickOutsideDeactivates: true,
    initialFocus: false, // Navigation drawer handles focusing on active nav item.
    escapeDeactivates: false, // Navigation drawer handles ESC.
    returnFocusOnDeactivate: false });
}



/***/ }),

/***/ 109:
/***/ (function(module, exports) {

var candidateSelectors = [
  'input',
  'select',
  'textarea',
  'a[href]',
  'button',
  '[tabindex]',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])',
];
var candidateSelector = candidateSelectors.join(',');

var matches = typeof Element === 'undefined'
  ? function () {}
  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

function tabbable(el, options) {
  options = options || {};

  var elementDocument = el.ownerDocument || el;
  var regularTabbables = [];
  var orderedTabbables = [];

  var untouchabilityChecker = new UntouchabilityChecker(elementDocument);
  var candidates = el.querySelectorAll(candidateSelector);

  if (options.includeContainer) {
    if (matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];

    if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;

    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(sortOrderedTabbables)
    .map(function(a) { return a.node })
    .concat(regularTabbables);

  return tabbableNodes;
}

tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;

function isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {
  if (
    !isNodeMatchingSelectorFocusable(node, untouchabilityChecker)
    || isNonTabbableRadio(node)
    || getTabindex(node) < 0
  ) {
    return false;
  }
  return true;
}

function isTabbable(node, untouchabilityChecker) {
  if (!node) throw new Error('No node provided');
  if (matches.call(node, candidateSelector) === false) return false;
  return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);
}

function isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {
  untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);
  if (
    node.disabled
    || isHiddenInput(node)
    || untouchabilityChecker.isUntouchable(node)
  ) {
    return false;
  }
  return true;
}

var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
function isFocusable(node, untouchabilityChecker) {
  if (!node) throw new Error('No node provided');
  if (matches.call(node, focusableCandidateSelector) === false) return false;
  return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);
}

function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
  if (!isNaN(tabindexAttr)) return tabindexAttr;
  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  if (isContentEditable(node)) return 0;
  return node.tabIndex;
}

function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
}

// Array.prototype.find not available in IE.
function find(list, predicate) {
  for (var i = 0, length = list.length; i < length; i++) {
    if (predicate(list[i])) return list[i];
  }
}

function isContentEditable(node) {
  return node.contentEditable === 'true';
}

function isInput(node) {
  return node.tagName === 'INPUT';
}

function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
}

function isRadio(node) {
  return isInput(node) && node.type === 'radio';
}

function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
}

function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}

function isTabbableRadio(node) {
  if (!node.name) return true;
  // This won't account for the edge case where you have radio groups with the same
  // in separate forms on the same page.
  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}

// An element is "untouchable" if *it or one of its ancestors* has
// `visibility: hidden` or `display: none`.
function UntouchabilityChecker(elementDocument) {
  this.doc = elementDocument;
  // Node cache must be refreshed on every check, in case
  // the content of the element has changed. The cache contains tuples
  // mapping nodes to their boolean result.
  this.cache = [];
}

// getComputedStyle accurately reflects `visibility: hidden` of ancestors
// but not `display: none`, so we need to recursively check parents.
UntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {
  if (node.nodeType !== Node.ELEMENT_NODE) return false;

    // Search for a cached result.
    var cached = find(this.cache, function(item) {
      return item === node;
    });
    if (cached) return cached[1];

    nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);

    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = this.hasDisplayNone(node.parentNode);
    }

    this.cache.push([node, result]);

    return result;
}

UntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {
  if (node === this.doc.documentElement) return false;
  var computedStyle = this.doc.defaultView.getComputedStyle(node);
  if (this.hasDisplayNone(node, computedStyle)) return true;
  return computedStyle.visibility === 'hidden';
}

module.exports = tabbable;


/***/ }),

/***/ 11:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* unused harmony export Index */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
var cssClasses = {
  ROOT: 'mdc-list',
  LIST_ITEM_CLASS: 'mdc-list-item',
  LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
  LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
};

/** @enum {string} */
var strings = {
  ARIA_ORIENTATION: 'aria-orientation',
  ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
  ARIA_SELECTED: 'aria-selected',
  ARIA_CHECKED: 'aria-checked',
  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
  RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
  CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: '.' + cssClasses.LIST_ITEM_CLASS + ' button:not(:disabled),\n  .' + cssClasses.LIST_ITEM_CLASS + ' a',
  FOCUSABLE_CHILD_ELEMENTS: '.' + cssClasses.LIST_ITEM_CLASS + ' button:not(:disabled), .' + cssClasses.LIST_ITEM_CLASS + ' a,\n  .' + cssClasses.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n  .' + cssClasses.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled)',
  ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)',
  ACTION_EVENT: 'MDCList:action'
};

/** @typedef {number|!Array<number>} */
var Index = void 0;



/***/ }),

/***/ 110:
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ 15:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(11);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



 // eslint-disable-line no-unused-vars

var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

var MDCListFoundation = function (_MDCFoundation) {
  _inherits(MDCListFoundation, _MDCFoundation);

  _createClass(MDCListFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */];
    }

    /** @return enum {string} */

  }, {
    key: 'cssClasses',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */];
    }

    /**
     * {@see MDCListAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCListAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get() {
      return (/** @type {!MDCListAdapter} */{
          getListItemCount: function getListItemCount() {},
          getFocusedElementIndex: function getFocusedElementIndex() {},
          setAttributeForElementIndex: function setAttributeForElementIndex() {},
          removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
          addClassForElementIndex: function addClassForElementIndex() {},
          removeClassForElementIndex: function removeClassForElementIndex() {},
          focusItemAtIndex: function focusItemAtIndex() {},
          setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
          hasRadioAtIndex: function hasRadioAtIndex() {},
          hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
          isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
          setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
          notifyAction: function notifyAction() {},
          isFocusInsideList: function isFocusInsideList() {}
        }
      );
    }

    /**
     * @param {!MDCListAdapter=} adapter
     */

  }]);

  function MDCListFoundation(adapter) {
    _classCallCheck(this, MDCListFoundation);

    /** @private {boolean} */
    var _this = _possibleConstructorReturn(this, (MDCListFoundation.__proto__ || Object.getPrototypeOf(MDCListFoundation)).call(this, _extends(MDCListFoundation.defaultAdapter, adapter)));

    _this.wrapFocus_ = false;

    /** @private {boolean} */
    _this.isVertical_ = true;

    /** @private {boolean} */
    _this.isSingleSelectionList_ = false;

    /** @private {!Index} */
    _this.selectedIndex_ = -1;

    /** @private {number} */
    _this.focusedItemIndex_ = -1;

    /** @private {boolean} */
    _this.useActivatedClass_ = false;

    /** @private {boolean} */
    _this.isCheckboxList_ = false;

    /** @private {boolean} */
    _this.isRadioList_ = false;
    return _this;
  }

  _createClass(MDCListFoundation, [{
    key: 'layout',
    value: function layout() {
      if (this.adapter_.getListItemCount() === 0) return;

      if (this.adapter_.hasCheckboxAtIndex(0)) {
        this.isCheckboxList_ = true;
      } else if (this.adapter_.hasRadioAtIndex(0)) {
        this.isRadioList_ = true;
      }
    }

    /**
     * Sets the private wrapFocus_ variable.
     * @param {boolean} value
     */

  }, {
    key: 'setWrapFocus',
    value: function setWrapFocus(value) {
      this.wrapFocus_ = value;
    }

    /**
     * Sets the isVertical_ private variable.
     * @param {boolean} value
     */

  }, {
    key: 'setVerticalOrientation',
    value: function setVerticalOrientation(value) {
      this.isVertical_ = value;
    }

    /**
     * Sets the isSingleSelectionList_ private variable.
     * @param {boolean} value
     */

  }, {
    key: 'setSingleSelection',
    value: function setSingleSelection(value) {
      this.isSingleSelectionList_ = value;
    }

    /**
     * Sets the useActivatedClass_ private variable.
     * @param {boolean} useActivated
     */

  }, {
    key: 'setUseActivatedClass',
    value: function setUseActivatedClass(useActivated) {
      this.useActivatedClass_ = useActivated;
    }

    /** @return {!Index} */

  }, {
    key: 'getSelectedIndex',
    value: function getSelectedIndex() {
      return this.selectedIndex_;
    }

    /** @param {!Index} index */

  }, {
    key: 'setSelectedIndex',
    value: function setSelectedIndex(index) {
      if (!this.isIndexValid_(index)) return;

      if (this.isCheckboxList_) {
        this.setCheckboxAtIndex_( /** @type {!Array<number>} */index);
      } else if (this.isRadioList_) {
        this.setRadioAtIndex_( /** @type {number} */index);
      } else {
        this.setSingleSelectionAtIndex_( /** @type {number} */index);
      }
    }

    /**
     * Focus in handler for the list items.
     * @param evt
     * @param {number} listItemIndex
     */

  }, {
    key: 'handleFocusIn',
    value: function handleFocusIn(evt, listItemIndex) {
      if (listItemIndex >= 0) {
        this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
      }
    }

    /**
     * Focus out handler for the list items.
     * @param {Event} evt
     * @param {number} listItemIndex
     */

  }, {
    key: 'handleFocusOut',
    value: function handleFocusOut(evt, listItemIndex) {
      var _this2 = this;

      if (listItemIndex >= 0) {
        this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
      }

      /**
       * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
       * is moved to next element.
       */
      setTimeout(function () {
        if (!_this2.adapter_.isFocusInsideList()) {
          _this2.setTabindexToFirstSelectedItem_();
        }
      }, 0);
    }

    /**
     * Key handler for the list.
     * @param {Event} evt
     * @param {boolean} isRootListItem
     * @param {number} listItemIndex
     */

  }, {
    key: 'handleKeydown',
    value: function handleKeydown(evt, isRootListItem, listItemIndex) {
      var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
      var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
      var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
      var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
      var isHome = evt.key === 'Home' || evt.keyCode === 36;
      var isEnd = evt.key === 'End' || evt.keyCode === 35;
      var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
      var isSpace = evt.key === 'Space' || evt.keyCode === 32;

      var currentIndex = this.adapter_.getFocusedElementIndex();
      var nextIndex = -1;
      if (currentIndex === -1) {
        currentIndex = listItemIndex;
        if (currentIndex < 0) {
          // If this event doesn't have a mdc-list-item ancestor from the
          // current list (not from a sublist), return early.
          return;
        }
      }

      if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
        this.preventDefaultEvent_(evt);
        nextIndex = this.focusNextElement(currentIndex);
      } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
        this.preventDefaultEvent_(evt);
        nextIndex = this.focusPrevElement(currentIndex);
      } else if (isHome) {
        this.preventDefaultEvent_(evt);
        nextIndex = this.focusFirstElement();
      } else if (isEnd) {
        this.preventDefaultEvent_(evt);
        nextIndex = this.focusLastElement();
      } else if (isEnter || isSpace) {
        if (isRootListItem) {
          // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
          if (evt.target.tagName === 'A' && isEnter) return;
          this.preventDefaultEvent_(evt);

          if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(currentIndex);
          }

          this.adapter_.notifyAction(currentIndex);
        }
      }

      this.focusedItemIndex_ = currentIndex;

      if (nextIndex >= 0) {
        this.setTabindexAtIndex_(nextIndex);
        this.focusedItemIndex_ = nextIndex;
      }
    }

    /**
     * Click handler for the list.
     * @param {number} index
     * @param {boolean} toggleCheckbox
     */

  }, {
    key: 'handleClick',
    value: function handleClick(index, toggleCheckbox) {
      if (index === -1) return;

      if (this.isSelectableList_()) {
        this.setSelectedIndexOnAction_(index, toggleCheckbox);
      }

      this.adapter_.notifyAction(index);

      this.setTabindexAtIndex_(index);
      this.focusedItemIndex_ = index;
    }

    /**
     * Ensures that preventDefault is only called if the containing element doesn't
     * consume the event, and it will cause an unintended scroll.
     * @param {Event} evt
     * @private
     */

  }, {
    key: 'preventDefaultEvent_',
    value: function preventDefaultEvent_(evt) {
      var tagName = ('' + evt.target.tagName).toLowerCase();
      if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
        evt.preventDefault();
      }
    }

    /**
     * Focuses the next element on the list.
     * @param {number} index
     * @return {number}
     */

  }, {
    key: 'focusNextElement',
    value: function focusNextElement(index) {
      var count = this.adapter_.getListItemCount();
      var nextIndex = index + 1;
      if (nextIndex >= count) {
        if (this.wrapFocus_) {
          nextIndex = 0;
        } else {
          // Return early because last item is already focused.
          return index;
        }
      }
      this.adapter_.focusItemAtIndex(nextIndex);

      return nextIndex;
    }

    /**
     * Focuses the previous element on the list.
     * @param {number} index
     * @return {number}
     */

  }, {
    key: 'focusPrevElement',
    value: function focusPrevElement(index) {
      var prevIndex = index - 1;
      if (prevIndex < 0) {
        if (this.wrapFocus_) {
          prevIndex = this.adapter_.getListItemCount() - 1;
        } else {
          // Return early because first item is already focused.
          return index;
        }
      }
      this.adapter_.focusItemAtIndex(prevIndex);

      return prevIndex;
    }

    /**
     * @return {number}
     */

  }, {
    key: 'focusFirstElement',
    value: function focusFirstElement() {
      this.adapter_.focusItemAtIndex(0);
      return 0;
    }

    /**
     * @return {number}
     */

  }, {
    key: 'focusLastElement',
    value: function focusLastElement() {
      var lastIndex = this.adapter_.getListItemCount() - 1;
      this.adapter_.focusItemAtIndex(lastIndex);
      return lastIndex;
    }

    /**
     * @param {number} index
     * @private
     */

  }, {
    key: 'setSingleSelectionAtIndex_',
    value: function setSingleSelectionAtIndex_(index) {
      var selectedClassName = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].LIST_ITEM_SELECTED_CLASS;
      if (this.useActivatedClass_) {
        selectedClassName = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].LIST_ITEM_ACTIVATED_CLASS;
      }

      if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
        this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
        this.adapter_.setAttributeForElementIndex(this.selectedIndex_, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */].ARIA_SELECTED, 'false');
      }

      this.adapter_.addClassForElementIndex(index, selectedClassName);
      this.adapter_.setAttributeForElementIndex(index, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */].ARIA_SELECTED, 'true');

      this.selectedIndex_ = index;
    }

    /**
     * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
     * @param {number} index
     * @private
     */

  }, {
    key: 'setRadioAtIndex_',
    value: function setRadioAtIndex_(index) {
      this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

      if (this.selectedIndex_ >= 0) {
        this.adapter_.setAttributeForElementIndex(this.selectedIndex_, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */].ARIA_CHECKED, 'false');
      }

      this.adapter_.setAttributeForElementIndex(index, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */].ARIA_CHECKED, 'true');

      this.selectedIndex_ = index;
    }

    /**
     * @param {!Array<number>} index
     * @private
     */

  }, {
    key: 'setCheckboxAtIndex_',
    value: function setCheckboxAtIndex_(index) {
      for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
        var isChecked = false;
        if (index.indexOf(i) >= 0) {
          isChecked = true;
        }

        this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
        this.adapter_.setAttributeForElementIndex(i, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */].ARIA_CHECKED, isChecked ? 'true' : 'false');
      }

      this.selectedIndex_ = index;
    }

    /**
     * @param {number} index
     * @private
     */

  }, {
    key: 'setTabindexAtIndex_',
    value: function setTabindexAtIndex_(index) {
      if (this.focusedItemIndex_ === -1 && index !== 0) {
        // If no list item was selected set first list item's tabindex to -1.
        // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
        this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
      } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
        this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
      }

      this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
    }

    /**
     * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
     * @private
     */

  }, {
    key: 'isSelectableList_',
    value: function isSelectableList_() {
      return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
    }

    /** @private */

  }, {
    key: 'setTabindexToFirstSelectedItem_',
    value: function setTabindexToFirstSelectedItem_() {
      var targetIndex = 0;

      if (this.isSelectableList_()) {
        if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
          targetIndex = this.selectedIndex_;
        } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
          targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
            return Math.min(currentIndex, minIndex);
          });
        }
      }

      this.setTabindexAtIndex_(targetIndex);
    }

    /**
     * @param {!Index} index
     * @return {boolean}
     * @private
     */

  }, {
    key: 'isIndexValid_',
    value: function isIndexValid_(index) {
      var _this3 = this;

      if (index instanceof Array) {
        if (!this.isCheckboxList_) {
          throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
        }

        if (index.length === 0) {
          return true;
        } else {
          return index.some(function (i) {
            return _this3.isIndexInRange_(i);
          });
        }
      } else if (typeof index === 'number') {
        if (this.isCheckboxList_) {
          throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
        }
        return this.isIndexInRange_(index);
      } else {
        return false;
      }
    }

    /**
     * @param {number} index
     * @return {boolean}
     * @private
     */

  }, {
    key: 'isIndexInRange_',
    value: function isIndexInRange_(index) {
      var listSize = this.adapter_.getListItemCount();
      return index >= 0 && index < listSize;
    }

    /**
     * @param {number} index
     * @param {boolean=} toggleCheckbox
     * @private
     */

  }, {
    key: 'setSelectedIndexOnAction_',
    value: function setSelectedIndexOnAction_(index) {
      var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (this.isCheckboxList_) {
        this.toggleCheckboxAtIndex_(index, toggleCheckbox);
      } else {
        this.setSelectedIndex(index);
      }
    }

    /**
     * @param {number} index
     * @param {boolean} toggleCheckbox
     * @private
     */

  }, {
    key: 'toggleCheckboxAtIndex_',
    value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
      var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

      if (toggleCheckbox) {
        isChecked = !isChecked;
        this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
      }

      this.adapter_.setAttributeForElementIndex(index, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */].ARIA_CHECKED, isChecked ? 'true' : 'false');

      // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.
      if (this.selectedIndex_ === -1) {
        this.selectedIndex_ = [];
      }

      if (isChecked) {
        this.selectedIndex_.push(index);
      } else {
        this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
          return i !== index;
        });
      }
    }
  }]);

  return MDCListFoundation;
}(__WEBPACK_IMPORTED_MODULE_0__material_base_foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCListFoundation);

/***/ }),

/***/ 25:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MDCList", function() { return MDCList; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_component__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__adapter__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__material_dom_ponyfill__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(11);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCListFoundation", function() { return __WEBPACK_IMPORTED_MODULE_1__foundation__["a"]; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





 // eslint-disable-line no-unused-vars

/**
 * @extends MDCComponent<!MDCListFoundation>
 */

var MDCList = function (_MDCComponent) {
  _inherits(MDCList, _MDCComponent);

  /** @param {...?} args */
  function MDCList() {
    var _ref;

    _classCallCheck(this, MDCList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @private {!Function} */
    var _this = _possibleConstructorReturn(this, (_ref = MDCList.__proto__ || Object.getPrototypeOf(MDCList)).call.apply(_ref, [this].concat(args)));

    _this.handleKeydown_;
    /** @private {!Function} */
    _this.handleClick_;
    /** @private {!Function} */
    _this.focusInEventListener_;
    /** @private {!Function} */
    _this.focusOutEventListener_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @return {!MDCList}
   */


  _createClass(MDCList, [{
    key: 'destroy',
    value: function destroy() {
      this.root_.removeEventListener('keydown', this.handleKeydown_);
      this.root_.removeEventListener('click', this.handleClick_);
      this.root_.removeEventListener('focusin', this.focusInEventListener_);
      this.root_.removeEventListener('focusout', this.focusOutEventListener_);
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      this.handleClick_ = this.handleClickEvent_.bind(this);
      this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
      this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
      this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
      this.root_.addEventListener('keydown', this.handleKeydown_);
      this.root_.addEventListener('focusin', this.focusInEventListener_);
      this.root_.addEventListener('focusout', this.focusOutEventListener_);
      this.root_.addEventListener('click', this.handleClick_);
      this.layout();
      this.initializeListType();
    }
  }, {
    key: 'layout',
    value: function layout() {
      var direction = this.root_.getAttribute(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ARIA_ORIENTATION);
      this.vertical = direction !== __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ARIA_ORIENTATION_HORIZONTAL;

      // List items need to have at least tabindex=-1 to be focusable.
      [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
        ele.setAttribute('tabindex', -1);
      });

      // Child button/a elements are not tabbable until the list item is focused.
      [].slice.call(this.root_.querySelectorAll(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
        return ele.setAttribute('tabindex', -1);
      });

      this.foundation_.layout();
    }

    /**
     * Used to figure out which list item this event is targetting. Or returns -1 if
     * there is no list item
     * @param {Event} evt
     * @private
     */

  }, {
    key: 'getListItemIndex_',
    value: function getListItemIndex_(evt) {
      var eventTarget = /** @type {HTMLElement} */evt.target;
      var index = -1;

      // Find the first ancestor that is a list item or the list.
      while (!eventTarget.classList.contains(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].LIST_ITEM_CLASS) && !eventTarget.classList.contains(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].ROOT)) {
        eventTarget = eventTarget.parentElement;
      }

      // Get the index of the element if it is a list item.
      if (eventTarget.classList.contains(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].LIST_ITEM_CLASS)) {
        index = this.listElements.indexOf(eventTarget);
      }

      return index;
    }

    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     * @param {Event} evt
     * @private
     */

  }, {
    key: 'handleFocusInEvent_',
    value: function handleFocusInEvent_(evt) {
      var index = this.getListItemIndex_(evt);
      this.foundation_.handleFocusIn(evt, index);
    }

    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     * @param {Event} evt
     * @private
     */

  }, {
    key: 'handleFocusOutEvent_',
    value: function handleFocusOutEvent_(evt) {
      var index = this.getListItemIndex_(evt);
      this.foundation_.handleFocusOut(evt, index);
    }

    /**
     * Used to figure out which element was focused when keydown event occurred before sending the event to the
     * foundation.
     * @param {Event} evt
     * @private
     */

  }, {
    key: 'handleKeydownEvent_',
    value: function handleKeydownEvent_(evt) {
      var index = this.getListItemIndex_(evt);

      if (index >= 0) {
        this.foundation_.handleKeydown(evt, evt.target.classList.contains(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].LIST_ITEM_CLASS), index);
      }
    }

    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     * @param {Event} evt
     * @private
     */

  }, {
    key: 'handleClickEvent_',
    value: function handleClickEvent_(evt) {
      var index = this.getListItemIndex_(evt);

      // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.
      var toggleCheckbox = !Object(__WEBPACK_IMPORTED_MODULE_3__material_dom_ponyfill__["matches"])( /** @type {!Element} */evt.target, __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].CHECKBOX_RADIO_SELECTOR);
      this.foundation_.handleClick(index, toggleCheckbox);
    }

    /**
     * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
     */

  }, {
    key: 'initializeListType',
    value: function initializeListType() {
      var _this2 = this;

      var checkboxListItems = this.root_.querySelectorAll(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ARIA_ROLE_CHECKBOX_SELECTOR);
      var singleSelectedListItem = this.root_.querySelector('.' + __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].LIST_ITEM_ACTIVATED_CLASS + ',\n        .' + __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].LIST_ITEM_SELECTED_CLASS);
      var radioSelectedListItem = this.root_.querySelector(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ARIA_CHECKED_RADIO_SELECTOR);

      if (checkboxListItems.length) {
        var preselectedItems = this.root_.querySelectorAll(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ARIA_CHECKED_CHECKBOX_SELECTOR);
        this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
          return _this2.listElements.indexOf(listItem);
        });
      } else if (singleSelectedListItem) {
        if (singleSelectedListItem.classList.contains(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].LIST_ITEM_ACTIVATED_CLASS)) {
          this.foundation_.setUseActivatedClass(true);
        }

        this.singleSelection = true;
        this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
      } else if (radioSelectedListItem) {
        this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
      }
    }

    /** @param {boolean} value */

  }, {
    key: 'getDefaultFoundation',


    /** @return {!MDCListFoundation} */
    value: function getDefaultFoundation() {
      var _this3 = this;

      return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* default */]( /** @type {!MDCListAdapter} */_extends({
        getListItemCount: function getListItemCount() {
          return _this3.listElements.length;
        },
        getFocusedElementIndex: function getFocusedElementIndex() {
          return _this3.listElements.indexOf(document.activeElement);
        },
        setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
          var element = _this3.listElements[index];
          if (element) {
            element.setAttribute(attr, value);
          }
        },
        removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
          var element = _this3.listElements[index];
          if (element) {
            element.removeAttribute(attr);
          }
        },
        addClassForElementIndex: function addClassForElementIndex(index, className) {
          var element = _this3.listElements[index];
          if (element) {
            element.classList.add(className);
          }
        },
        removeClassForElementIndex: function removeClassForElementIndex(index, className) {
          var element = _this3.listElements[index];
          if (element) {
            element.classList.remove(className);
          }
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          var element = _this3.listElements[index];
          if (element) {
            element.focus();
          }
        },
        setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
          var element = _this3.listElements[listItemIndex];
          var listItemChildren = [].slice.call(element.querySelectorAll(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
          listItemChildren.forEach(function (ele) {
            return ele.setAttribute('tabindex', tabIndexValue);
          });
        },
        hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
          var listItem = _this3.listElements[index];
          return !!listItem.querySelector(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].CHECKBOX_SELECTOR);
        },
        hasRadioAtIndex: function hasRadioAtIndex(index) {
          var listItem = _this3.listElements[index];
          return !!listItem.querySelector(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].RADIO_SELECTOR);
        },
        isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
          var listItem = _this3.listElements[index];
          var toggleEl = listItem.querySelector(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].CHECKBOX_SELECTOR);
          return toggleEl.checked;
        },
        setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
          var listItem = _this3.listElements[index];
          var toggleEl = listItem.querySelector(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].CHECKBOX_RADIO_SELECTOR);
          toggleEl.checked = isChecked;

          var event = document.createEvent('Event');
          event.initEvent('change', true, true);
          toggleEl.dispatchEvent(event);
        },
        notifyAction: function notifyAction(index) {
          _this3.emit(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ACTION_EVENT, index, /** shouldBubble */true);
        },
        isFocusInsideList: function isFocusInsideList() {
          return _this3.root_.contains(document.activeElement);
        }
      }));
    }
  }, {
    key: 'vertical',
    set: function set(value) {
      this.foundation_.setVerticalOrientation(value);
    }

    /** @return Array<!Element>*/

  }, {
    key: 'listElements',
    get: function get() {
      return [].slice.call(this.root_.querySelectorAll(__WEBPACK_IMPORTED_MODULE_4__constants__["b" /* strings */].ENABLED_ITEMS_SELECTOR));
    }

    /** @param {boolean} value */

  }, {
    key: 'wrapFocus',
    set: function set(value) {
      this.foundation_.setWrapFocus(value);
    }

    /** @param {boolean} isSingleSelectionList */

  }, {
    key: 'singleSelection',
    set: function set(isSingleSelectionList) {
      this.foundation_.setSingleSelection(isSingleSelectionList);
    }

    /** @return {!Index} */

  }, {
    key: 'selectedIndex',
    get: function get() {
      return this.foundation_.getSelectedIndex();
    }

    /** @param {!Index} index */
    ,
    set: function set(index) {
      this.foundation_.setSelectedIndex(index);
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      return new MDCList(root);
    }
  }]);

  return MDCList;
}(__WEBPACK_IMPORTED_MODULE_0__material_base_component__["a" /* default */]);



/***/ }),

/***/ 69:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base_foundation__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(71);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





/**
 * @extends {MDCFoundation<!MDCDrawerAdapter>}
 */

var MDCDismissibleDrawerFoundation = function (_MDCFoundation) {
  _inherits(MDCDismissibleDrawerFoundation, _MDCFoundation);

  _createClass(MDCDismissibleDrawerFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */];
    }

    /** @return enum {string} */

  }, {
    key: 'cssClasses',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */];
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return (/** @type {!MDCDrawerAdapter} */{
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() /* className: string */{},
          elementHasClass: function elementHasClass() /* element: !Element, className: string */{},
          notifyClose: function notifyClose() {},
          notifyOpen: function notifyOpen() {},
          saveFocus: function saveFocus() {},
          restoreFocus: function restoreFocus() {},
          focusActiveNavigationItem: function focusActiveNavigationItem() {},
          trapFocus: function trapFocus() {},
          releaseFocus: function releaseFocus() {}
        }
      );
    }
  }]);

  function MDCDismissibleDrawerFoundation(adapter) {
    _classCallCheck(this, MDCDismissibleDrawerFoundation);

    /** @private {number} */
    var _this = _possibleConstructorReturn(this, (MDCDismissibleDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCDismissibleDrawerFoundation)).call(this, _extends(MDCDismissibleDrawerFoundation.defaultAdapter, adapter)));

    _this.animationFrame_ = 0;

    /** @private {number} */
    _this.animationTimer_ = 0;
    return _this;
  }

  _createClass(MDCDismissibleDrawerFoundation, [{
    key: 'destroy',
    value: function destroy() {
      if (this.animationFrame_) {
        cancelAnimationFrame(this.animationFrame_);
      }
      if (this.animationTimer_) {
        clearTimeout(this.animationTimer_);
      }
    }

    /**
     * Function to open the drawer.
     */

  }, {
    key: 'open',
    value: function open() {
      var _this2 = this;

      if (this.isOpen() || this.isOpening() || this.isClosing()) {
        return;
      }

      this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].OPEN);
      this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].ANIMATE);

      // Wait a frame once display is no longer "none", to establish basis for animation
      this.runNextAnimationFrame_(function () {
        _this2.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].OPENING);
      });

      this.adapter_.saveFocus();
    }

    /**
     * Function to close the drawer.
     */

  }, {
    key: 'close',
    value: function close() {
      if (!this.isOpen() || this.isOpening() || this.isClosing()) {
        return;
      }

      this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].CLOSING);
    }

    /**
     * Extension point for when drawer finishes open animation.
     * @protected
     */

  }, {
    key: 'opened',
    value: function opened() {}

    /**
     * Extension point for when drawer finishes close animation.
     * @protected
     */

  }, {
    key: 'closed',
    value: function closed() {}

    /**
     * Returns true if drawer is in open state.
     * @return {boolean}
     */

  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.adapter_.hasClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].OPEN);
    }

    /**
     * Returns true if drawer is animating open.
     * @return {boolean}
     */

  }, {
    key: 'isOpening',
    value: function isOpening() {
      return this.adapter_.hasClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].OPENING) || this.adapter_.hasClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].ANIMATE);
    }

    /**
     * Returns true if drawer is animating closed.
     * @return {boolean}
     */

  }, {
    key: 'isClosing',
    value: function isClosing() {
      return this.adapter_.hasClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].CLOSING);
    }

    /**
     * Keydown handler to close drawer when key is escape.
     * @param evt
     */

  }, {
    key: 'handleKeydown',
    value: function handleKeydown(evt) {
      var keyCode = evt.keyCode,
          key = evt.key;


      var isEscape = key === 'Escape' || keyCode === 27;
      if (isEscape) {
        this.close();
      }
    }

    /**
     * Handles a transition end event on the root element.
     * @param {!Event} evt
     */

  }, {
    key: 'handleTransitionEnd',
    value: function handleTransitionEnd(evt) {
      var OPENING = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].OPENING,
          CLOSING = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].CLOSING,
          OPEN = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].OPEN,
          ANIMATE = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].ANIMATE,
          ROOT = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].ROOT;

      // In Edge, transitionend on ripple pseudo-elements yields a target without classList, so check for Element first.

      var isElement = evt.target instanceof Element;
      if (!isElement || !this.adapter_.elementHasClass( /** @type {!Element} */evt.target, ROOT)) {
        return;
      }

      if (this.isClosing()) {
        this.adapter_.removeClass(OPEN);
        this.closed();
        this.adapter_.restoreFocus();
        this.adapter_.notifyClose();
      } else {
        this.adapter_.focusActiveNavigationItem();
        this.opened();
        this.adapter_.notifyOpen();
      }

      this.adapter_.removeClass(ANIMATE);
      this.adapter_.removeClass(OPENING);
      this.adapter_.removeClass(CLOSING);
    }

    /**
     * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
     * @param {Function} callback
     * @private
     */

  }, {
    key: 'runNextAnimationFrame_',
    value: function runNextAnimationFrame_(callback) {
      var _this3 = this;

      cancelAnimationFrame(this.animationFrame_);
      this.animationFrame_ = requestAnimationFrame(function () {
        _this3.animationFrame_ = 0;
        clearTimeout(_this3.animationTimer_);
        _this3.animationTimer_ = setTimeout(callback, 0);
      });
    }
  }]);

  return MDCDismissibleDrawerFoundation;
}(__WEBPACK_IMPORTED_MODULE_1__material_base_foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCDismissibleDrawerFoundation);

/***/ }),

/***/ 70:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Drawer
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Drawer into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCDrawerAdapter = function () {
  function MDCDrawerAdapter() {
    _classCallCheck(this, MDCDrawerAdapter);
  }

  _createClass(MDCDrawerAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the root Element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the root Element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns true if the root Element contains the given class.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /**
     * @param {!Element} element target element to verify class name
     * @param {string} className class name
     */

  }, {
    key: "elementHasClass",
    value: function elementHasClass(element, className) {}

    /**
     * Saves the focus of currently active element.
     */

  }, {
    key: "saveFocus",
    value: function saveFocus() {}

    /**
     * Restores focus to element previously saved with 'saveFocus'.
     */

  }, {
    key: "restoreFocus",
    value: function restoreFocus() {}

    /**
     * Focuses the active / selected navigation item.
     */

  }, {
    key: "focusActiveNavigationItem",
    value: function focusActiveNavigationItem() {}

    /**
     * Emits a custom event "MDCDrawer:closed" denoting the drawer has closed.
     */

  }, {
    key: "notifyClose",
    value: function notifyClose() {}

    /**
     * Emits a custom event "MDCDrawer:opened" denoting the drawer has opened.
     */

  }, {
    key: "notifyOpen",
    value: function notifyOpen() {}

    /**
     * Traps focus on root element and focuses the active navigation element.
     */

  }, {
    key: "trapFocus",
    value: function trapFocus() {}

    /**
     * Releases focus trap from root element which was set by `trapFocus`
     * and restores focus to where it was prior to calling `trapFocus`.
     */

  }, {
    key: "releaseFocus",
    value: function releaseFocus() {}
  }]);

  return MDCDrawerAdapter;
}();

/* unused harmony default export */ var _unused_webpack_default_export = (MDCDrawerAdapter);

/***/ }),

/***/ 71:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return strings; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/** @enum {string} */
var cssClasses = {
  ROOT: 'mdc-drawer',
  DISMISSIBLE: 'mdc-drawer--dismissible',
  MODAL: 'mdc-drawer--modal',
  OPEN: 'mdc-drawer--open',
  ANIMATE: 'mdc-drawer--animate',
  OPENING: 'mdc-drawer--opening',
  CLOSING: 'mdc-drawer--closing'
};

/** @enum {string} */
var strings = {
  APP_CONTENT_SELECTOR: '.mdc-drawer-app-content',
  SCRIM_SELECTOR: '.mdc-drawer-scrim',
  CLOSE_EVENT: 'MDCDrawer:closed',
  OPEN_EVENT: 'MDCDrawer:opened'
};



/***/ }),

/***/ 72:
/***/ (function(module, exports, __webpack_require__) {

var tabbable = __webpack_require__(109);
var xtend = __webpack_require__(110);

var activeFocusTraps = (function() {
  var trapQueue = [];
  return {
    activateTrap: function(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }

      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        // move this existing trap to the front of the queue
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },

    deactivateTrap: function(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }

      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
})();

function focusTrap(element, userOptions) {
  var doc = document;
  var container =
    typeof element === 'string' ? doc.querySelector(element) : element;

  var config = xtend(
    {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    },
    userOptions
  );

  var state = {
    firstTabbableNode: null,
    lastTabbableNode: null,
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false
  };

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (state.active) return;

    updateTabbableNodes();

    state.active = true;
    state.paused = false;
    state.nodeFocusedBeforeActivation = doc.activeElement;

    var onActivate =
      activateOptions && activateOptions.onActivate
        ? activateOptions.onActivate
        : config.onActivate;
    if (onActivate) {
      onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!state.active) return;

    removeListeners();
    state.active = false;
    state.paused = false;

    activeFocusTraps.deactivateTrap(trap);

    var onDeactivate =
      deactivateOptions && deactivateOptions.onDeactivate !== undefined
        ? deactivateOptions.onDeactivate
        : config.onDeactivate;
    if (onDeactivate) {
      onDeactivate();
    }

    var returnFocus =
      deactivateOptions && deactivateOptions.returnFocus !== undefined
        ? deactivateOptions.returnFocus
        : config.returnFocusOnDeactivate;
    if (returnFocus) {
      delay(function() {
        tryFocus(state.nodeFocusedBeforeActivation);
      });
    }

    return trap;
  }

  function pause() {
    if (state.paused || !state.active) return;
    state.paused = true;
    removeListeners();
  }

  function unpause() {
    if (!state.paused || !state.active) return;
    state.paused = false;
    addListeners();
  }

  function addListeners() {
    if (!state.active) return;

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trap);

    updateTabbableNodes();

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    delay(function() {
      tryFocus(getInitialFocusNode());
    });
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, true);
    doc.addEventListener('touchstart', checkPointerDown, true);
    doc.addEventListener('click', checkClick, true);
    doc.addEventListener('keydown', checkKey, true);

    return trap;
  }

  function removeListeners() {
    if (!state.active) return;

    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function getInitialFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(doc.activeElement)) {
      node = doc.activeElement;
    } else {
      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error(
        "You can't have a focus-trap without at least one focusable element"
      );
    }

    return node;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  function checkPointerDown(e) {
    if (container.contains(e.target)) return;
    if (config.clickOutsideDeactivates) {
      deactivate({
        returnFocus: !tabbable.isFocusable(e.target)
      });
    } else {
      e.preventDefault();
    }
  }

  // In case focus escapes the trap for some strange reason, pull it back in.
  function checkFocusIn(e) {
    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (container.contains(e.target) || e.target instanceof Document) {
      return;
    }
    e.stopImmediatePropagation();
    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
  }

  function checkKey(e) {
    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      e.preventDefault();
      deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  }

  // Hijack Tab events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  function checkTab(e) {
    updateTabbableNodes();
    if (e.shiftKey && e.target === state.firstTabbableNode) {
      e.preventDefault();
      tryFocus(state.lastTabbableNode);
      return;
    }
    if (!e.shiftKey && e.target === state.lastTabbableNode) {
      e.preventDefault();
      tryFocus(state.firstTabbableNode);
      return;
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function updateTabbableNodes() {
    var tabbableNodes = tabbable(container);
    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
    state.lastTabbableNode =
      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
  }

  function tryFocus(node) {
    if (node === doc.activeElement) return;
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }

    node.focus();
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  }
}

function isSelectableInput(node) {
  return (
    node.tagName &&
    node.tagName.toLowerCase() === 'input' &&
    typeof node.select === 'function'
  );
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
}

function delay(fn) {
  return setTimeout(fn, 0);
}

module.exports = focusTrap;


/***/ }),

/***/ 8:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closest", function() { return closest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return matches; });
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */

/**
 * @param {!Element} element
 * @param {string} selector
 * @return {?Element}
 */
function closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }

  var el = element;
  while (el) {
    if (matches(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}

/**
 * @param {!Element} element
 * @param {string} selector
 * @return {boolean}
 */
function matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}



/***/ })

/******/ });
});

},{}],"../node_modules/@material/top-app-bar/dist/mdc.topAppBar.js":[function(require,module,exports) {
var define;
/*!
 Material Components for the Web
 Copyright (c) 2019 Google Inc.
 License: MIT
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["topAppBar"] = factory();
	else
		root["mdc"] = root["mdc"] || {}, root["mdc"]["topAppBar"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 170);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
var MDCFoundation = function () {
  _createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }

    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }

    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }

    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }

    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  _createClass(MDCFoundation, [{
    key: "init",
    value: function init() {
      // Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);

  return MDCFoundation;
}();

/* harmony default export */ __webpack_exports__["a"] = (MDCFoundation);

/***/ }),

/***/ 1:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foundation__ = __webpack_require__(0);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * @template F
 */

var MDCComponent = function () {
  _createClass(MDCComponent, null, [{
    key: 'attachTo',

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new __WEBPACK_IMPORTED_MODULE_0__foundation__["a" /* default */]());
    }

    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args);
    // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.
    /** @protected {!F} */
    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  _createClass(MDCComponent, [{
    key: 'initialize',
    value: function initialize() /* ...args */{}
    // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.


    /**
     * @return {!F} foundation
     */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      // Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }

    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'listen',
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }

    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'unlisten',
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }

    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: 'emit',
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var evt = void 0;
      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);

  return MDCComponent;
}();

/* harmony default export */ __webpack_exports__["a"] = (MDCComponent);

/***/ }),

/***/ 170:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MDCTopAppBar", function() { return MDCTopAppBar; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base_component__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ripple_index__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__fixed_foundation__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__short_foundation__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__standard_foundation__ = __webpack_require__(173);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCTopAppBarBaseFoundation", function() { return __WEBPACK_IMPORTED_MODULE_4__foundation__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCTopAppBarFoundation", function() { return __WEBPACK_IMPORTED_MODULE_7__standard_foundation__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCFixedTopAppBarFoundation", function() { return __WEBPACK_IMPORTED_MODULE_5__fixed_foundation__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCShortTopAppBarFoundation", function() { return __WEBPACK_IMPORTED_MODULE_6__short_foundation__["a"]; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */










/**
 * @extends {MDCComponent<!MDCTopAppBarBaseFoundation>}
 * @final
 */

var MDCTopAppBar = function (_MDCComponent) {
  _inherits(MDCTopAppBar, _MDCComponent);

  /**
   * @param {...?} args
   */
  function MDCTopAppBar() {
    var _ref;

    _classCallCheck(this, MDCTopAppBar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @private {?Element} */
    var _this = _possibleConstructorReturn(this, (_ref = MDCTopAppBar.__proto__ || Object.getPrototypeOf(MDCTopAppBar)).call.apply(_ref, [this].concat(args)));

    _this.navIcon_;
    /** @type {?Array<MDCRipple>} */
    _this.iconRipples_;
    /** @type {Object} */
    _this.scrollTarget_;
    return _this;
  }

  _createClass(MDCTopAppBar, [{
    key: 'initialize',
    value: function initialize() {
      var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
        return __WEBPACK_IMPORTED_MODULE_2__material_ripple_index__["MDCRipple"].attachTo(el);
      };

      this.navIcon_ = this.root_.querySelector(__WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].NAVIGATION_ICON_SELECTOR);

      // Get all icons in the toolbar and instantiate the ripples
      var icons = [].slice.call(this.root_.querySelectorAll(__WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].ACTION_ITEM_SELECTOR));
      if (this.navIcon_) {
        icons.push(this.navIcon_);
      }

      this.iconRipples_ = icons.map(function (icon) {
        var ripple = rippleFactory(icon);
        ripple.unbounded = true;
        return ripple;
      });

      this.scrollTarget_ = window;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.iconRipples_.forEach(function (iconRipple) {
        return iconRipple.destroy();
      });
      _get(MDCTopAppBar.prototype.__proto__ || Object.getPrototypeOf(MDCTopAppBar.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'setScrollTarget',
    value: function setScrollTarget(target) {
      this.foundation_.destroyScrollHandler();
      this.scrollTarget_ = target;
      this.foundation_.initScrollHandler();
    }

    /**
     * @param {!Element} root
     * @return {!MDCTopAppBar}
     */

  }, {
    key: 'getDefaultFoundation',


    /**
     * @return {!MDCTopAppBarBaseFoundation}
     */
    value: function getDefaultFoundation() {
      var _this2 = this;

      /** @type {!MDCTopAppBarAdapter} */
      var adapter = /** @type {!MDCTopAppBarAdapter} */_extends({
        hasClass: function hasClass(className) {
          return _this2.root_.classList.contains(className);
        },
        addClass: function addClass(className) {
          return _this2.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this2.root_.classList.remove(className);
        },
        setStyle: function setStyle(property, value) {
          return _this2.root_.style.setProperty(property, value);
        },
        getTopAppBarHeight: function getTopAppBarHeight() {
          return _this2.root_.clientHeight;
        },
        registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(evtType, handler) {
          if (_this2.navIcon_) {
            _this2.navIcon_.addEventListener(evtType, handler);
          }
        },
        deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(evtType, handler) {
          if (_this2.navIcon_) {
            _this2.navIcon_.removeEventListener(evtType, handler);
          }
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          _this2.emit(__WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].NAVIGATION_EVENT, {});
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          return _this2.scrollTarget_.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          return _this2.scrollTarget_.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        getViewportScrollY: function getViewportScrollY() {
          return _this2.scrollTarget_[_this2.scrollTarget_ === window ? 'pageYOffset' : 'scrollTop'];
        },
        getTotalActionItems: function getTotalActionItems() {
          return _this2.root_.querySelectorAll(__WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].ACTION_ITEM_SELECTOR).length;
        }
      });

      /** @type {!MDCTopAppBarBaseFoundation} */
      var foundation = void 0;
      if (this.root_.classList.contains(__WEBPACK_IMPORTED_MODULE_3__constants__["a" /* cssClasses */].SHORT_CLASS)) {
        foundation = new __WEBPACK_IMPORTED_MODULE_6__short_foundation__["a" /* default */](adapter);
      } else if (this.root_.classList.contains(__WEBPACK_IMPORTED_MODULE_3__constants__["a" /* cssClasses */].FIXED_CLASS)) {
        foundation = new __WEBPACK_IMPORTED_MODULE_5__fixed_foundation__["a" /* default */](adapter);
      } else {
        foundation = new __WEBPACK_IMPORTED_MODULE_7__standard_foundation__["a" /* default */](adapter);
      }

      return foundation;
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      return new MDCTopAppBar(root);
    }
  }]);

  return MDCTopAppBar;
}(__WEBPACK_IMPORTED_MODULE_1__material_base_component__["a" /* default */]);



/***/ }),

/***/ 171:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation__ = __webpack_require__(44);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





/**
 * @extends {MDCTopAppBarFoundation<!MDCFixedTopAppBarFoundation>}
 * @final
 */

var MDCFixedTopAppBarFoundation = function (_MDCTopAppBarFoundati) {
  _inherits(MDCFixedTopAppBarFoundation, _MDCTopAppBarFoundati);

  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  function MDCFixedTopAppBarFoundation(adapter) {
    _classCallCheck(this, MDCFixedTopAppBarFoundation);

    /** State variable for the previous scroll iteration top app bar state */
    var _this = _possibleConstructorReturn(this, (MDCFixedTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCFixedTopAppBarFoundation)).call(this, adapter));

    _this.wasScrolled_ = false;

    _this.scrollHandler_ = function () {
      return _this.fixedScrollHandler_();
    };
    return _this;
  }

  _createClass(MDCFixedTopAppBarFoundation, [{
    key: 'init',
    value: function init() {
      _get(MDCFixedTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCFixedTopAppBarFoundation.prototype), 'init', this).call(this);
      this.adapter_.registerScrollHandler(this.scrollHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(MDCFixedTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCFixedTopAppBarFoundation.prototype), 'destroy', this).call(this);
      this.adapter_.deregisterScrollHandler(this.scrollHandler_);
    }

    /**
     * Scroll handler for applying/removing the modifier class
     * on the fixed top app bar.
     */

  }, {
    key: 'fixedScrollHandler_',
    value: function fixedScrollHandler_() {
      var currentScroll = this.adapter_.getViewportScrollY();

      if (currentScroll <= 0) {
        if (this.wasScrolled_) {
          this.adapter_.removeClass(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */].FIXED_SCROLLED_CLASS);
          this.wasScrolled_ = false;
        }
      } else {
        if (!this.wasScrolled_) {
          this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */].FIXED_SCROLLED_CLASS);
          this.wasScrolled_ = true;
        }
      }
    }
  }]);

  return MDCFixedTopAppBarFoundation;
}(__WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCFixedTopAppBarFoundation);

/***/ }),

/***/ 172:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(43);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





/**
 * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
 * @final
 */

var MDCShortTopAppBarFoundation = function (_MDCTopAppBarBaseFoun) {
  _inherits(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  function MDCShortTopAppBarFoundation(adapter) {
    _classCallCheck(this, MDCShortTopAppBarFoundation);

    // State variable for the current top app bar state
    var _this = _possibleConstructorReturn(this, (MDCShortTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation)).call(this, adapter));

    _this.isCollapsed = false;

    _this.scrollHandler_ = function () {
      return _this.shortAppBarScrollHandler_();
    };
    return _this;
  }

  _createClass(MDCShortTopAppBarFoundation, [{
    key: 'init',
    value: function init() {
      _get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'init', this).call(this);
      var isAlwaysCollapsed = this.adapter_.hasClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].SHORT_COLLAPSED_CLASS);

      if (this.adapter_.getTotalActionItems() > 0) {
        this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].SHORT_HAS_ACTION_ITEM_CLASS);
      }

      if (!isAlwaysCollapsed) {
        this.adapter_.registerScrollHandler(this.scrollHandler_);
        this.shortAppBarScrollHandler_();
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'destroy', this).call(this);
      this.adapter_.deregisterScrollHandler(this.scrollHandler_);
    }

    /**
     * Scroll handler for applying/removing the collapsed modifier class
     * on the short top app bar.
     * @private
     */

  }, {
    key: 'shortAppBarScrollHandler_',
    value: function shortAppBarScrollHandler_() {
      var currentScroll = this.adapter_.getViewportScrollY();

      if (currentScroll <= 0) {
        if (this.isCollapsed) {
          this.adapter_.removeClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].SHORT_COLLAPSED_CLASS);
          this.isCollapsed = false;
        }
      } else {
        if (!this.isCollapsed) {
          this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */].SHORT_COLLAPSED_CLASS);
          this.isCollapsed = true;
        }
      }
    }
  }]);

  return MDCShortTopAppBarFoundation;
}(__WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCShortTopAppBarFoundation);

/***/ }),

/***/ 173:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(43);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





var INITIAL_VALUE = 0;
/**
 * @extends {MDCTopAppBarBaseFoundation<!MDCTopAppBarFoundation>}
 * @final
 */

var MDCTopAppBarFoundation = function (_MDCTopAppBarBaseFoun) {
  _inherits(MDCTopAppBarFoundation, _MDCTopAppBarBaseFoun);

  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  function MDCTopAppBarFoundation(adapter) {
    _classCallCheck(this, MDCTopAppBarFoundation);

    /**
     * Used for diffs of current scroll position vs previous scroll position
     * @private {number}
     */
    var _this = _possibleConstructorReturn(this, (MDCTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCTopAppBarFoundation)).call(this, adapter));

    _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();

    /**
     * Used to verify when the top app bar is completely showing or completely hidden
     * @private {number}
     */
    _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();

    /**
     * wasDocked_ is used to indicate if the top app bar was docked in the previous
     * scroll handler iteration.
     * @private {boolean}
     */
    _this.wasDocked_ = true;

    /**
     * isDockedShowing_ is used to indicate if the top app bar is docked in the fully
     * shown position.
     * @private {boolean}
     */
    _this.isDockedShowing_ = true;

    /**
     * Variable for current scroll position of the top app bar
     * @private {number}
     */
    _this.currentAppBarOffsetTop_ = 0;

    /**
     * Used to prevent the top app bar from being scrolled out of view during resize events
     * @private {boolean} */
    _this.isCurrentlyBeingResized_ = false;

    /**
     * The timeout that's used to throttle the resize events
     * @private {number}
     */
    _this.resizeThrottleId_ = INITIAL_VALUE;

    /**
     * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
     * @private {number}
     */
    _this.resizeDebounceId_ = INITIAL_VALUE;

    _this.scrollHandler_ = function () {
      return _this.topAppBarScrollHandler_();
    };
    _this.resizeHandler_ = function () {
      return _this.topAppBarResizeHandler_();
    };
    return _this;
  }

  _createClass(MDCTopAppBarFoundation, [{
    key: 'init',
    value: function init() {
      _get(MDCTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTopAppBarFoundation.prototype), 'init', this).call(this);
      this.adapter_.registerScrollHandler(this.scrollHandler_);
      this.adapter_.registerResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(MDCTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTopAppBarFoundation.prototype), 'destroy', this).call(this);
      this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      this.adapter_.setStyle('top', '');
    }

    /**
     * Function to determine if the DOM needs to update.
     * @return {boolean}
     * @private
     */

  }, {
    key: 'checkForUpdate_',
    value: function checkForUpdate_() {
      var offscreenBoundaryTop = -this.topAppBarHeight_;
      var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
      var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
      var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;

      // If it's partially showing, it can't be docked.
      if (partiallyShowing) {
        this.wasDocked_ = false;
      } else {
        // Not previously docked and not partially showing, it's now docked.
        if (!this.wasDocked_) {
          this.wasDocked_ = true;
          return true;
        } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
          this.isDockedShowing_ = hasAnyPixelsOnscreen;
          return true;
        }
      }

      return partiallyShowing;
    }

    /**
     * Function to move the top app bar if needed.
     * @private
     */

  }, {
    key: 'moveTopAppBar_',
    value: function moveTopAppBar_() {
      if (this.checkForUpdate_()) {
        // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
        // so the top app bar doesn't show if the window resizes and the new height > the old height.
        var offset = this.currentAppBarOffsetTop_;
        if (Math.abs(offset) >= this.topAppBarHeight_) {
          offset = -__WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */].MAX_TOP_APP_BAR_HEIGHT;
        }

        this.adapter_.setStyle('top', offset + 'px');
      }
    }

    /**
     * Scroll handler for the default scroll behavior of the top app bar.
     * @private
     */

  }, {
    key: 'topAppBarScrollHandler_',
    value: function topAppBarScrollHandler_() {
      var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
      var diff = currentScrollPosition - this.lastScrollPosition_;
      this.lastScrollPosition_ = currentScrollPosition;

      // If the window is being resized the lastScrollPosition_ needs to be updated but the
      // current scroll of the top app bar should stay in the same position.
      if (!this.isCurrentlyBeingResized_) {
        this.currentAppBarOffsetTop_ -= diff;

        if (this.currentAppBarOffsetTop_ > 0) {
          this.currentAppBarOffsetTop_ = 0;
        } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
          this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
        }

        this.moveTopAppBar_();
      }
    }

    /**
     * Top app bar resize handler that throttle/debounce functions that execute updates.
     * @private
     */

  }, {
    key: 'topAppBarResizeHandler_',
    value: function topAppBarResizeHandler_() {
      var _this2 = this;

      // Throttle resize events 10 p/s
      if (!this.resizeThrottleId_) {
        this.resizeThrottleId_ = setTimeout(function () {
          _this2.resizeThrottleId_ = INITIAL_VALUE;
          _this2.throttledResizeHandler_();
        }, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */].DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
      }

      this.isCurrentlyBeingResized_ = true;

      if (this.resizeDebounceId_) {
        clearTimeout(this.resizeDebounceId_);
      }

      this.resizeDebounceId_ = setTimeout(function () {
        _this2.topAppBarScrollHandler_();
        _this2.isCurrentlyBeingResized_ = false;
        _this2.resizeDebounceId_ = INITIAL_VALUE;
      }, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */].DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    }

    /**
     * Throttled function that updates the top app bar scrolled values if the
     * top app bar height changes.
     * @private
     */

  }, {
    key: 'throttledResizeHandler_',
    value: function throttledResizeHandler_() {
      var currentHeight = this.adapter_.getTopAppBarHeight();
      if (this.topAppBarHeight_ !== currentHeight) {
        this.wasDocked_ = false;

        // Since the top app bar has a different height depending on the screen width, this
        // will ensure that the top app bar remains in the correct location if
        // completely hidden and a resize makes the top app bar a different height.
        this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
        this.topAppBarHeight_ = currentHeight;
      }
      this.topAppBarScrollHandler_();
    }
  }]);

  return MDCTopAppBarFoundation;
}(__WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCTopAppBarFoundation);

/***/ }),

/***/ 2:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsCssVariables", function() { return supportsCssVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPassive", function() { return applyPassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatchesProperty", function() { return getMatchesProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNormalizedEventCoords", function() { return getNormalizedEventCoords; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
var supportsCssVariables_ = void 0;

/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */
var supportsPassive_ = void 0;

/**
 * @param {!Window} windowObj
 * @return {boolean}
 */
function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  var document = windowObj.document;
  var node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node);

  // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  var computedStyle = windowObj.getComputedStyle(node);
  var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}

/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */

function supportsCssVariables(windowObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var supportsCssVariables = supportsCssVariables_;
  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables;
  }

  var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
  if (!supportsFunctionPresent) {
    return;
  }

  var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
  // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari
  var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables = false;
  }

  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVariables;
  }
  return supportsCssVariables;
}

//
/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|!EventListenerOptions}
 */
function applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
          return isSupported;
        } });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? /** @type {!EventListenerOptions} */{ passive: true } : false;
}

/**
 * @param {!Object} HTMLElementPrototype
 * @return {string}
 */
function getMatchesProperty(HTMLElementPrototype) {
  /**
   * Order is important because we return the first existing method we find.
   * Do not change the order of the items in the below array.
   */
  var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
  var method = 'matches';
  for (var i = 0; i < matchesMethods.length; i++) {
    var matchesMethod = matchesMethods[i];
    if (matchesMethod in HTMLElementPrototype) {
      method = matchesMethod;
      break;
    }
  }

  return method;
}

/**
 * @param {!Event} ev
 * @param {{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {{x: number, y: number}}
 */
function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  var x = pageOffset.x,
      y = pageOffset.y;

  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;

  var normalizedX = void 0;
  var normalizedY = void 0;
  // Determine touch point relative to the ripple container.
  if (ev.type === 'touchstart') {
    ev = /** @type {!TouchEvent} */ev;
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    ev = /** @type {!MouseEvent} */ev;
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return { x: normalizedX, y: normalizedY };
}



/***/ }),

/***/ 3:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Ripple. Provides an interface for managing
 * - classes
 * - dom
 * - CSS variables
 * - position
 * - dimensions
 * - scroll position
 * - event handlers
 * - unbounded, active and disabled states
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCRippleAdapter = function () {
  function MDCRippleAdapter() {
    _classCallCheck(this, MDCRippleAdapter);
  }

  _createClass(MDCRippleAdapter, [{
    key: "browserSupportsCssVars",

    /** @return {boolean} */
    value: function browserSupportsCssVars() {}

    /** @return {boolean} */

  }, {
    key: "isUnbounded",
    value: function isUnbounded() {}

    /** @return {boolean} */

  }, {
    key: "isSurfaceActive",
    value: function isSurfaceActive() {}

    /** @return {boolean} */

  }, {
    key: "isSurfaceDisabled",
    value: function isSurfaceDisabled() {}

    /** @param {string} className */

  }, {
    key: "addClass",
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /** @param {!EventTarget} target */

  }, {
    key: "containsEventTarget",
    value: function containsEventTarget(target) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerDocumentInteractionHandler",
    value: function registerDocumentInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterDocumentInteractionHandler",
    value: function deregisterDocumentInteractionHandler(evtType, handler) {}

    /**
     * @param {!Function} handler
     */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}

    /**
     * @param {!Function} handler
     */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}

    /**
     * @param {string} varName
     * @param {?number|string} value
     */

  }, {
    key: "updateCssVariable",
    value: function updateCssVariable(varName, value) {}

    /** @return {!ClientRect} */

  }, {
    key: "computeBoundingRect",
    value: function computeBoundingRect() {}

    /** @return {{x: number, y: number}} */

  }, {
    key: "getWindowPageOffset",
    value: function getWindowPageOffset() {}
  }]);

  return MDCRippleAdapter;
}();

/* unused harmony default export */ var _unused_webpack_default_export = (MDCRippleAdapter);

/***/ }),

/***/ 4:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MDCRipple", function() { return MDCRipple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RippleCapableSurface", function() { return RippleCapableSurface; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_component__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(2);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MDCRippleFoundation", function() { return __WEBPACK_IMPORTED_MODULE_2__foundation__["a"]; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "util", function() { return __WEBPACK_IMPORTED_MODULE_3__util__; });
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */






/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */

var MDCRipple = function (_MDCComponent) {
  _inherits(MDCRipple, _MDCComponent);

  /** @param {...?} args */
  function MDCRipple() {
    var _ref;

    _classCallCheck(this, MDCRipple);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @type {boolean} */
    var _this = _possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

    _this.disabled = false;

    /** @private {boolean} */
    _this.unbounded_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */


  _createClass(MDCRipple, [{
    key: 'setUnbounded_',


    /**
     * Closure Compiler throws an access control error when directly accessing a
     * protected or private property inside a getter/setter, like unbounded above.
     * By accessing the protected property inside a method, we solve that problem.
     * That's why this function exists.
     * @private
     */
    value: function setUnbounded_() {
      this.foundation_.setUnbounded(this.unbounded_);
    }
  }, {
    key: 'activate',
    value: function activate() {
      this.foundation_.activate();
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.foundation_.deactivate();
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.foundation_.layout();
    }

    /**
     * @return {!MDCRippleFoundation}
     * @override
     */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      return new __WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */](MDCRipple.createAdapter(this));
    }

    /** @override */

  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
    }
  }, {
    key: 'unbounded',


    /** @return {boolean} */
    get: function get() {
      return this.unbounded_;
    }

    /** @param {boolean} unbounded */
    ,
    set: function set(unbounded) {
      this.unbounded_ = Boolean(unbounded);
      this.setUnbounded_();
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$isUnbounded = _ref2.isUnbounded,
          isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

      var ripple = new MDCRipple(root);
      // Only override unbounded behavior if option is explicitly specified
      if (isUnbounded !== undefined) {
        ripple.unbounded = /** @type {boolean} */isUnbounded;
      }
      return ripple;
    }

    /**
     * @param {!RippleCapableSurface} instance
     * @return {!MDCRippleAdapter}
     */

  }, {
    key: 'createAdapter',
    value: function createAdapter(instance) {
      var MATCHES = __WEBPACK_IMPORTED_MODULE_3__util__["getMatchesProperty"](HTMLElement.prototype);

      return {
        browserSupportsCssVars: function browserSupportsCssVars() {
          return __WEBPACK_IMPORTED_MODULE_3__util__["supportsCssVariables"](window);
        },
        isUnbounded: function isUnbounded() {
          return instance.unbounded;
        },
        isSurfaceActive: function isSurfaceActive() {
          return instance.root_[MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return instance.disabled;
        },
        addClass: function addClass(className) {
          return instance.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return instance.root_.classList.remove(className);
        },
        containsEventTarget: function containsEventTarget(target) {
          return instance.root_.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          return instance.root_.addEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["applyPassive"]());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          return instance.root_.removeEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["applyPassive"]());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["applyPassive"]());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["applyPassive"]());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          return instance.root_.style.setProperty(varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return instance.root_.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      };
    }
  }]);

  return MDCRipple;
}(__WEBPACK_IMPORTED_MODULE_0__material_base_component__["a" /* default */]);

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */


var RippleCapableSurface = function RippleCapableSurface() {
  _classCallCheck(this, RippleCapableSurface);
};

/** @protected {!Element} */


RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;



/***/ }),

/***/ 42:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Top App Bar
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Top App Bar into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTopAppBarAdapter = function () {
  function MDCTopAppBarAdapter() {
    _classCallCheck(this, MDCTopAppBarAdapter);
  }

  _createClass(MDCTopAppBarAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the root Element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the root Element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns true if the root Element contains the given class.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /**
     * Sets the specified inline style property on the root Element to the given value.
     * @param {string} property
     * @param {string} value
     */

  }, {
    key: "setStyle",
    value: function setStyle(property, value) {}

    /**
     * Gets the height of the top app bar.
     * @return {number}
     */

  }, {
    key: "getTopAppBarHeight",
    value: function getTopAppBarHeight() {}

    /**
     * Registers an event handler on the navigation icon element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerNavigationIconInteractionHandler",
    value: function registerNavigationIconInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the navigation icon element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterNavigationIconInteractionHandler",
    value: function deregisterNavigationIconInteractionHandler(type, handler) {}

    /**
     * Emits an event when the navigation icon is clicked.
     */

  }, {
    key: "notifyNavigationIconClicked",
    value: function notifyNavigationIconClicked() {}

    /** @param {function(!Event)} handler */

  }, {
    key: "registerScrollHandler",
    value: function registerScrollHandler(handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "deregisterScrollHandler",
    value: function deregisterScrollHandler(handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}

    /** @return {number} */

  }, {
    key: "getViewportScrollY",
    value: function getViewportScrollY() {}

    /** @return {number} */

  }, {
    key: "getTotalActionItems",
    value: function getTotalActionItems() {}
  }]);

  return MDCTopAppBarAdapter;
}();

/* unused harmony default export */ var _unused_webpack_default_export = (MDCTopAppBarAdapter);

/***/ }),

/***/ 43:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return numbers; });
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
var cssClasses = {
  FIXED_CLASS: 'mdc-top-app-bar--fixed',
  FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
  SHORT_CLASS: 'mdc-top-app-bar--short',
  SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
  SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
};

/** @enum {number} */
var numbers = {
  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
  MAX_TOP_APP_BAR_HEIGHT: 128
};

/** @enum {string} */
var strings = {
  ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
  NAVIGATION_EVENT: 'MDCTopAppBar:nav',
  NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
  ROOT_SELECTOR: '.mdc-top-app-bar',
  TITLE_SELECTOR: '.mdc-top-app-bar__title'
};



/***/ }),

/***/ 44:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_base_foundation__ = __webpack_require__(0);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





/**
 * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
 */

var MDCTopAppBarBaseFoundation = function (_MDCFoundation) {
  _inherits(MDCTopAppBarBaseFoundation, _MDCFoundation);

  _createClass(MDCTopAppBarBaseFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_0__constants__["c" /* strings */];
    }

    /** @return enum {string} */

  }, {
    key: 'cssClasses',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */];
    }

    /** @return enum {number} */

  }, {
    key: 'numbers',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* numbers */];
    }

    /**
     * {@see MDCTopAppBarAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTopAppBarAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get() {
      return (/** @type {!MDCTopAppBarAdapter} */{
          hasClass: function hasClass() /* className: string */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          setStyle: function setStyle() /* property: string, value: string */{},
          getTopAppBarHeight: function getTopAppBarHeight() {},
          registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
          notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
          registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
          deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getViewportScrollY: function getViewportScrollY() {
            return (/* number */0
            );
          },
          getTotalActionItems: function getTotalActionItems() {
            return (/* number */0
            );
          }
        }
      );
    }

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */

  }]);

  function MDCTopAppBarBaseFoundation( /** @type {!MDCTopAppBarAdapter} */adapter) {
    _classCallCheck(this, MDCTopAppBarBaseFoundation);

    var _this = _possibleConstructorReturn(this, (MDCTopAppBarBaseFoundation.__proto__ || Object.getPrototypeOf(MDCTopAppBarBaseFoundation)).call(this, _extends(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

    _this.navClickHandler_ = function () {
      return _this.adapter_.notifyNavigationIconClicked();
    };

    _this.scrollHandler_ = function () {};
    return _this;
  }

  _createClass(MDCTopAppBarBaseFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
    }
  }, {
    key: 'initScrollHandler',
    value: function initScrollHandler() {
      this.adapter_.registerScrollHandler(this.scrollHandler_);
    }
  }, {
    key: 'destroyScrollHandler',
    value: function destroyScrollHandler() {
      this.adapter_.deregisterScrollHandler(this.scrollHandler_);
    }
  }]);

  return MDCTopAppBarBaseFoundation;
}(__WEBPACK_IMPORTED_MODULE_2__material_base_foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCTopAppBarBaseFoundation);

/***/ }),

/***/ 5:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(2);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */






/**
 * @typedef {{
 *   isActivated: (boolean|undefined),
 *   hasDeactivationUXRun: (boolean|undefined),
 *   wasActivatedByPointer: (boolean|undefined),
 *   wasElementMadeActive: (boolean|undefined),
 *   activationEvent: (!Event|undefined),
 *   isProgrammatic: (boolean|undefined)
 * }}
 */
var ActivationStateType = void 0;

/**
 * @typedef {{
 *   activate: (string|undefined),
 *   deactivate: (string|undefined),
 *   focus: (string|undefined),
 *   blur: (string|undefined)
 * }}
 */
var ListenerInfoType = void 0;

/**
 * @typedef {{
 *   activate: function(!Event),
 *   deactivate: function(!Event=),
 *   focus: function(),
 *   blur: function()
 * }}
 */
var ListenersType = void 0;

/**
 * @typedef {{
 *   x: number,
 *   y: number
 * }}
 */
var PointType = void 0;

// Activation events registered on the root element of each instance for activation
var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

// Deactivation events registered on documentElement when a pointer-related down event occurs
var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu'];

// Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
/** @type {!Array<!EventTarget>} */
var activatedTargets = [];

/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */

var MDCRippleFoundation = function (_MDCFoundation) {
  _inherits(MDCRippleFoundation, _MDCFoundation);

  _createClass(MDCRippleFoundation, null, [{
    key: 'cssClasses',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */];
    }
  }, {
    key: 'strings',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["c" /* strings */];
    }
  }, {
    key: 'numbers',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */];
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return {
        browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
        isUnbounded: function isUnbounded() /* boolean */{},
        isSurfaceActive: function isSurfaceActive() /* boolean */{},
        isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
        registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
        computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
        getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
      };
    }
  }]);

  function MDCRippleFoundation(adapter) {
    _classCallCheck(this, MDCRippleFoundation);

    /** @private {number} */
    var _this = _possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

    _this.layoutFrame_ = 0;

    /** @private {!ClientRect} */
    _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

    /** @private {!ActivationStateType} */
    _this.activationState_ = _this.defaultActivationState_();

    /** @private {number} */
    _this.initialSize_ = 0;

    /** @private {number} */
    _this.maxRadius_ = 0;

    /** @private {function(!Event)} */
    _this.activateHandler_ = function (e) {
      return _this.activate_(e);
    };

    /** @private {function(!Event=)} */
    _this.deactivateHandler_ = function () {
      return _this.deactivate_();
    };

    /** @private {function(!Event=)} */
    _this.focusHandler_ = function () {
      return _this.handleFocus();
    };

    /** @private {function(!Event=)} */
    _this.blurHandler_ = function () {
      return _this.handleBlur();
    };

    /** @private {!Function} */
    _this.resizeHandler_ = function () {
      return _this.layout();
    };

    /** @private {{left: number, top:number}} */
    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };

    /** @private {number} */
    _this.fgScale_ = 0;

    /** @private {number} */
    _this.activationTimer_ = 0;

    /** @private {number} */
    _this.fgDeactivationRemovalTimer_ = 0;

    /** @private {boolean} */
    _this.activationAnimationHasEnded_ = false;

    /** @private {!Function} */
    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;
      _this.runDeactivationUXLogicIfReady_();
    };

    /** @private {!Event|undefined} */
    _this.previousActivationEvent_;
    return _this;
  }

  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */


  _createClass(MDCRippleFoundation, [{
    key: 'supportsPressRipple_',
    value: function supportsPressRipple_() {
      return this.adapter_.browserSupportsCssVars();
    }

    /**
     * @return {!ActivationStateType}
     */

  }, {
    key: 'defaultActivationState_',
    value: function defaultActivationState_() {
      return {
        isActivated: false,
        hasDeactivationUXRun: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false,
        activationEvent: undefined,
        isProgrammatic: false
      };
    }

    /** @override */

  }, {
    key: 'init',
    value: function init() {
      var _this2 = this;

      var supportsPressRipple = this.supportsPressRipple_();

      this.registerRootHandlers_(supportsPressRipple);

      if (supportsPressRipple) {
        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);
          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED);
            // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
            _this2.layoutInternal_();
          }
        });
      }
    }

    /** @override */

  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      if (this.supportsPressRipple_()) {
        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
        }

        if (this.fgDeactivationRemovalTimer_) {
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.fgDeactivationRemovalTimer_ = 0;
          this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
        }

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);
          _this3.adapter_.removeClass(UNBOUNDED);
          _this3.removeCssVars_();
        });
      }

      this.deregisterRootHandlers_();
      this.deregisterDeactivationHandlers_();
    }

    /**
     * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
     * @private
     */

  }, {
    key: 'registerRootHandlers_',
    value: function registerRootHandlers_(supportsPressRipple) {
      var _this4 = this;

      if (supportsPressRipple) {
        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        if (this.adapter_.isUnbounded()) {
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }

      this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
      this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
    }

    /**
     * @param {!Event} e
     * @private
     */

  }, {
    key: 'registerDeactivationHandlers_',
    value: function registerDeactivationHandlers_(e) {
      var _this5 = this;

      if (e.type === 'keydown') {
        this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
      } else {
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
        });
      }
    }

    /** @private */

  }, {
    key: 'deregisterRootHandlers_',
    value: function deregisterRootHandlers_() {
      var _this6 = this;

      ACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
      });
      this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
      this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

      if (this.adapter_.isUnbounded()) {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }

    /** @private */

  }, {
    key: 'deregisterDeactivationHandlers_',
    value: function deregisterDeactivationHandlers_() {
      var _this7 = this;

      this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
      });
    }

    /** @private */

  }, {
    key: 'removeCssVars_',
    value: function removeCssVars_() {
      var _this8 = this;

      var strings = MDCRippleFoundation.strings;

      Object.keys(strings).forEach(function (k) {
        if (k.indexOf('VAR_') === 0) {
          _this8.adapter_.updateCssVariable(strings[k], null);
        }
      });
    }

    /**
     * @param {!Event=} e
     * @private
     */

  }, {
    key: 'activate_',
    value: function activate_(e) {
      var _this9 = this;

      if (this.adapter_.isSurfaceDisabled()) {
        return;
      }

      var activationState = this.activationState_;
      if (activationState.isActivated) {
        return;
      }

      // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
      var previousActivationEvent = this.previousActivationEvent_;
      var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;
      if (isSameInteraction) {
        return;
      }

      activationState.isActivated = true;
      activationState.isProgrammatic = e === undefined;
      activationState.activationEvent = e;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');

      var hasActivatedChild = e !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
        return _this9.adapter_.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        // Immediately reset activation state, while preserving logic that prevents touch follow-on events
        this.resetActivationState_();
        return;
      }

      if (e !== undefined) {
        activatedTargets.push( /** @type {!EventTarget} */e.target);
        this.registerDeactivationHandlers_(e);
      }

      activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
      if (activationState.wasElementMadeActive) {
        this.animateActivation_();
      }

      requestAnimationFrame(function () {
        // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
        activatedTargets = [];

        if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
          // If space was pressed, try again within an rAF call to detect :active, because different UAs report
          // active states inconsistently when they're called within event handling code:
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
          // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
          // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
          // variable is set within a rAF callback for a submit button interaction (#2241).
          activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
          if (activationState.wasElementMadeActive) {
            _this9.animateActivation_();
          }
        }

        if (!activationState.wasElementMadeActive) {
          // Reset activation state immediately if element was not made active.
          _this9.activationState_ = _this9.defaultActivationState_();
        }
      });
    }

    /**
     * @param {!Event=} e
     * @private
     */

  }, {
    key: 'checkElementMadeActive_',
    value: function checkElementMadeActive_(e) {
      return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
    }

    /**
     * @param {!Event=} event Optional event containing position information.
     */

  }, {
    key: 'activate',
    value: function activate(event) {
      this.activate_(event);
    }

    /** @private */

  }, {
    key: 'animateActivation_',
    value: function animateActivation_() {
      var _this10 = this;

      var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
          VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
          VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
      var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
          FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
          FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


      this.layoutInternal_();

      var translateStart = '';
      var translateEnd = '';

      if (!this.adapter_.isUnbounded()) {
        var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
            startPoint = _getFgTranslationCoor.startPoint,
            endPoint = _getFgTranslationCoor.endPoint;

        translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
        translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
      }

      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      // Cancel any ongoing activation/deactivation animations
      clearTimeout(this.activationTimer_);
      clearTimeout(this.fgDeactivationRemovalTimer_);
      this.rmBoundedActivationClasses_();
      this.adapter_.removeClass(FG_DEACTIVATION);

      // Force layout in order to re-trigger the animation.
      this.adapter_.computeBoundingRect();
      this.adapter_.addClass(FG_ACTIVATION);
      this.activationTimer_ = setTimeout(function () {
        return _this10.activationTimerCallback_();
      }, DEACTIVATION_TIMEOUT_MS);
    }

    /**
     * @private
     * @return {{startPoint: PointType, endPoint: PointType}}
     */

  }, {
    key: 'getFgTranslationCoordinates_',
    value: function getFgTranslationCoordinates_() {
      var _activationState_ = this.activationState_,
          activationEvent = _activationState_.activationEvent,
          wasActivatedByPointer = _activationState_.wasActivatedByPointer;


      var startPoint = void 0;
      if (wasActivatedByPointer) {
        startPoint = Object(__WEBPACK_IMPORTED_MODULE_3__util__["getNormalizedEventCoords"])(
        /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame_.width / 2,
          y: this.frame_.height / 2
        };
      }
      // Center the element around the start point.
      startPoint = {
        x: startPoint.x - this.initialSize_ / 2,
        y: startPoint.y - this.initialSize_ / 2
      };

      var endPoint = {
        x: this.frame_.width / 2 - this.initialSize_ / 2,
        y: this.frame_.height / 2 - this.initialSize_ / 2
      };

      return { startPoint: startPoint, endPoint: endPoint };
    }

    /** @private */

  }, {
    key: 'runDeactivationUXLogicIfReady_',
    value: function runDeactivationUXLogicIfReady_() {
      var _this11 = this;

      // This method is called both when a pointing device is released, and when the activation animation ends.
      // The deactivation animation should only run after both of those occur.
      var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
      var _activationState_2 = this.activationState_,
          hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
          isActivated = _activationState_2.isActivated;

      var activationHasEnded = hasDeactivationUXRun || !isActivated;

      if (activationHasEnded && this.activationAnimationHasEnded_) {
        this.rmBoundedActivationClasses_();
        this.adapter_.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer_ = setTimeout(function () {
          _this11.adapter_.removeClass(FG_DEACTIVATION);
        }, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */].FG_DEACTIVATION_MS);
      }
    }

    /** @private */

  }, {
    key: 'rmBoundedActivationClasses_',
    value: function rmBoundedActivationClasses_() {
      var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

      this.adapter_.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded_ = false;
      this.adapter_.computeBoundingRect();
    }
  }, {
    key: 'resetActivationState_',
    value: function resetActivationState_() {
      var _this12 = this;

      this.previousActivationEvent_ = this.activationState_.activationEvent;
      this.activationState_ = this.defaultActivationState_();
      // Touch devices may fire additional events for the same interaction within a short time.
      // Store the previous event until it's safe to assume that subsequent events are for new interactions.
      setTimeout(function () {
        return _this12.previousActivationEvent_ = undefined;
      }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
    }

    /**
     * @private
     */

  }, {
    key: 'deactivate_',
    value: function deactivate_() {
      var _this13 = this;

      var activationState = this.activationState_;
      // This can happen in scenarios such as when you have a keyup event that blurs the element.
      if (!activationState.isActivated) {
        return;
      }

      var state = /** @type {!ActivationStateType} */_extends({}, activationState);

      if (activationState.isProgrammatic) {
        requestAnimationFrame(function () {
          return _this13.animateDeactivation_(state);
        });
        this.resetActivationState_();
      } else {
        this.deregisterDeactivationHandlers_();
        requestAnimationFrame(function () {
          _this13.activationState_.hasDeactivationUXRun = true;
          _this13.animateDeactivation_(state);
          _this13.resetActivationState_();
        });
      }
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.deactivate_();
    }

    /**
     * @param {!ActivationStateType} options
     * @private
     */

  }, {
    key: 'animateDeactivation_',
    value: function animateDeactivation_(_ref) {
      var wasActivatedByPointer = _ref.wasActivatedByPointer,
          wasElementMadeActive = _ref.wasElementMadeActive;

      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady_();
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      var _this14 = this;

      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }
      this.layoutFrame_ = requestAnimationFrame(function () {
        _this14.layoutInternal_();
        _this14.layoutFrame_ = 0;
      });
    }

    /** @private */

  }, {
    key: 'layoutInternal_',
    value: function layoutInternal_() {
      var _this15 = this;

      this.frame_ = this.adapter_.computeBoundingRect();
      var maxDim = Math.max(this.frame_.height, this.frame_.width);

      // Surface diameter is treated differently for unbounded vs. bounded ripples.
      // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
      // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
      // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
      // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
      // `overflow: hidden`.
      var getBoundedRadius = function getBoundedRadius() {
        var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
        return hypotenuse + MDCRippleFoundation.numbers.PADDING;
      };

      this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

      // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
      this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
      this.fgScale_ = this.maxRadius_ / this.initialSize_;

      this.updateLayoutCssVars_();
    }

    /** @private */

  }, {
    key: 'updateLayoutCssVars_',
    value: function updateLayoutCssVars_() {
      var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
          VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
          VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
          VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
          VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


      this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
      this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

      if (this.adapter_.isUnbounded()) {
        this.unboundedCoords_ = {
          left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
          top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
        };

        this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
        this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
      }
    }

    /** @param {boolean} unbounded */

  }, {
    key: 'setUnbounded',
    value: function setUnbounded(unbounded) {
      var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

      if (unbounded) {
        this.adapter_.addClass(UNBOUNDED);
      } else {
        this.adapter_.removeClass(UNBOUNDED);
      }
    }
  }, {
    key: 'handleFocus',
    value: function handleFocus() {
      var _this16 = this;

      requestAnimationFrame(function () {
        return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    }
  }, {
    key: 'handleBlur',
    value: function handleBlur() {
      var _this17 = this;

      requestAnimationFrame(function () {
        return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    }
  }]);

  return MDCRippleFoundation;
}(__WEBPACK_IMPORTED_MODULE_0__material_base_foundation__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MDCRippleFoundation);

/***/ }),

/***/ 6:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return numbers; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
};

var strings = {
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
};

var numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
  FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
  TAP_DELAY_MS: 300 };



/***/ })

/******/ });
});

},{}],"../node_modules/chart.js/src/helpers/helpers.core.js":[function(require,module,exports) {
'use strict';

/**
 * @namespace Chart.helpers
 */
var helpers = {
	/**
	 * An empty function that can be used, for example, for optional callback.
	 */
	noop: function() {},

	/**
	 * Returns a unique id, sequentially generated from a global variable.
	 * @returns {Number}
	 * @function
	 */
	uid: (function() {
		var id = 0;
		return function() {
			return id++;
		};
	}()),

	/**
	 * Returns true if `value` is neither null nor undefined, else returns false.
	 * @param {*} value - The value to test.
	 * @returns {Boolean}
	 * @since 2.7.0
	 */
	isNullOrUndef: function(value) {
		return value === null || typeof value === 'undefined';
	},

	/**
	 * Returns true if `value` is an array, else returns false.
	 * @param {*} value - The value to test.
	 * @returns {Boolean}
	 * @function
	 */
	isArray: Array.isArray ? Array.isArray : function(value) {
		return Object.prototype.toString.call(value) === '[object Array]';
	},

	/**
	 * Returns true if `value` is an object (excluding null), else returns false.
	 * @param {*} value - The value to test.
	 * @returns {Boolean}
	 * @since 2.7.0
	 */
	isObject: function(value) {
		return value !== null && Object.prototype.toString.call(value) === '[object Object]';
	},

	/**
	 * Returns `value` if defined, else returns `defaultValue`.
	 * @param {*} value - The value to return if defined.
	 * @param {*} defaultValue - The value to return if `value` is undefined.
	 * @returns {*}
	 */
	valueOrDefault: function(value, defaultValue) {
		return typeof value === 'undefined' ? defaultValue : value;
	},

	/**
	 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
	 * @param {Array} value - The array to lookup for value at `index`.
	 * @param {Number} index - The index in `value` to lookup for value.
	 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
	 * @returns {*}
	 */
	valueAtIndexOrDefault: function(value, index, defaultValue) {
		return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
	},

	/**
	 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
	 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
	 * @param {Function} fn - The function to call.
	 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
	 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
	 * @returns {*}
	 */
	callback: function(fn, args, thisArg) {
		if (fn && typeof fn.call === 'function') {
			return fn.apply(thisArg, args);
		}
	},

	/**
	 * Note(SB) for performance sake, this method should only be used when loopable type
	 * is unknown or in none intensive code (not called often and small loopable). Else
	 * it's preferable to use a regular for() loop and save extra function calls.
	 * @param {Object|Array} loopable - The object or array to be iterated.
	 * @param {Function} fn - The function to call for each item.
	 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
	 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
	 */
	each: function(loopable, fn, thisArg, reverse) {
		var i, len, keys;
		if (helpers.isArray(loopable)) {
			len = loopable.length;
			if (reverse) {
				for (i = len - 1; i >= 0; i--) {
					fn.call(thisArg, loopable[i], i);
				}
			} else {
				for (i = 0; i < len; i++) {
					fn.call(thisArg, loopable[i], i);
				}
			}
		} else if (helpers.isObject(loopable)) {
			keys = Object.keys(loopable);
			len = keys.length;
			for (i = 0; i < len; i++) {
				fn.call(thisArg, loopable[keys[i]], keys[i]);
			}
		}
	},

	/**
	 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
	 * @see http://stackoverflow.com/a/14853974
	 * @param {Array} a0 - The array to compare
	 * @param {Array} a1 - The array to compare
	 * @returns {Boolean}
	 */
	arrayEquals: function(a0, a1) {
		var i, ilen, v0, v1;

		if (!a0 || !a1 || a0.length !== a1.length) {
			return false;
		}

		for (i = 0, ilen = a0.length; i < ilen; ++i) {
			v0 = a0[i];
			v1 = a1[i];

			if (v0 instanceof Array && v1 instanceof Array) {
				if (!helpers.arrayEquals(v0, v1)) {
					return false;
				}
			} else if (v0 !== v1) {
				// NOTE: two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}

		return true;
	},

	/**
	 * Returns a deep copy of `source` without keeping references on objects and arrays.
	 * @param {*} source - The value to clone.
	 * @returns {*}
	 */
	clone: function(source) {
		if (helpers.isArray(source)) {
			return source.map(helpers.clone);
		}

		if (helpers.isObject(source)) {
			var target = {};
			var keys = Object.keys(source);
			var klen = keys.length;
			var k = 0;

			for (; k < klen; ++k) {
				target[keys[k]] = helpers.clone(source[keys[k]]);
			}

			return target;
		}

		return source;
	},

	/**
	 * The default merger when Chart.helpers.merge is called without merger option.
	 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
	 * @private
	 */
	_merger: function(key, target, source, options) {
		var tval = target[key];
		var sval = source[key];

		if (helpers.isObject(tval) && helpers.isObject(sval)) {
			helpers.merge(tval, sval, options);
		} else {
			target[key] = helpers.clone(sval);
		}
	},

	/**
	 * Merges source[key] in target[key] only if target[key] is undefined.
	 * @private
	 */
	_mergerIf: function(key, target, source) {
		var tval = target[key];
		var sval = source[key];

		if (helpers.isObject(tval) && helpers.isObject(sval)) {
			helpers.mergeIf(tval, sval);
		} else if (!target.hasOwnProperty(key)) {
			target[key] = helpers.clone(sval);
		}
	},

	/**
	 * Recursively deep copies `source` properties into `target` with the given `options`.
	 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
	 * @param {Object} target - The target object in which all sources are merged into.
	 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
	 * @param {Object} [options] - Merging options:
	 * @param {Function} [options.merger] - The merge method (key, target, source, options)
	 * @returns {Object} The `target` object.
	 */
	merge: function(target, source, options) {
		var sources = helpers.isArray(source) ? source : [source];
		var ilen = sources.length;
		var merge, i, keys, klen, k;

		if (!helpers.isObject(target)) {
			return target;
		}

		options = options || {};
		merge = options.merger || helpers._merger;

		for (i = 0; i < ilen; ++i) {
			source = sources[i];
			if (!helpers.isObject(source)) {
				continue;
			}

			keys = Object.keys(source);
			for (k = 0, klen = keys.length; k < klen; ++k) {
				merge(keys[k], target, source, options);
			}
		}

		return target;
	},

	/**
	 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
	 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
	 * @param {Object} target - The target object in which all sources are merged into.
	 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
	 * @returns {Object} The `target` object.
	 */
	mergeIf: function(target, source) {
		return helpers.merge(target, source, {merger: helpers._mergerIf});
	},

	/**
	 * Applies the contents of two or more objects together into the first object.
	 * @param {Object} target - The target object in which all objects are merged into.
	 * @param {Object} arg1 - Object containing additional properties to merge in target.
	 * @param {Object} argN - Additional objects containing properties to merge in target.
	 * @returns {Object} The `target` object.
	 */
	extend: function(target) {
		var setFn = function(value, key) {
			target[key] = value;
		};
		for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
			helpers.each(arguments[i], setFn);
		}
		return target;
	},

	/**
	 * Basic javascript inheritance based on the model created in Backbone.js
	 */
	inherits: function(extensions) {
		var me = this;
		var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
			return me.apply(this, arguments);
		};

		var Surrogate = function() {
			this.constructor = ChartElement;
		};

		Surrogate.prototype = me.prototype;
		ChartElement.prototype = new Surrogate();
		ChartElement.extend = helpers.inherits;

		if (extensions) {
			helpers.extend(ChartElement.prototype, extensions);
		}

		ChartElement.__super__ = me.prototype;
		return ChartElement;
	}
};

module.exports = helpers;

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.callback instead.
 * @function Chart.helpers.callCallback
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */
helpers.callCallback = helpers.callback;

/**
 * Provided for backward compatibility, use Array.prototype.indexOf instead.
 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
 * @function Chart.helpers.indexOf
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.indexOf = function(array, item, fromIndex) {
	return Array.prototype.indexOf.call(array, item, fromIndex);
};

/**
 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
 * @function Chart.helpers.getValueOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.getValueOrDefault = helpers.valueOrDefault;

/**
 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
 * @function Chart.helpers.getValueAtIndexOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

},{}],"../node_modules/chart.js/src/helpers/helpers.easing.js":[function(require,module,exports) {
'use strict';

var helpers = require('./helpers.core');

/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easingEffects
 * @see http://www.robertpenner.com/easing/
 */
var effects = {
	linear: function(t) {
		return t;
	},

	easeInQuad: function(t) {
		return t * t;
	},

	easeOutQuad: function(t) {
		return -t * (t - 2);
	},

	easeInOutQuad: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t;
		}
		return -0.5 * ((--t) * (t - 2) - 1);
	},

	easeInCubic: function(t) {
		return t * t * t;
	},

	easeOutCubic: function(t) {
		return (t = t - 1) * t * t + 1;
	},

	easeInOutCubic: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t;
		}
		return 0.5 * ((t -= 2) * t * t + 2);
	},

	easeInQuart: function(t) {
		return t * t * t * t;
	},

	easeOutQuart: function(t) {
		return -((t = t - 1) * t * t * t - 1);
	},

	easeInOutQuart: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t * t;
		}
		return -0.5 * ((t -= 2) * t * t * t - 2);
	},

	easeInQuint: function(t) {
		return t * t * t * t * t;
	},

	easeOutQuint: function(t) {
		return (t = t - 1) * t * t * t * t + 1;
	},

	easeInOutQuint: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t * t * t;
		}
		return 0.5 * ((t -= 2) * t * t * t * t + 2);
	},

	easeInSine: function(t) {
		return -Math.cos(t * (Math.PI / 2)) + 1;
	},

	easeOutSine: function(t) {
		return Math.sin(t * (Math.PI / 2));
	},

	easeInOutSine: function(t) {
		return -0.5 * (Math.cos(Math.PI * t) - 1);
	},

	easeInExpo: function(t) {
		return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
	},

	easeOutExpo: function(t) {
		return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
	},

	easeInOutExpo: function(t) {
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if ((t /= 0.5) < 1) {
			return 0.5 * Math.pow(2, 10 * (t - 1));
		}
		return 0.5 * (-Math.pow(2, -10 * --t) + 2);
	},

	easeInCirc: function(t) {
		if (t >= 1) {
			return t;
		}
		return -(Math.sqrt(1 - t * t) - 1);
	},

	easeOutCirc: function(t) {
		return Math.sqrt(1 - (t = t - 1) * t);
	},

	easeInOutCirc: function(t) {
		if ((t /= 0.5) < 1) {
			return -0.5 * (Math.sqrt(1 - t * t) - 1);
		}
		return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	},

	easeInElastic: function(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if (!p) {
			p = 0.3;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
	},

	easeOutElastic: function(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if (!p) {
			p = 0.3;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
	},

	easeInOutElastic: function(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if ((t /= 0.5) === 2) {
			return 1;
		}
		if (!p) {
			p = 0.45;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		if (t < 1) {
			return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		}
		return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
	},
	easeInBack: function(t) {
		var s = 1.70158;
		return t * t * ((s + 1) * t - s);
	},

	easeOutBack: function(t) {
		var s = 1.70158;
		return (t = t - 1) * t * ((s + 1) * t + s) + 1;
	},

	easeInOutBack: function(t) {
		var s = 1.70158;
		if ((t /= 0.5) < 1) {
			return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
		}
		return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
	},

	easeInBounce: function(t) {
		return 1 - effects.easeOutBounce(1 - t);
	},

	easeOutBounce: function(t) {
		if (t < (1 / 2.75)) {
			return 7.5625 * t * t;
		}
		if (t < (2 / 2.75)) {
			return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
		}
		if (t < (2.5 / 2.75)) {
			return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
		}
		return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
	},

	easeInOutBounce: function(t) {
		if (t < 0.5) {
			return effects.easeInBounce(t * 2) * 0.5;
		}
		return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
	}
};

module.exports = {
	effects: effects
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
 * @function Chart.helpers.easingEffects
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.easingEffects = effects;

},{"./helpers.core":"../node_modules/chart.js/src/helpers/helpers.core.js"}],"../node_modules/chart.js/src/helpers/helpers.canvas.js":[function(require,module,exports) {
'use strict';

var helpers = require('./helpers.core');

/**
 * @namespace Chart.helpers.canvas
 */
var exports = module.exports = {
	/**
	 * Clears the entire canvas associated to the given `chart`.
	 * @param {Chart} chart - The chart for which to clear the canvas.
	 */
	clear: function(chart) {
		chart.ctx.clearRect(0, 0, chart.width, chart.height);
	},

	/**
	 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
	 * given size (width, height) and the same `radius` for all corners.
	 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
	 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
	 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
	 * @param {Number} width - The rectangle's width.
	 * @param {Number} height - The rectangle's height.
	 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
	 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
	 */
	roundedRect: function(ctx, x, y, width, height, radius) {
		if (radius) {
			// NOTE(SB) `epsilon` helps to prevent minor artifacts appearing
			// on Chrome when `r` is exactly half the height or the width.
			var epsilon = 0.0000001;
			var r = Math.min(radius, (height / 2) - epsilon, (width / 2) - epsilon);

			ctx.moveTo(x + r, y);
			ctx.lineTo(x + width - r, y);
			ctx.arcTo(x + width, y, x + width, y + r, r);
			ctx.lineTo(x + width, y + height - r);
			ctx.arcTo(x + width, y + height, x + width - r, y + height, r);
			ctx.lineTo(x + r, y + height);
			ctx.arcTo(x, y + height, x, y + height - r, r);
			ctx.lineTo(x, y + r);
			ctx.arcTo(x, y, x + r, y, r);
			ctx.closePath();
			ctx.moveTo(x, y);
		} else {
			ctx.rect(x, y, width, height);
		}
	},

	drawPoint: function(ctx, style, radius, x, y, rotation) {
		var type, edgeLength, xOffset, yOffset, height, size;
		rotation = rotation || 0;

		if (style && typeof style === 'object') {
			type = style.toString();
			if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
				ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
				return;
			}
		}

		if (isNaN(radius) || radius <= 0) {
			return;
		}

		ctx.save();
		ctx.translate(x, y);
		ctx.rotate(rotation * Math.PI / 180);
		ctx.beginPath();

		switch (style) {
		// Default includes circle
		default:
			ctx.arc(0, 0, radius, 0, Math.PI * 2);
			ctx.closePath();
			break;
		case 'triangle':
			edgeLength = 3 * radius / Math.sqrt(3);
			height = edgeLength * Math.sqrt(3) / 2;
			ctx.moveTo(-edgeLength / 2, height / 3);
			ctx.lineTo(edgeLength / 2, height / 3);
			ctx.lineTo(0, -2 * height / 3);
			ctx.closePath();
			break;
		case 'rect':
			size = 1 / Math.SQRT2 * radius;
			ctx.rect(-size, -size, 2 * size, 2 * size);
			break;
		case 'rectRounded':
			var offset = radius / Math.SQRT2;
			var leftX = -offset;
			var topY = -offset;
			var sideSize = Math.SQRT2 * radius;

			// NOTE(SB) the rounded rect implementation changed to use `arcTo`
			// instead of `quadraticCurveTo` since it generates better results
			// when rect is almost a circle. 0.425 (instead of 0.5) produces
			// results visually closer to the previous impl.
			this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius * 0.425);
			break;
		case 'rectRot':
			size = 1 / Math.SQRT2 * radius;
			ctx.moveTo(-size, 0);
			ctx.lineTo(0, size);
			ctx.lineTo(size, 0);
			ctx.lineTo(0, -size);
			ctx.closePath();
			break;
		case 'cross':
			ctx.moveTo(0, radius);
			ctx.lineTo(0, -radius);
			ctx.moveTo(-radius, 0);
			ctx.lineTo(radius, 0);
			break;
		case 'crossRot':
			xOffset = Math.cos(Math.PI / 4) * radius;
			yOffset = Math.sin(Math.PI / 4) * radius;
			ctx.moveTo(-xOffset, -yOffset);
			ctx.lineTo(xOffset, yOffset);
			ctx.moveTo(-xOffset, yOffset);
			ctx.lineTo(xOffset, -yOffset);
			break;
		case 'star':
			ctx.moveTo(0, radius);
			ctx.lineTo(0, -radius);
			ctx.moveTo(-radius, 0);
			ctx.lineTo(radius, 0);
			xOffset = Math.cos(Math.PI / 4) * radius;
			yOffset = Math.sin(Math.PI / 4) * radius;
			ctx.moveTo(-xOffset, -yOffset);
			ctx.lineTo(xOffset, yOffset);
			ctx.moveTo(-xOffset, yOffset);
			ctx.lineTo(xOffset, -yOffset);
			break;
		case 'line':
			ctx.moveTo(-radius, 0);
			ctx.lineTo(radius, 0);
			break;
		case 'dash':
			ctx.moveTo(0, 0);
			ctx.lineTo(radius, 0);
			break;
		}

		ctx.fill();
		ctx.stroke();
		ctx.restore();
	},

	clipArea: function(ctx, area) {
		ctx.save();
		ctx.beginPath();
		ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
		ctx.clip();
	},

	unclipArea: function(ctx) {
		ctx.restore();
	},

	lineTo: function(ctx, previous, target, flip) {
		if (target.steppedLine) {
			if ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {
				ctx.lineTo(previous.x, target.y);
			} else {
				ctx.lineTo(target.x, previous.y);
			}
			ctx.lineTo(target.x, target.y);
			return;
		}

		if (!target.tension) {
			ctx.lineTo(target.x, target.y);
			return;
		}

		ctx.bezierCurveTo(
			flip ? previous.controlPointPreviousX : previous.controlPointNextX,
			flip ? previous.controlPointPreviousY : previous.controlPointNextY,
			flip ? target.controlPointNextX : target.controlPointPreviousX,
			flip ? target.controlPointNextY : target.controlPointPreviousY,
			target.x,
			target.y);
	}
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
 * @namespace Chart.helpers.clear
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.clear = exports.clear;

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
 * @namespace Chart.helpers.drawRoundedRectangle
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.drawRoundedRectangle = function(ctx) {
	ctx.beginPath();
	exports.roundedRect.apply(exports, arguments);
};

},{"./helpers.core":"../node_modules/chart.js/src/helpers/helpers.core.js"}],"../node_modules/chart.js/src/helpers/helpers.options.js":[function(require,module,exports) {
'use strict';

var helpers = require('./helpers.core');

/**
 * @alias Chart.helpers.options
 * @namespace
 */
module.exports = {
	/**
	 * Converts the given line height `value` in pixels for a specific font `size`.
	 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
	 * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
	 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
	 * @since 2.7.0
	 */
	toLineHeight: function(value, size) {
		var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
		if (!matches || matches[1] === 'normal') {
			return size * 1.2;
		}

		value = +matches[2];

		switch (matches[3]) {
		case 'px':
			return value;
		case '%':
			value /= 100;
			break;
		default:
			break;
		}

		return size * value;
	},

	/**
	 * Converts the given value into a padding object with pre-computed width/height.
	 * @param {Number|Object} value - If a number, set the value to all TRBL component,
	 *  else, if and object, use defined properties and sets undefined ones to 0.
	 * @returns {Object} The padding values (top, right, bottom, left, width, height)
	 * @since 2.7.0
	 */
	toPadding: function(value) {
		var t, r, b, l;

		if (helpers.isObject(value)) {
			t = +value.top || 0;
			r = +value.right || 0;
			b = +value.bottom || 0;
			l = +value.left || 0;
		} else {
			t = r = b = l = +value || 0;
		}

		return {
			top: t,
			right: r,
			bottom: b,
			left: l,
			height: t + b,
			width: l + r
		};
	},

	/**
	 * Evaluates the given `inputs` sequentially and returns the first defined value.
	 * @param {Array[]} inputs - An array of values, falling back to the last value.
	 * @param {Object} [context] - If defined and the current value is a function, the value
	 * is called with `context` as first argument and the result becomes the new input.
	 * @param {Number} [index] - If defined and the current value is an array, the value
	 * at `index` become the new input.
	 * @since 2.7.0
	 */
	resolve: function(inputs, context, index) {
		var i, ilen, value;

		for (i = 0, ilen = inputs.length; i < ilen; ++i) {
			value = inputs[i];
			if (value === undefined) {
				continue;
			}
			if (context !== undefined && typeof value === 'function') {
				value = value(context);
			}
			if (index !== undefined && helpers.isArray(value)) {
				value = value[index];
			}
			if (value !== undefined) {
				return value;
			}
		}
	}
};

},{"./helpers.core":"../node_modules/chart.js/src/helpers/helpers.core.js"}],"../node_modules/chart.js/src/helpers/index.js":[function(require,module,exports) {
'use strict';

module.exports = require('./helpers.core');
module.exports.easing = require('./helpers.easing');
module.exports.canvas = require('./helpers.canvas');
module.exports.options = require('./helpers.options');

},{"./helpers.core":"../node_modules/chart.js/src/helpers/helpers.core.js","./helpers.easing":"../node_modules/chart.js/src/helpers/helpers.easing.js","./helpers.canvas":"../node_modules/chart.js/src/helpers/helpers.canvas.js","./helpers.options":"../node_modules/chart.js/src/helpers/helpers.options.js"}],"../node_modules/chart.js/src/core/core.defaults.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');

module.exports = {
	/**
	 * @private
	 */
	_set: function(scope, values) {
		return helpers.merge(this[scope] || (this[scope] = {}), values);
	}
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/core/core.js":[function(require,module,exports) {
'use strict';

var defaults = require('./core.defaults');

defaults._set('global', {
	responsive: true,
	responsiveAnimationDuration: 0,
	maintainAspectRatio: true,
	events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
	hover: {
		onHover: null,
		mode: 'nearest',
		intersect: true,
		animationDuration: 400
	},
	onClick: null,
	defaultColor: 'rgba(0,0,0,0.1)',
	defaultFontColor: '#666',
	defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
	defaultFontSize: 12,
	defaultFontStyle: 'normal',
	showLines: true,

	// Element defaults defined in element extensions
	elements: {},

	// Layout options such as padding
	layout: {
		padding: {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0
		}
	}
});

module.exports = function() {

	// Occupy the global variable of Chart, and create a simple base class
	var Chart = function(item, config) {
		this.construct(item, config);
		return this;
	};

	Chart.Chart = Chart;

	return Chart;
};

},{"./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js"}],"../node_modules/chartjs-color/node_modules/color-convert/conversions.js":[function(require,module,exports) {
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],"../node_modules/chartjs-color/node_modules/color-convert/index.js":[function(require,module,exports) {
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":"../node_modules/chartjs-color/node_modules/color-convert/conversions.js"}],"../node_modules/color-name/index.js":[function(require,module,exports) {
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],"../node_modules/chartjs-color-string/color-string.js":[function(require,module,exports) {
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/i,
       hex =  /^#([a-fA-F0-9]{6})$/i,
       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       keyword = /(\w+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
    var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}

},{"color-name":"../node_modules/color-name/index.js"}],"../node_modules/chartjs-color/index.js":[function(require,module,exports) {
/* MIT license */
var convert = require('color-convert');
var string = require('chartjs-color-string');

var Color = function (obj) {
	if (obj instanceof Color) {
		return obj;
	}
	if (!(this instanceof Color)) {
		return new Color(obj);
	}

	this.valid = false;
	this.values = {
		rgb: [0, 0, 0],
		hsl: [0, 0, 0],
		hsv: [0, 0, 0],
		hwb: [0, 0, 0],
		cmyk: [0, 0, 0, 0],
		alpha: 1
	};

	// parse Color() argument
	var vals;
	if (typeof obj === 'string') {
		vals = string.getRgba(obj);
		if (vals) {
			this.setValues('rgb', vals);
		} else if (vals = string.getHsla(obj)) {
			this.setValues('hsl', vals);
		} else if (vals = string.getHwb(obj)) {
			this.setValues('hwb', vals);
		}
	} else if (typeof obj === 'object') {
		vals = obj;
		if (vals.r !== undefined || vals.red !== undefined) {
			this.setValues('rgb', vals);
		} else if (vals.l !== undefined || vals.lightness !== undefined) {
			this.setValues('hsl', vals);
		} else if (vals.v !== undefined || vals.value !== undefined) {
			this.setValues('hsv', vals);
		} else if (vals.w !== undefined || vals.whiteness !== undefined) {
			this.setValues('hwb', vals);
		} else if (vals.c !== undefined || vals.cyan !== undefined) {
			this.setValues('cmyk', vals);
		}
	}
};

Color.prototype = {
	isValid: function () {
		return this.valid;
	},
	rgb: function () {
		return this.setSpace('rgb', arguments);
	},
	hsl: function () {
		return this.setSpace('hsl', arguments);
	},
	hsv: function () {
		return this.setSpace('hsv', arguments);
	},
	hwb: function () {
		return this.setSpace('hwb', arguments);
	},
	cmyk: function () {
		return this.setSpace('cmyk', arguments);
	},

	rgbArray: function () {
		return this.values.rgb;
	},
	hslArray: function () {
		return this.values.hsl;
	},
	hsvArray: function () {
		return this.values.hsv;
	},
	hwbArray: function () {
		var values = this.values;
		if (values.alpha !== 1) {
			return values.hwb.concat([values.alpha]);
		}
		return values.hwb;
	},
	cmykArray: function () {
		return this.values.cmyk;
	},
	rgbaArray: function () {
		var values = this.values;
		return values.rgb.concat([values.alpha]);
	},
	hslaArray: function () {
		var values = this.values;
		return values.hsl.concat([values.alpha]);
	},
	alpha: function (val) {
		if (val === undefined) {
			return this.values.alpha;
		}
		this.setValues('alpha', val);
		return this;
	},

	red: function (val) {
		return this.setChannel('rgb', 0, val);
	},
	green: function (val) {
		return this.setChannel('rgb', 1, val);
	},
	blue: function (val) {
		return this.setChannel('rgb', 2, val);
	},
	hue: function (val) {
		if (val) {
			val %= 360;
			val = val < 0 ? 360 + val : val;
		}
		return this.setChannel('hsl', 0, val);
	},
	saturation: function (val) {
		return this.setChannel('hsl', 1, val);
	},
	lightness: function (val) {
		return this.setChannel('hsl', 2, val);
	},
	saturationv: function (val) {
		return this.setChannel('hsv', 1, val);
	},
	whiteness: function (val) {
		return this.setChannel('hwb', 1, val);
	},
	blackness: function (val) {
		return this.setChannel('hwb', 2, val);
	},
	value: function (val) {
		return this.setChannel('hsv', 2, val);
	},
	cyan: function (val) {
		return this.setChannel('cmyk', 0, val);
	},
	magenta: function (val) {
		return this.setChannel('cmyk', 1, val);
	},
	yellow: function (val) {
		return this.setChannel('cmyk', 2, val);
	},
	black: function (val) {
		return this.setChannel('cmyk', 3, val);
	},

	hexString: function () {
		return string.hexString(this.values.rgb);
	},
	rgbString: function () {
		return string.rgbString(this.values.rgb, this.values.alpha);
	},
	rgbaString: function () {
		return string.rgbaString(this.values.rgb, this.values.alpha);
	},
	percentString: function () {
		return string.percentString(this.values.rgb, this.values.alpha);
	},
	hslString: function () {
		return string.hslString(this.values.hsl, this.values.alpha);
	},
	hslaString: function () {
		return string.hslaString(this.values.hsl, this.values.alpha);
	},
	hwbString: function () {
		return string.hwbString(this.values.hwb, this.values.alpha);
	},
	keyword: function () {
		return string.keyword(this.values.rgb, this.values.alpha);
	},

	rgbNumber: function () {
		var rgb = this.values.rgb;
		return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.values.rgb;
		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}
		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();
		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}
		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.values.rgb;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = [];
		for (var i = 0; i < 3; i++) {
			rgb[i] = 255 - this.values.rgb[i];
		}
		this.setValues('rgb', rgb);
		return this;
	},

	lighten: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] += hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	darken: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] -= hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	saturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] += hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	desaturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] -= hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	whiten: function (ratio) {
		var hwb = this.values.hwb;
		hwb[1] += hwb[1] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	blacken: function (ratio) {
		var hwb = this.values.hwb;
		hwb[2] += hwb[2] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	greyscale: function () {
		var rgb = this.values.rgb;
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		this.setValues('rgb', [val, val, val]);
		return this;
	},

	clearer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha - (alpha * ratio));
		return this;
	},

	opaquer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha + (alpha * ratio));
		return this;
	},

	rotate: function (degrees) {
		var hsl = this.values.hsl;
		var hue = (hsl[0] + degrees) % 360;
		hsl[0] = hue < 0 ? 360 + hue : hue;
		this.setValues('hsl', hsl);
		return this;
	},

	/**
	 * Ported from sass implementation in C
	 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
	 */
	mix: function (mixinColor, weight) {
		var color1 = this;
		var color2 = mixinColor;
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return this
			.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue()
			)
			.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
	},

	toJSON: function () {
		return this.rgb();
	},

	clone: function () {
		// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
		// making the final build way to big to embed in Chart.js. So let's do it manually,
		// assuming that values to clone are 1 dimension arrays containing only numbers,
		// except 'alpha' which is a number.
		var result = new Color();
		var source = this.values;
		var target = result.values;
		var value, type;

		for (var prop in source) {
			if (source.hasOwnProperty(prop)) {
				value = source[prop];
				type = ({}).toString.call(value);
				if (type === '[object Array]') {
					target[prop] = value.slice(0);
				} else if (type === '[object Number]') {
					target[prop] = value;
				} else {
					console.error('unexpected color value:', value);
				}
			}
		}

		return result;
	}
};

Color.prototype.spaces = {
	rgb: ['red', 'green', 'blue'],
	hsl: ['hue', 'saturation', 'lightness'],
	hsv: ['hue', 'saturation', 'value'],
	hwb: ['hue', 'whiteness', 'blackness'],
	cmyk: ['cyan', 'magenta', 'yellow', 'black']
};

Color.prototype.maxes = {
	rgb: [255, 255, 255],
	hsl: [360, 100, 100],
	hsv: [360, 100, 100],
	hwb: [360, 100, 100],
	cmyk: [100, 100, 100, 100]
};

Color.prototype.getValues = function (space) {
	var values = this.values;
	var vals = {};

	for (var i = 0; i < space.length; i++) {
		vals[space.charAt(i)] = values[space][i];
	}

	if (values.alpha !== 1) {
		vals.a = values.alpha;
	}

	// {r: 255, g: 255, b: 255, a: 0.4}
	return vals;
};

Color.prototype.setValues = function (space, vals) {
	var values = this.values;
	var spaces = this.spaces;
	var maxes = this.maxes;
	var alpha = 1;
	var i;

	this.valid = true;

	if (space === 'alpha') {
		alpha = vals;
	} else if (vals.length) {
		// [10, 10, 10]
		values[space] = vals.slice(0, space.length);
		alpha = vals[space.length];
	} else if (vals[space.charAt(0)] !== undefined) {
		// {r: 10, g: 10, b: 10}
		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[space.charAt(i)];
		}

		alpha = vals.a;
	} else if (vals[spaces[space][0]] !== undefined) {
		// {red: 10, green: 10, blue: 10}
		var chans = spaces[space];

		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[chans[i]];
		}

		alpha = vals.alpha;
	}

	values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

	if (space === 'alpha') {
		return false;
	}

	var capped;

	// cap values of the space prior converting all values
	for (i = 0; i < space.length; i++) {
		capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
		values[space][i] = Math.round(capped);
	}

	// convert to all the other color spaces
	for (var sname in spaces) {
		if (sname !== space) {
			values[sname] = convert[space][sname](values[space]);
		}
	}

	return true;
};

Color.prototype.setSpace = function (space, args) {
	var vals = args[0];

	if (vals === undefined) {
		// color.rgb()
		return this.getValues(space);
	}

	// color.rgb(10, 10, 10)
	if (typeof vals === 'number') {
		vals = Array.prototype.slice.call(args);
	}

	this.setValues(space, vals);
	return this;
};

Color.prototype.setChannel = function (space, index, val) {
	var svalues = this.values[space];
	if (val === undefined) {
		// color.red()
		return svalues[index];
	} else if (val === svalues[index]) {
		// color.red(color.red())
		return this;
	}

	// color.red(100)
	svalues[index] = val;
	this.setValues(space, svalues);

	return this;
};

if (typeof window !== 'undefined') {
	window.Color = Color;
}

module.exports = Color;

},{"color-convert":"../node_modules/chartjs-color/node_modules/color-convert/index.js","chartjs-color-string":"../node_modules/chartjs-color-string/color-string.js"}],"../node_modules/chart.js/src/core/core.layouts.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');

function filterByPosition(array, position) {
	return helpers.where(array, function(v) {
		return v.position === position;
	});
}

function sortByWeight(array, reverse) {
	array.forEach(function(v, i) {
		v._tmpIndex_ = i;
		return v;
	});
	array.sort(function(a, b) {
		var v0 = reverse ? b : a;
		var v1 = reverse ? a : b;
		return v0.weight === v1.weight ?
			v0._tmpIndex_ - v1._tmpIndex_ :
			v0.weight - v1.weight;
	});
	array.forEach(function(v) {
		delete v._tmpIndex_;
	});
}

/**
 * @interface ILayoutItem
 * @prop {String} position - The position of the item in the chart layout. Possible values are
 * 'left', 'top', 'right', 'bottom', and 'chartArea'
 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
 * @prop {Function} getPadding -  Returns an object with padding on the edges
 * @prop {Number} width - Width of item. Must be valid after update()
 * @prop {Number} height - Height of item. Must be valid after update()
 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
 */

// The layout service is very self explanatory.  It's responsible for the layout within a chart.
// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
// It is this service's responsibility of carrying out that layout.
module.exports = {
	defaults: {},

	/**
	 * Register a box to a chart.
	 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
	 * @param {Chart} chart - the chart to use
	 * @param {ILayoutItem} item - the item to add to be layed out
	 */
	addBox: function(chart, item) {
		if (!chart.boxes) {
			chart.boxes = [];
		}

		// initialize item with default values
		item.fullWidth = item.fullWidth || false;
		item.position = item.position || 'top';
		item.weight = item.weight || 0;

		chart.boxes.push(item);
	},

	/**
	 * Remove a layoutItem from a chart
	 * @param {Chart} chart - the chart to remove the box from
	 * @param {Object} layoutItem - the item to remove from the layout
	 */
	removeBox: function(chart, layoutItem) {
		var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
		if (index !== -1) {
			chart.boxes.splice(index, 1);
		}
	},

	/**
	 * Sets (or updates) options on the given `item`.
	 * @param {Chart} chart - the chart in which the item lives (or will be added to)
	 * @param {Object} item - the item to configure with the given options
	 * @param {Object} options - the new item options.
	 */
	configure: function(chart, item, options) {
		var props = ['fullWidth', 'position', 'weight'];
		var ilen = props.length;
		var i = 0;
		var prop;

		for (; i < ilen; ++i) {
			prop = props[i];
			if (options.hasOwnProperty(prop)) {
				item[prop] = options[prop];
			}
		}
	},

	/**
	 * Fits boxes of the given chart into the given size by having each box measure itself
	 * then running a fitting algorithm
	 * @param {Chart} chart - the chart
	 * @param {Number} width - the width to fit into
	 * @param {Number} height - the height to fit into
	 */
	update: function(chart, width, height) {
		if (!chart) {
			return;
		}

		var layoutOptions = chart.options.layout || {};
		var padding = helpers.options.toPadding(layoutOptions.padding);
		var leftPadding = padding.left;
		var rightPadding = padding.right;
		var topPadding = padding.top;
		var bottomPadding = padding.bottom;

		var leftBoxes = filterByPosition(chart.boxes, 'left');
		var rightBoxes = filterByPosition(chart.boxes, 'right');
		var topBoxes = filterByPosition(chart.boxes, 'top');
		var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
		var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

		// Sort boxes by weight. A higher weight is further away from the chart area
		sortByWeight(leftBoxes, true);
		sortByWeight(rightBoxes, false);
		sortByWeight(topBoxes, true);
		sortByWeight(bottomBoxes, false);

		// Essentially we now have any number of boxes on each of the 4 sides.
		// Our canvas looks like the following.
		// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
		// B1 is the bottom axis
		// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
		// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
		// an error will be thrown.
		//
		// |----------------------------------------------------|
		// |                  T1 (Full Width)                   |
		// |----------------------------------------------------|
		// |    |    |                 T2                  |    |
		// |    |----|-------------------------------------|----|
		// |    |    | C1 |                           | C2 |    |
		// |    |    |----|                           |----|    |
		// |    |    |                                     |    |
		// | L1 | L2 |           ChartArea (C0)            | R1 |
		// |    |    |                                     |    |
		// |    |    |----|                           |----|    |
		// |    |    | C3 |                           | C4 |    |
		// |    |----|-------------------------------------|----|
		// |    |    |                 B1                  |    |
		// |----------------------------------------------------|
		// |                  B2 (Full Width)                   |
		// |----------------------------------------------------|
		//
		// What we do to find the best sizing, we do the following
		// 1. Determine the minimum size of the chart area.
		// 2. Split the remaining width equally between each vertical axis
		// 3. Split the remaining height equally between each horizontal axis
		// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
		// 5. Adjust the sizes of each axis based on it's minimum reported size.
		// 6. Refit each axis
		// 7. Position each axis in the final location
		// 8. Tell the chart the final location of the chart area
		// 9. Tell any axes that overlay the chart area the positions of the chart area

		// Step 1
		var chartWidth = width - leftPadding - rightPadding;
		var chartHeight = height - topPadding - bottomPadding;
		var chartAreaWidth = chartWidth / 2; // min 50%
		var chartAreaHeight = chartHeight / 2; // min 50%

		// Step 2
		var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

		// Step 3
		var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

		// Step 4
		var maxChartAreaWidth = chartWidth;
		var maxChartAreaHeight = chartHeight;
		var minBoxSizes = [];

		function getMinimumBoxSize(box) {
			var minSize;
			var isHorizontal = box.isHorizontal();

			if (isHorizontal) {
				minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
				maxChartAreaHeight -= minSize.height;
			} else {
				minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
				maxChartAreaWidth -= minSize.width;
			}

			minBoxSizes.push({
				horizontal: isHorizontal,
				minSize: minSize,
				box: box,
			});
		}

		helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

		// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
		var maxHorizontalLeftPadding = 0;
		var maxHorizontalRightPadding = 0;
		var maxVerticalTopPadding = 0;
		var maxVerticalBottomPadding = 0;

		helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
			if (horizontalBox.getPadding) {
				var boxPadding = horizontalBox.getPadding();
				maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
				maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
			}
		});

		helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
			if (verticalBox.getPadding) {
				var boxPadding = verticalBox.getPadding();
				maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
				maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
			}
		});

		// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
		// be if the axes are drawn at their minimum sizes.
		// Steps 5 & 6
		var totalLeftBoxesWidth = leftPadding;
		var totalRightBoxesWidth = rightPadding;
		var totalTopBoxesHeight = topPadding;
		var totalBottomBoxesHeight = bottomPadding;

		// Function to fit a box
		function fitBox(box) {
			var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
				return minBox.box === box;
			});

			if (minBoxSize) {
				if (box.isHorizontal()) {
					var scaleMargin = {
						left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
						right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
						top: 0,
						bottom: 0
					};

					// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
					// on the margin. Sometimes they need to increase in size slightly
					box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
				} else {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight);
				}
			}
		}

		// Update, and calculate the left and right margins for the horizontal boxes
		helpers.each(leftBoxes.concat(rightBoxes), fitBox);

		helpers.each(leftBoxes, function(box) {
			totalLeftBoxesWidth += box.width;
		});

		helpers.each(rightBoxes, function(box) {
			totalRightBoxesWidth += box.width;
		});

		// Set the Left and Right margins for the horizontal boxes
		helpers.each(topBoxes.concat(bottomBoxes), fitBox);

		// Figure out how much margin is on the top and bottom of the vertical boxes
		helpers.each(topBoxes, function(box) {
			totalTopBoxesHeight += box.height;
		});

		helpers.each(bottomBoxes, function(box) {
			totalBottomBoxesHeight += box.height;
		});

		function finalFitVerticalBox(box) {
			var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
				return minSize.box === box;
			});

			var scaleMargin = {
				left: 0,
				right: 0,
				top: totalTopBoxesHeight,
				bottom: totalBottomBoxesHeight
			};

			if (minBoxSize) {
				box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
			}
		}

		// Let the left layout know the final margin
		helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

		// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
		totalLeftBoxesWidth = leftPadding;
		totalRightBoxesWidth = rightPadding;
		totalTopBoxesHeight = topPadding;
		totalBottomBoxesHeight = bottomPadding;

		helpers.each(leftBoxes, function(box) {
			totalLeftBoxesWidth += box.width;
		});

		helpers.each(rightBoxes, function(box) {
			totalRightBoxesWidth += box.width;
		});

		helpers.each(topBoxes, function(box) {
			totalTopBoxesHeight += box.height;
		});
		helpers.each(bottomBoxes, function(box) {
			totalBottomBoxesHeight += box.height;
		});

		// We may be adding some padding to account for rotated x axis labels
		var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
		totalLeftBoxesWidth += leftPaddingAddition;
		totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

		var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
		totalTopBoxesHeight += topPaddingAddition;
		totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

		// Figure out if our chart area changed. This would occur if the dataset layout label rotation
		// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
		// without calling `fit` again
		var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
		var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

		if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
			helpers.each(leftBoxes, function(box) {
				box.height = newMaxChartAreaHeight;
			});

			helpers.each(rightBoxes, function(box) {
				box.height = newMaxChartAreaHeight;
			});

			helpers.each(topBoxes, function(box) {
				if (!box.fullWidth) {
					box.width = newMaxChartAreaWidth;
				}
			});

			helpers.each(bottomBoxes, function(box) {
				if (!box.fullWidth) {
					box.width = newMaxChartAreaWidth;
				}
			});

			maxChartAreaHeight = newMaxChartAreaHeight;
			maxChartAreaWidth = newMaxChartAreaWidth;
		}

		// Step 7 - Position the boxes
		var left = leftPadding + leftPaddingAddition;
		var top = topPadding + topPaddingAddition;

		function placeBox(box) {
			if (box.isHorizontal()) {
				box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
				box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
				box.top = top;
				box.bottom = top + box.height;

				// Move to next point
				top = box.bottom;

			} else {

				box.left = left;
				box.right = left + box.width;
				box.top = totalTopBoxesHeight;
				box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

				// Move to next point
				left = box.right;
			}
		}

		helpers.each(leftBoxes.concat(topBoxes), placeBox);

		// Account for chart width and height
		left += maxChartAreaWidth;
		top += maxChartAreaHeight;

		helpers.each(rightBoxes, placeBox);
		helpers.each(bottomBoxes, placeBox);

		// Step 8
		chart.chartArea = {
			left: totalLeftBoxesWidth,
			top: totalTopBoxesHeight,
			right: totalLeftBoxesWidth + maxChartAreaWidth,
			bottom: totalTopBoxesHeight + maxChartAreaHeight
		};

		// Step 9
		helpers.each(chartAreaBoxes, function(box) {
			box.left = chart.chartArea.left;
			box.top = chart.chartArea.top;
			box.right = chart.chartArea.right;
			box.bottom = chart.chartArea.bottom;

			box.update(maxChartAreaWidth, maxChartAreaHeight);
		});
	}
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/core/core.scaleService.js":[function(require,module,exports) {
'use strict';

var defaults = require('./core.defaults');
var helpers = require('../helpers/index');
var layouts = require('./core.layouts');

module.exports = {
	// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
	// use the new chart options to grab the correct scale
	constructors: {},
	// Use a registration function so that we can move to an ES6 map when we no longer need to support
	// old browsers

	// Scale config defaults
	defaults: {},
	registerScaleType: function(type, scaleConstructor, scaleDefaults) {
		this.constructors[type] = scaleConstructor;
		this.defaults[type] = helpers.clone(scaleDefaults);
	},
	getScaleConstructor: function(type) {
		return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
	},
	getScaleDefaults: function(type) {
		// Return the scale defaults merged with the global settings so that we always use the latest ones
		return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
	},
	updateScaleDefaults: function(type, additions) {
		var me = this;
		if (me.defaults.hasOwnProperty(type)) {
			me.defaults[type] = helpers.extend(me.defaults[type], additions);
		}
	},
	addScalesToLayout: function(chart) {
		// Adds each scale to the chart.boxes array to be sized accordingly
		helpers.each(chart.scales, function(scale) {
			// Set ILayoutItem parameters for backwards compatibility
			scale.fullWidth = scale.options.fullWidth;
			scale.position = scale.options.position;
			scale.weight = scale.options.weight;
			layouts.addBox(chart, scale);
		});
	}
};

},{"./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","./core.layouts":"../node_modules/chart.js/src/core/core.layouts.js"}],"../node_modules/chart.js/src/core/core.helpers.js":[function(require,module,exports) {
/* global window: false */
/* global document: false */
'use strict';

var color = require('chartjs-color');
var defaults = require('./core.defaults');
var helpers = require('../helpers/index');
var scaleService = require('../core/core.scaleService');

module.exports = function() {

	// -- Basic js utility methods

	helpers.configMerge = function(/* objects ... */) {
		return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
			merger: function(key, target, source, options) {
				var tval = target[key] || {};
				var sval = source[key];

				if (key === 'scales') {
					// scale config merging is complex. Add our own function here for that
					target[key] = helpers.scaleMerge(tval, sval);
				} else if (key === 'scale') {
					// used in polar area & radar charts since there is only one scale
					target[key] = helpers.merge(tval, [scaleService.getScaleDefaults(sval.type), sval]);
				} else {
					helpers._merger(key, target, source, options);
				}
			}
		});
	};

	helpers.scaleMerge = function(/* objects ... */) {
		return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
			merger: function(key, target, source, options) {
				if (key === 'xAxes' || key === 'yAxes') {
					var slen = source[key].length;
					var i, type, scale;

					if (!target[key]) {
						target[key] = [];
					}

					for (i = 0; i < slen; ++i) {
						scale = source[key][i];
						type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

						if (i >= target[key].length) {
							target[key].push({});
						}

						if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
							// new/untyped scale or type changed: let's apply the new defaults
							// then merge source scale to correctly overwrite the defaults.
							helpers.merge(target[key][i], [scaleService.getScaleDefaults(type), scale]);
						} else {
							// scales type are the same
							helpers.merge(target[key][i], scale);
						}
					}
				} else {
					helpers._merger(key, target, source, options);
				}
			}
		});
	};

	helpers.where = function(collection, filterCallback) {
		if (helpers.isArray(collection) && Array.prototype.filter) {
			return collection.filter(filterCallback);
		}
		var filtered = [];

		helpers.each(collection, function(item) {
			if (filterCallback(item)) {
				filtered.push(item);
			}
		});

		return filtered;
	};
	helpers.findIndex = Array.prototype.findIndex ?
		function(array, callback, scope) {
			return array.findIndex(callback, scope);
		} :
		function(array, callback, scope) {
			scope = scope === undefined ? array : scope;
			for (var i = 0, ilen = array.length; i < ilen; ++i) {
				if (callback.call(scope, array[i], i, array)) {
					return i;
				}
			}
			return -1;
		};
	helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to start of the array
		if (helpers.isNullOrUndef(startIndex)) {
			startIndex = -1;
		}
		for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to end of the array
		if (helpers.isNullOrUndef(startIndex)) {
			startIndex = arrayToSearch.length;
		}
		for (var i = startIndex - 1; i >= 0; i--) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};

	// -- Math methods
	helpers.isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};
	helpers.almostEquals = function(x, y, epsilon) {
		return Math.abs(x - y) < epsilon;
	};
	helpers.almostWhole = function(x, epsilon) {
		var rounded = Math.round(x);
		return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
	};
	helpers.max = function(array) {
		return array.reduce(function(max, value) {
			if (!isNaN(value)) {
				return Math.max(max, value);
			}
			return max;
		}, Number.NEGATIVE_INFINITY);
	};
	helpers.min = function(array) {
		return array.reduce(function(min, value) {
			if (!isNaN(value)) {
				return Math.min(min, value);
			}
			return min;
		}, Number.POSITIVE_INFINITY);
	};
	helpers.sign = Math.sign ?
		function(x) {
			return Math.sign(x);
		} :
		function(x) {
			x = +x; // convert to a number
			if (x === 0 || isNaN(x)) {
				return x;
			}
			return x > 0 ? 1 : -1;
		};
	helpers.log10 = Math.log10 ?
		function(x) {
			return Math.log10(x);
		} :
		function(x) {
			var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
			// Check for whole powers of 10,
			// which due to floating point rounding error should be corrected.
			var powerOf10 = Math.round(exponent);
			var isPowerOf10 = x === Math.pow(10, powerOf10);

			return isPowerOf10 ? powerOf10 : exponent;
		};
	helpers.toRadians = function(degrees) {
		return degrees * (Math.PI / 180);
	};
	helpers.toDegrees = function(radians) {
		return radians * (180 / Math.PI);
	};
	// Gets the angle from vertical upright to the point about a centre.
	helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
		var distanceFromXCenter = anglePoint.x - centrePoint.x;
		var distanceFromYCenter = anglePoint.y - centrePoint.y;
		var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

		var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

		if (angle < (-0.5 * Math.PI)) {
			angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
		}

		return {
			angle: angle,
			distance: radialDistanceFromCenter
		};
	};
	helpers.distanceBetweenPoints = function(pt1, pt2) {
		return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
	};
	helpers.aliasPixel = function(pixelWidth) {
		return (pixelWidth % 2 === 0) ? 0 : 0.5;
	};
	helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
		// Props to Rob Spencer at scaled innovation for his post on splining between points
		// http://scaledinnovation.com/analytics/splines/aboutSplines.html

		// This function must also respect "skipped" points

		var previous = firstPoint.skip ? middlePoint : firstPoint;
		var current = middlePoint;
		var next = afterPoint.skip ? middlePoint : afterPoint;

		var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
		var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

		var s01 = d01 / (d01 + d12);
		var s12 = d12 / (d01 + d12);

		// If all points are the same, s01 & s02 will be inf
		s01 = isNaN(s01) ? 0 : s01;
		s12 = isNaN(s12) ? 0 : s12;

		var fa = t * s01; // scaling factor for triangle Ta
		var fb = t * s12;

		return {
			previous: {
				x: current.x - fa * (next.x - previous.x),
				y: current.y - fa * (next.y - previous.y)
			},
			next: {
				x: current.x + fb * (next.x - previous.x),
				y: current.y + fb * (next.y - previous.y)
			}
		};
	};
	helpers.EPSILON = Number.EPSILON || 1e-14;
	helpers.splineCurveMonotone = function(points) {
		// This function calculates Bzier control points in a similar way than |splineCurve|,
		// but preserves monotonicity of the provided data and ensures no local extremums are added
		// between the dataset discrete points due to the interpolation.
		// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

		var pointsWithTangents = (points || []).map(function(point) {
			return {
				model: point._model,
				deltaK: 0,
				mK: 0
			};
		});

		// Calculate slopes (deltaK) and initialize tangents (mK)
		var pointsLen = pointsWithTangents.length;
		var i, pointBefore, pointCurrent, pointAfter;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointAfter && !pointAfter.model.skip) {
				var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

				// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
				pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
			}

			if (!pointBefore || pointBefore.model.skip) {
				pointCurrent.mK = pointCurrent.deltaK;
			} else if (!pointAfter || pointAfter.model.skip) {
				pointCurrent.mK = pointBefore.deltaK;
			} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
				pointCurrent.mK = 0;
			} else {
				pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
			}
		}

		// Adjust tangents to ensure monotonic properties
		var alphaK, betaK, tauK, squaredMagnitude;
		for (i = 0; i < pointsLen - 1; ++i) {
			pointCurrent = pointsWithTangents[i];
			pointAfter = pointsWithTangents[i + 1];
			if (pointCurrent.model.skip || pointAfter.model.skip) {
				continue;
			}

			if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
				pointCurrent.mK = pointAfter.mK = 0;
				continue;
			}

			alphaK = pointCurrent.mK / pointCurrent.deltaK;
			betaK = pointAfter.mK / pointCurrent.deltaK;
			squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
			if (squaredMagnitude <= 9) {
				continue;
			}

			tauK = 3 / Math.sqrt(squaredMagnitude);
			pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
			pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
		}

		// Compute control points
		var deltaX;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointBefore && !pointBefore.model.skip) {
				deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
				pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
				pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
			}
			if (pointAfter && !pointAfter.model.skip) {
				deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
				pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
				pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
			}
		}
	};
	helpers.nextItem = function(collection, index, loop) {
		if (loop) {
			return index >= collection.length - 1 ? collection[0] : collection[index + 1];
		}
		return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
	};
	helpers.previousItem = function(collection, index, loop) {
		if (loop) {
			return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
		}
		return index <= 0 ? collection[0] : collection[index - 1];
	};
	// Implementation of the nice number algorithm used in determining where axis labels will go
	helpers.niceNum = function(range, round) {
		var exponent = Math.floor(helpers.log10(range));
		var fraction = range / Math.pow(10, exponent);
		var niceFraction;

		if (round) {
			if (fraction < 1.5) {
				niceFraction = 1;
			} else if (fraction < 3) {
				niceFraction = 2;
			} else if (fraction < 7) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
		} else if (fraction <= 1.0) {
			niceFraction = 1;
		} else if (fraction <= 2) {
			niceFraction = 2;
		} else if (fraction <= 5) {
			niceFraction = 5;
		} else {
			niceFraction = 10;
		}

		return niceFraction * Math.pow(10, exponent);
	};
	// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
	helpers.requestAnimFrame = (function() {
		if (typeof window === 'undefined') {
			return function(callback) {
				callback();
			};
		}
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				return window.setTimeout(callback, 1000 / 60);
			};
	}());
	// -- DOM methods
	helpers.getRelativePosition = function(evt, chart) {
		var mouseX, mouseY;
		var e = evt.originalEvent || evt;
		var canvas = evt.target || evt.srcElement;
		var boundingRect = canvas.getBoundingClientRect();

		var touches = e.touches;
		if (touches && touches.length > 0) {
			mouseX = touches[0].clientX;
			mouseY = touches[0].clientY;

		} else {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}

		// Scale mouse coordinates into canvas coordinates
		// by following the pattern laid out by 'jerryj' in the comments of
		// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
		var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
		var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
		var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
		var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

		// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
		// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

		return {
			x: mouseX,
			y: mouseY
		};

	};

	// Private helper function to convert max-width/max-height values that may be percentages into a number
	function parseMaxStyle(styleValue, node, parentProperty) {
		var valueInPixels;
		if (typeof styleValue === 'string') {
			valueInPixels = parseInt(styleValue, 10);

			if (styleValue.indexOf('%') !== -1) {
				// percentage * size in dimension
				valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
			}
		} else {
			valueInPixels = styleValue;
		}

		return valueInPixels;
	}

	/**
	 * Returns if the given value contains an effective constraint.
	 * @private
	 */
	function isConstrainedValue(value) {
		return value !== undefined && value !== null && value !== 'none';
	}

	// Private helper to get a constraint dimension
	// @param domNode : the node to check the constraint on
	// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
	// @param percentageProperty : property of parent to use when calculating width as a percentage
	// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
	function getConstraintDimension(domNode, maxStyle, percentageProperty) {
		var view = document.defaultView;
		var parentNode = helpers._getParentNode(domNode);
		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
		var hasCNode = isConstrainedValue(constrainedNode);
		var hasCContainer = isConstrainedValue(constrainedContainer);
		var infinity = Number.POSITIVE_INFINITY;

		if (hasCNode || hasCContainer) {
			return Math.min(
				hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
				hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
		}

		return 'none';
	}
	// returns Number or undefined if no constraint
	helpers.getConstraintWidth = function(domNode) {
		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
	};
	// returns Number or undefined if no constraint
	helpers.getConstraintHeight = function(domNode) {
		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
	};
	/**
	 * @private
 	 */
	helpers._calculatePadding = function(container, padding, parentDimension) {
		padding = helpers.getStyle(container, padding);

		return padding.indexOf('%') > -1 ? parentDimension / parseInt(padding, 10) : parseInt(padding, 10);
	};
	/**
	 * @private
	 */
	helpers._getParentNode = function(domNode) {
		var parent = domNode.parentNode;
		if (parent && parent.host) {
			parent = parent.host;
		}
		return parent;
	};
	helpers.getMaximumWidth = function(domNode) {
		var container = helpers._getParentNode(domNode);
		if (!container) {
			return domNode.clientWidth;
		}

		var clientWidth = container.clientWidth;
		var paddingLeft = helpers._calculatePadding(container, 'padding-left', clientWidth);
		var paddingRight = helpers._calculatePadding(container, 'padding-right', clientWidth);

		var w = clientWidth - paddingLeft - paddingRight;
		var cw = helpers.getConstraintWidth(domNode);
		return isNaN(cw) ? w : Math.min(w, cw);
	};
	helpers.getMaximumHeight = function(domNode) {
		var container = helpers._getParentNode(domNode);
		if (!container) {
			return domNode.clientHeight;
		}

		var clientHeight = container.clientHeight;
		var paddingTop = helpers._calculatePadding(container, 'padding-top', clientHeight);
		var paddingBottom = helpers._calculatePadding(container, 'padding-bottom', clientHeight);

		var h = clientHeight - paddingTop - paddingBottom;
		var ch = helpers.getConstraintHeight(domNode);
		return isNaN(ch) ? h : Math.min(h, ch);
	};
	helpers.getStyle = function(el, property) {
		return el.currentStyle ?
			el.currentStyle[property] :
			document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
	};
	helpers.retinaScale = function(chart, forceRatio) {
		var pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;
		if (pixelRatio === 1) {
			return;
		}

		var canvas = chart.canvas;
		var height = chart.height;
		var width = chart.width;

		canvas.height = height * pixelRatio;
		canvas.width = width * pixelRatio;
		chart.ctx.scale(pixelRatio, pixelRatio);

		// If no style has been set on the canvas, the render size is used as display size,
		// making the chart visually bigger, so let's enforce it to the "correct" values.
		// See https://github.com/chartjs/Chart.js/issues/3575
		if (!canvas.style.height && !canvas.style.width) {
			canvas.style.height = height + 'px';
			canvas.style.width = width + 'px';
		}
	};
	// -- Canvas methods
	helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
		return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
	};
	helpers.longestText = function(ctx, font, arrayOfThings, cache) {
		cache = cache || {};
		var data = cache.data = cache.data || {};
		var gc = cache.garbageCollect = cache.garbageCollect || [];

		if (cache.font !== font) {
			data = cache.data = {};
			gc = cache.garbageCollect = [];
			cache.font = font;
		}

		ctx.font = font;
		var longest = 0;
		helpers.each(arrayOfThings, function(thing) {
			// Undefined strings and arrays should not be measured
			if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
				longest = helpers.measureText(ctx, data, gc, longest, thing);
			} else if (helpers.isArray(thing)) {
				// if it is an array lets measure each element
				// to do maybe simplify this function a bit so we can do this more recursively?
				helpers.each(thing, function(nestedThing) {
					// Undefined strings and arrays should not be measured
					if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
						longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
					}
				});
			}
		});

		var gcLen = gc.length / 2;
		if (gcLen > arrayOfThings.length) {
			for (var i = 0; i < gcLen; i++) {
				delete data[gc[i]];
			}
			gc.splice(0, gcLen);
		}
		return longest;
	};
	helpers.measureText = function(ctx, data, gc, longest, string) {
		var textWidth = data[string];
		if (!textWidth) {
			textWidth = data[string] = ctx.measureText(string).width;
			gc.push(string);
		}
		if (textWidth > longest) {
			longest = textWidth;
		}
		return longest;
	};
	helpers.numberOfLabelLines = function(arrayOfThings) {
		var numberOfLines = 1;
		helpers.each(arrayOfThings, function(thing) {
			if (helpers.isArray(thing)) {
				if (thing.length > numberOfLines) {
					numberOfLines = thing.length;
				}
			}
		});
		return numberOfLines;
	};

	helpers.color = !color ?
		function(value) {
			console.error('Color.js not found!');
			return value;
		} :
		function(value) {
			/* global CanvasGradient */
			if (value instanceof CanvasGradient) {
				value = defaults.global.defaultColor;
			}

			return color(value);
		};

	helpers.getHoverColor = function(colorValue) {
		/* global CanvasPattern */
		return (colorValue instanceof CanvasPattern) ?
			colorValue :
			helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
	};
};

},{"chartjs-color":"../node_modules/chartjs-color/index.js","./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js"}],"../node_modules/chart.js/src/core/core.element.js":[function(require,module,exports) {
'use strict';

var color = require('chartjs-color');
var helpers = require('../helpers/index');

function interpolate(start, view, model, ease) {
	var keys = Object.keys(model);
	var i, ilen, key, actual, origin, target, type, c0, c1;

	for (i = 0, ilen = keys.length; i < ilen; ++i) {
		key = keys[i];

		target = model[key];

		// if a value is added to the model after pivot() has been called, the view
		// doesn't contain it, so let's initialize the view to the target value.
		if (!view.hasOwnProperty(key)) {
			view[key] = target;
		}

		actual = view[key];

		if (actual === target || key[0] === '_') {
			continue;
		}

		if (!start.hasOwnProperty(key)) {
			start[key] = actual;
		}

		origin = start[key];

		type = typeof target;

		if (type === typeof origin) {
			if (type === 'string') {
				c0 = color(origin);
				if (c0.valid) {
					c1 = color(target);
					if (c1.valid) {
						view[key] = c1.mix(c0, ease).rgbString();
						continue;
					}
				}
			} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
				view[key] = origin + (target - origin) * ease;
				continue;
			}
		}

		view[key] = target;
	}
}

var Element = function(configuration) {
	helpers.extend(this, configuration);
	this.initialize.apply(this, arguments);
};

helpers.extend(Element.prototype, {

	initialize: function() {
		this.hidden = false;
	},

	pivot: function() {
		var me = this;
		if (!me._view) {
			me._view = helpers.clone(me._model);
		}
		me._start = {};
		return me;
	},

	transition: function(ease) {
		var me = this;
		var model = me._model;
		var start = me._start;
		var view = me._view;

		// No animation -> No Transition
		if (!model || ease === 1) {
			me._view = model;
			me._start = null;
			return me;
		}

		if (!view) {
			view = me._view = {};
		}

		if (!start) {
			start = me._start = {};
		}

		interpolate(start, view, model, ease);

		return me;
	},

	tooltipPosition: function() {
		return {
			x: this._model.x,
			y: this._model.y
		};
	},

	hasValue: function() {
		return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
	}
});

Element.extend = helpers.inherits;

module.exports = Element;

},{"chartjs-color":"../node_modules/chartjs-color/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/core/core.animation.js":[function(require,module,exports) {
'use strict';

var Element = require('./core.element');

var exports = module.exports = Element.extend({
	chart: null, // the animation associated chart instance
	currentStep: 0, // the current animation step
	numSteps: 60, // default number of steps
	easing: '', // the easing to use for this animation
	render: null, // render function used by the animation service

	onAnimationProgress: null, // user specified callback to fire on each step of the animation
	onAnimationComplete: null, // user specified callback to fire when the animation finishes
});

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.Animation instead
 * @prop Chart.Animation#animationObject
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 */
Object.defineProperty(exports.prototype, 'animationObject', {
	get: function() {
		return this;
	}
});

/**
 * Provided for backward compatibility, use Chart.Animation#chart instead
 * @prop Chart.Animation#chartInstance
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 */
Object.defineProperty(exports.prototype, 'chartInstance', {
	get: function() {
		return this.chart;
	},
	set: function(value) {
		this.chart = value;
	}
});

},{"./core.element":"../node_modules/chart.js/src/core/core.element.js"}],"../node_modules/chart.js/src/core/core.animations.js":[function(require,module,exports) {
/* global window: false */
'use strict';

var defaults = require('./core.defaults');
var helpers = require('../helpers/index');

defaults._set('global', {
	animation: {
		duration: 1000,
		easing: 'easeOutQuart',
		onProgress: helpers.noop,
		onComplete: helpers.noop
	}
});

module.exports = {
	frameDuration: 17,
	animations: [],
	dropFrames: 0,
	request: null,

	/**
	 * @param {Chart} chart - The chart to animate.
	 * @param {Chart.Animation} animation - The animation that we will animate.
	 * @param {Number} duration - The animation duration in ms.
	 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
	 */
	addAnimation: function(chart, animation, duration, lazy) {
		var animations = this.animations;
		var i, ilen;

		animation.chart = chart;

		if (!lazy) {
			chart.animating = true;
		}

		for (i = 0, ilen = animations.length; i < ilen; ++i) {
			if (animations[i].chart === chart) {
				animations[i] = animation;
				return;
			}
		}

		animations.push(animation);

		// If there are no animations queued, manually kickstart a digest, for lack of a better word
		if (animations.length === 1) {
			this.requestAnimationFrame();
		}
	},

	cancelAnimation: function(chart) {
		var index = helpers.findIndex(this.animations, function(animation) {
			return animation.chart === chart;
		});

		if (index !== -1) {
			this.animations.splice(index, 1);
			chart.animating = false;
		}
	},

	requestAnimationFrame: function() {
		var me = this;
		if (me.request === null) {
			// Skip animation frame requests until the active one is executed.
			// This can happen when processing mouse events, e.g. 'mousemove'
			// and 'mouseout' events will trigger multiple renders.
			me.request = helpers.requestAnimFrame.call(window, function() {
				me.request = null;
				me.startDigest();
			});
		}
	},

	/**
	 * @private
	 */
	startDigest: function() {
		var me = this;
		var startTime = Date.now();
		var framesToDrop = 0;

		if (me.dropFrames > 1) {
			framesToDrop = Math.floor(me.dropFrames);
			me.dropFrames = me.dropFrames % 1;
		}

		me.advance(1 + framesToDrop);

		var endTime = Date.now();

		me.dropFrames += (endTime - startTime) / me.frameDuration;

		// Do we have more stuff to animate?
		if (me.animations.length > 0) {
			me.requestAnimationFrame();
		}
	},

	/**
	 * @private
	 */
	advance: function(count) {
		var animations = this.animations;
		var animation, chart;
		var i = 0;

		while (i < animations.length) {
			animation = animations[i];
			chart = animation.chart;

			animation.currentStep = (animation.currentStep || 0) + count;
			animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

			helpers.callback(animation.render, [chart, animation], chart);
			helpers.callback(animation.onAnimationProgress, [animation], chart);

			if (animation.currentStep >= animation.numSteps) {
				helpers.callback(animation.onAnimationComplete, [animation], chart);
				chart.animating = false;
				animations.splice(i, 1);
			} else {
				++i;
			}
		}
	}
};

},{"./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/elements/element.arc.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var Element = require('../core/core.element');
var helpers = require('../helpers/index');

defaults._set('global', {
	elements: {
		arc: {
			backgroundColor: defaults.global.defaultColor,
			borderColor: '#fff',
			borderWidth: 2
		}
	}
});

module.exports = Element.extend({
	inLabelRange: function(mouseX) {
		var vm = this._view;

		if (vm) {
			return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
		}
		return false;
	},

	inRange: function(chartX, chartY) {
		var vm = this._view;

		if (vm) {
			var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
			var	angle = pointRelativePosition.angle;
			var distance = pointRelativePosition.distance;

			// Sanitise angle range
			var startAngle = vm.startAngle;
			var endAngle = vm.endAngle;
			while (endAngle < startAngle) {
				endAngle += 2.0 * Math.PI;
			}
			while (angle > endAngle) {
				angle -= 2.0 * Math.PI;
			}
			while (angle < startAngle) {
				angle += 2.0 * Math.PI;
			}

			// Check if within the range of the open/close angle
			var betweenAngles = (angle >= startAngle && angle <= endAngle);
			var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

			return (betweenAngles && withinRadius);
		}
		return false;
	},

	getCenterPoint: function() {
		var vm = this._view;
		var halfAngle = (vm.startAngle + vm.endAngle) / 2;
		var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
		return {
			x: vm.x + Math.cos(halfAngle) * halfRadius,
			y: vm.y + Math.sin(halfAngle) * halfRadius
		};
	},

	getArea: function() {
		var vm = this._view;
		return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
	},

	tooltipPosition: function() {
		var vm = this._view;
		var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
		var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

		return {
			x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
			y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
		};
	},

	draw: function() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var sA = vm.startAngle;
		var eA = vm.endAngle;

		ctx.beginPath();

		ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
		ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

		ctx.closePath();
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = vm.borderWidth;

		ctx.fillStyle = vm.backgroundColor;

		ctx.fill();
		ctx.lineJoin = 'bevel';

		if (vm.borderWidth) {
			ctx.stroke();
		}
	}
});

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../core/core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/elements/element.line.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var Element = require('../core/core.element');
var helpers = require('../helpers/index');

var globalDefaults = defaults.global;

defaults._set('global', {
	elements: {
		line: {
			tension: 0.4,
			backgroundColor: globalDefaults.defaultColor,
			borderWidth: 3,
			borderColor: globalDefaults.defaultColor,
			borderCapStyle: 'butt',
			borderDash: [],
			borderDashOffset: 0.0,
			borderJoinStyle: 'miter',
			capBezierPoints: true,
			fill: true, // do we fill in the area between the line and its base axis
		}
	}
});

module.exports = Element.extend({
	draw: function() {
		var me = this;
		var vm = me._view;
		var ctx = me._chart.ctx;
		var spanGaps = vm.spanGaps;
		var points = me._children.slice(); // clone array
		var globalOptionLineElements = globalDefaults.elements.line;
		var lastDrawnIndex = -1;
		var index, current, previous, currentVM;

		// If we are looping, adding the first point again
		if (me._loop && points.length) {
			points.push(points[0]);
		}

		ctx.save();

		// Stroke Line Options
		ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

		// IE 9 and 10 do not support line dash
		if (ctx.setLineDash) {
			ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
		}

		ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
		ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
		ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
		ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

		// Stroke Line
		ctx.beginPath();
		lastDrawnIndex = -1;

		for (index = 0; index < points.length; ++index) {
			current = points[index];
			previous = helpers.previousItem(points, index);
			currentVM = current._view;

			// First point moves to it's starting position no matter what
			if (index === 0) {
				if (!currentVM.skip) {
					ctx.moveTo(currentVM.x, currentVM.y);
					lastDrawnIndex = index;
				}
			} else {
				previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

				if (!currentVM.skip) {
					if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
						// There was a gap and this is the first point after the gap
						ctx.moveTo(currentVM.x, currentVM.y);
					} else {
						// Line to next point
						helpers.canvas.lineTo(ctx, previous._view, current._view);
					}
					lastDrawnIndex = index;
				}
			}
		}

		ctx.stroke();
		ctx.restore();
	}
});

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../core/core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/elements/element.point.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var Element = require('../core/core.element');
var helpers = require('../helpers/index');

var defaultColor = defaults.global.defaultColor;

defaults._set('global', {
	elements: {
		point: {
			radius: 3,
			pointStyle: 'circle',
			backgroundColor: defaultColor,
			borderColor: defaultColor,
			borderWidth: 1,
			// Hover
			hitRadius: 1,
			hoverRadius: 4,
			hoverBorderWidth: 1
		}
	}
});

function xRange(mouseX) {
	var vm = this._view;
	return vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
}

function yRange(mouseY) {
	var vm = this._view;
	return vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
}

module.exports = Element.extend({
	inRange: function(mouseX, mouseY) {
		var vm = this._view;
		return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
	},

	inLabelRange: xRange,
	inXRange: xRange,
	inYRange: yRange,

	getCenterPoint: function() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y
		};
	},

	getArea: function() {
		return Math.PI * Math.pow(this._view.radius, 2);
	},

	tooltipPosition: function() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y,
			padding: vm.radius + vm.borderWidth
		};
	},

	draw: function(chartArea) {
		var vm = this._view;
		var model = this._model;
		var ctx = this._chart.ctx;
		var pointStyle = vm.pointStyle;
		var rotation = vm.rotation;
		var radius = vm.radius;
		var x = vm.x;
		var y = vm.y;
		var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)

		if (vm.skip) {
			return;
		}

		// Clipping for Points.
		if (chartArea === undefined || (model.x >= chartArea.left && chartArea.right * errMargin >= model.x && model.y >= chartArea.top && chartArea.bottom * errMargin >= model.y)) {
			ctx.strokeStyle = vm.borderColor || defaultColor;
			ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
			ctx.fillStyle = vm.backgroundColor || defaultColor;
			helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
		}
	}
});

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../core/core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/elements/element.rectangle.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var Element = require('../core/core.element');

defaults._set('global', {
	elements: {
		rectangle: {
			backgroundColor: defaults.global.defaultColor,
			borderColor: defaults.global.defaultColor,
			borderSkipped: 'bottom',
			borderWidth: 0
		}
	}
});

function isVertical(bar) {
	return bar._view.width !== undefined;
}

/**
 * Helper function to get the bounds of the bar regardless of the orientation
 * @param bar {Chart.Element.Rectangle} the bar
 * @return {Bounds} bounds of the bar
 * @private
 */
function getBarBounds(bar) {
	var vm = bar._view;
	var x1, x2, y1, y2;

	if (isVertical(bar)) {
		// vertical
		var halfWidth = vm.width / 2;
		x1 = vm.x - halfWidth;
		x2 = vm.x + halfWidth;
		y1 = Math.min(vm.y, vm.base);
		y2 = Math.max(vm.y, vm.base);
	} else {
		// horizontal bar
		var halfHeight = vm.height / 2;
		x1 = Math.min(vm.x, vm.base);
		x2 = Math.max(vm.x, vm.base);
		y1 = vm.y - halfHeight;
		y2 = vm.y + halfHeight;
	}

	return {
		left: x1,
		top: y1,
		right: x2,
		bottom: y2
	};
}

module.exports = Element.extend({
	draw: function() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var left, right, top, bottom, signX, signY, borderSkipped;
		var borderWidth = vm.borderWidth;

		if (!vm.horizontal) {
			// bar
			left = vm.x - vm.width / 2;
			right = vm.x + vm.width / 2;
			top = vm.y;
			bottom = vm.base;
			signX = 1;
			signY = bottom > top ? 1 : -1;
			borderSkipped = vm.borderSkipped || 'bottom';
		} else {
			// horizontal bar
			left = vm.base;
			right = vm.x;
			top = vm.y - vm.height / 2;
			bottom = vm.y + vm.height / 2;
			signX = right > left ? 1 : -1;
			signY = 1;
			borderSkipped = vm.borderSkipped || 'left';
		}

		// Canvas doesn't allow us to stroke inside the width so we can
		// adjust the sizes to fit if we're setting a stroke on the line
		if (borderWidth) {
			// borderWidth shold be less than bar width and bar height.
			var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
			borderWidth = borderWidth > barSize ? barSize : borderWidth;
			var halfStroke = borderWidth / 2;
			// Adjust borderWidth when bar top position is near vm.base(zero).
			var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
			var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
			var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
			var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
			// not become a vertical line?
			if (borderLeft !== borderRight) {
				top = borderTop;
				bottom = borderBottom;
			}
			// not become a horizontal line?
			if (borderTop !== borderBottom) {
				left = borderLeft;
				right = borderRight;
			}
		}

		ctx.beginPath();
		ctx.fillStyle = vm.backgroundColor;
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = borderWidth;

		// Corner points, from bottom-left to bottom-right clockwise
		// | 1 2 |
		// | 0 3 |
		var corners = [
			[left, bottom],
			[left, top],
			[right, top],
			[right, bottom]
		];

		// Find first (starting) corner with fallback to 'bottom'
		var borders = ['bottom', 'left', 'top', 'right'];
		var startCorner = borders.indexOf(borderSkipped, 0);
		if (startCorner === -1) {
			startCorner = 0;
		}

		function cornerAt(index) {
			return corners[(startCorner + index) % 4];
		}

		// Draw rectangle from 'startCorner'
		var corner = cornerAt(0);
		ctx.moveTo(corner[0], corner[1]);

		for (var i = 1; i < 4; i++) {
			corner = cornerAt(i);
			ctx.lineTo(corner[0], corner[1]);
		}

		ctx.fill();
		if (borderWidth) {
			ctx.stroke();
		}
	},

	height: function() {
		var vm = this._view;
		return vm.base - vm.y;
	},

	inRange: function(mouseX, mouseY) {
		var inRange = false;

		if (this._view) {
			var bounds = getBarBounds(this);
			inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
		}

		return inRange;
	},

	inLabelRange: function(mouseX, mouseY) {
		var me = this;
		if (!me._view) {
			return false;
		}

		var inRange = false;
		var bounds = getBarBounds(me);

		if (isVertical(me)) {
			inRange = mouseX >= bounds.left && mouseX <= bounds.right;
		} else {
			inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
		}

		return inRange;
	},

	inXRange: function(mouseX) {
		var bounds = getBarBounds(this);
		return mouseX >= bounds.left && mouseX <= bounds.right;
	},

	inYRange: function(mouseY) {
		var bounds = getBarBounds(this);
		return mouseY >= bounds.top && mouseY <= bounds.bottom;
	},

	getCenterPoint: function() {
		var vm = this._view;
		var x, y;
		if (isVertical(this)) {
			x = vm.x;
			y = (vm.y + vm.base) / 2;
		} else {
			x = (vm.x + vm.base) / 2;
			y = vm.y;
		}

		return {x: x, y: y};
	},

	getArea: function() {
		var vm = this._view;
		return vm.width * Math.abs(vm.y - vm.base);
	},

	tooltipPosition: function() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y
		};
	}
});

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../core/core.element":"../node_modules/chart.js/src/core/core.element.js"}],"../node_modules/chart.js/src/elements/index.js":[function(require,module,exports) {
'use strict';

module.exports = {};
module.exports.Arc = require('./element.arc');
module.exports.Line = require('./element.line');
module.exports.Point = require('./element.point');
module.exports.Rectangle = require('./element.rectangle');

},{"./element.arc":"../node_modules/chart.js/src/elements/element.arc.js","./element.line":"../node_modules/chart.js/src/elements/element.line.js","./element.point":"../node_modules/chart.js/src/elements/element.point.js","./element.rectangle":"../node_modules/chart.js/src/elements/element.rectangle.js"}],"../node_modules/chart.js/src/core/core.interaction.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');

/**
 * Helper function to get relative position for an event
 * @param {Event|IEvent} event - The event to get the position for
 * @param {Chart} chart - The chart
 * @returns {Point} the event position
 */
function getRelativePosition(e, chart) {
	if (e.native) {
		return {
			x: e.x,
			y: e.y
		};
	}

	return helpers.getRelativePosition(e, chart);
}

/**
 * Helper function to traverse all of the visible elements in the chart
 * @param chart {chart} the chart
 * @param handler {Function} the callback to execute for each visible item
 */
function parseVisibleItems(chart, handler) {
	var datasets = chart.data.datasets;
	var meta, i, j, ilen, jlen;

	for (i = 0, ilen = datasets.length; i < ilen; ++i) {
		if (!chart.isDatasetVisible(i)) {
			continue;
		}

		meta = chart.getDatasetMeta(i);
		for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
			var element = meta.data[j];
			if (!element._view.skip) {
				handler(element);
			}
		}
	}
}

/**
 * Helper function to get the items that intersect the event position
 * @param items {ChartElement[]} elements to filter
 * @param position {Point} the point to be nearest to
 * @return {ChartElement[]} the nearest items
 */
function getIntersectItems(chart, position) {
	var elements = [];

	parseVisibleItems(chart, function(element) {
		if (element.inRange(position.x, position.y)) {
			elements.push(element);
		}
	});

	return elements;
}

/**
 * Helper function to get the items nearest to the event position considering all visible items in teh chart
 * @param chart {Chart} the chart to look at elements from
 * @param position {Point} the point to be nearest to
 * @param intersect {Boolean} if true, only consider items that intersect the position
 * @param distanceMetric {Function} function to provide the distance between points
 * @return {ChartElement[]} the nearest items
 */
function getNearestItems(chart, position, intersect, distanceMetric) {
	var minDistance = Number.POSITIVE_INFINITY;
	var nearestItems = [];

	parseVisibleItems(chart, function(element) {
		if (intersect && !element.inRange(position.x, position.y)) {
			return;
		}

		var center = element.getCenterPoint();
		var distance = distanceMetric(position, center);

		if (distance < minDistance) {
			nearestItems = [element];
			minDistance = distance;
		} else if (distance === minDistance) {
			// Can have multiple items at the same distance in which case we sort by size
			nearestItems.push(element);
		}
	});

	return nearestItems;
}

/**
 * Get a distance metric function for two points based on the
 * axis mode setting
 * @param {String} axis the axis mode. x|y|xy
 */
function getDistanceMetricForAxis(axis) {
	var useX = axis.indexOf('x') !== -1;
	var useY = axis.indexOf('y') !== -1;

	return function(pt1, pt2) {
		var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
		var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	};
}

function indexMode(chart, e, options) {
	var position = getRelativePosition(e, chart);
	// Default axis for index mode is 'x' to match old behaviour
	options.axis = options.axis || 'x';
	var distanceMetric = getDistanceMetricForAxis(options.axis);
	var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
	var elements = [];

	if (!items.length) {
		return [];
	}

	chart.data.datasets.forEach(function(dataset, datasetIndex) {
		if (chart.isDatasetVisible(datasetIndex)) {
			var meta = chart.getDatasetMeta(datasetIndex);
			var element = meta.data[items[0]._index];

			// don't count items that are skipped (null data)
			if (element && !element._view.skip) {
				elements.push(element);
			}
		}
	});

	return elements;
}

/**
 * @interface IInteractionOptions
 */
/**
 * If true, only consider items that intersect the point
 * @name IInterfaceOptions#boolean
 * @type Boolean
 */

/**
 * Contains interaction related functions
 * @namespace Chart.Interaction
 */
module.exports = {
	// Helper function for different modes
	modes: {
		single: function(chart, e) {
			var position = getRelativePosition(e, chart);
			var elements = [];

			parseVisibleItems(chart, function(element) {
				if (element.inRange(position.x, position.y)) {
					elements.push(element);
					return elements;
				}
			});

			return elements.slice(0, 1);
		},

		/**
		 * @function Chart.Interaction.modes.label
		 * @deprecated since version 2.4.0
		 * @todo remove at version 3
		 * @private
		 */
		label: indexMode,

		/**
		 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
		 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
		 * @function Chart.Interaction.modes.index
		 * @since v2.4.0
		 * @param chart {chart} the chart we are returning items from
		 * @param e {Event} the event we are find things at
		 * @param options {IInteractionOptions} options to use during interaction
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		index: indexMode,

		/**
		 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
		 * If the options.intersect is false, we find the nearest item and return the items in that dataset
		 * @function Chart.Interaction.modes.dataset
		 * @param chart {chart} the chart we are returning items from
		 * @param e {Event} the event we are find things at
		 * @param options {IInteractionOptions} options to use during interaction
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		dataset: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			options.axis = options.axis || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

			if (items.length > 0) {
				items = chart.getDatasetMeta(items[0]._datasetIndex).data;
			}

			return items;
		},

		/**
		 * @function Chart.Interaction.modes.x-axis
		 * @deprecated since version 2.4.0. Use index mode and intersect == true
		 * @todo remove at version 3
		 * @private
		 */
		'x-axis': function(chart, e) {
			return indexMode(chart, e, {intersect: false});
		},

		/**
		 * Point mode returns all elements that hit test based on the event position
		 * of the event
		 * @function Chart.Interaction.modes.intersect
		 * @param chart {chart} the chart we are returning items from
		 * @param e {Event} the event we are find things at
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		point: function(chart, e) {
			var position = getRelativePosition(e, chart);
			return getIntersectItems(chart, position);
		},

		/**
		 * nearest mode returns the element closest to the point
		 * @function Chart.Interaction.modes.intersect
		 * @param chart {chart} the chart we are returning items from
		 * @param e {Event} the event we are find things at
		 * @param options {IInteractionOptions} options to use
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		nearest: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			options.axis = options.axis || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

			// We have multiple items at the same distance from the event. Now sort by smallest
			if (nearestItems.length > 1) {
				nearestItems.sort(function(a, b) {
					var sizeA = a.getArea();
					var sizeB = b.getArea();
					var ret = sizeA - sizeB;

					if (ret === 0) {
						// if equal sort by dataset index
						ret = a._datasetIndex - b._datasetIndex;
					}

					return ret;
				});
			}

			// Return only 1 item
			return nearestItems.slice(0, 1);
		},

		/**
		 * x mode returns the elements that hit-test at the current x coordinate
		 * @function Chart.Interaction.modes.x
		 * @param chart {chart} the chart we are returning items from
		 * @param e {Event} the event we are find things at
		 * @param options {IInteractionOptions} options to use
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		x: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			var items = [];
			var intersectsItem = false;

			parseVisibleItems(chart, function(element) {
				if (element.inXRange(position.x)) {
					items.push(element);
				}

				if (element.inRange(position.x, position.y)) {
					intersectsItem = true;
				}
			});

			// If we want to trigger on an intersect and we don't have any items
			// that intersect the position, return nothing
			if (options.intersect && !intersectsItem) {
				items = [];
			}
			return items;
		},

		/**
		 * y mode returns the elements that hit-test at the current y coordinate
		 * @function Chart.Interaction.modes.y
		 * @param chart {chart} the chart we are returning items from
		 * @param e {Event} the event we are find things at
		 * @param options {IInteractionOptions} options to use
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		y: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			var items = [];
			var intersectsItem = false;

			parseVisibleItems(chart, function(element) {
				if (element.inYRange(position.y)) {
					items.push(element);
				}

				if (element.inRange(position.x, position.y)) {
					intersectsItem = true;
				}
			});

			// If we want to trigger on an intersect and we don't have any items
			// that intersect the position, return nothing
			if (options.intersect && !intersectsItem) {
				items = [];
			}
			return items;
		}
	}
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/platforms/platform.basic.js":[function(require,module,exports) {
/**
 * Platform fallback implementation (minimal).
 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
 */

module.exports = {
	acquireContext: function(item) {
		if (item && item.canvas) {
			// Support for any object associated to a canvas (including a context2d)
			item = item.canvas;
		}

		return item && item.getContext('2d') || null;
	}
};

},{}],"../node_modules/chart.js/src/platforms/platform.dom.js":[function(require,module,exports) {
/**
 * Chart.Platform implementation for targeting a web browser
 */

'use strict';

var helpers = require('../helpers/index');

var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

/**
 * DOM event types -> Chart.js event types.
 * Note: only events with different types are mapped.
 * @see https://developer.mozilla.org/en-US/docs/Web/Events
 */
var EVENT_TYPES = {
	touchstart: 'mousedown',
	touchmove: 'mousemove',
	touchend: 'mouseup',
	pointerenter: 'mouseenter',
	pointerdown: 'mousedown',
	pointermove: 'mousemove',
	pointerup: 'mouseup',
	pointerleave: 'mouseout',
	pointerout: 'mouseout'
};

/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns {Number} Size in pixels or undefined if unknown.
 */
function readUsedSize(element, property) {
	var value = helpers.getStyle(element, property);
	var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
	return matches ? Number(matches[1]) : undefined;
}

/**
 * Initializes the canvas style and render size without modifying the canvas display size,
 * since responsiveness is handled by the controller.resize() method. The config is used
 * to determine the aspect ratio to apply in case no explicit height has been specified.
 */
function initCanvas(canvas, config) {
	var style = canvas.style;

	// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
	// returns null or '' if no explicit value has been set to the canvas attribute.
	var renderHeight = canvas.getAttribute('height');
	var renderWidth = canvas.getAttribute('width');

	// Chart.js modifies some canvas values that we want to restore on destroy
	canvas[EXPANDO_KEY] = {
		initial: {
			height: renderHeight,
			width: renderWidth,
			style: {
				display: style.display,
				height: style.height,
				width: style.width
			}
		}
	};

	// Force canvas to display as block to avoid extra space caused by inline
	// elements, which would interfere with the responsive resize process.
	// https://github.com/chartjs/Chart.js/issues/2538
	style.display = style.display || 'block';

	if (renderWidth === null || renderWidth === '') {
		var displayWidth = readUsedSize(canvas, 'width');
		if (displayWidth !== undefined) {
			canvas.width = displayWidth;
		}
	}

	if (renderHeight === null || renderHeight === '') {
		if (canvas.style.height === '') {
			// If no explicit render height and style height, let's apply the aspect ratio,
			// which one can be specified by the user but also by charts as default option
			// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
			canvas.height = canvas.width / (config.options.aspectRatio || 2);
		} else {
			var displayHeight = readUsedSize(canvas, 'height');
			if (displayWidth !== undefined) {
				canvas.height = displayHeight;
			}
		}
	}

	return canvas;
}

/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */
var supportsEventListenerOptions = (function() {
	var supports = false;
	try {
		var options = Object.defineProperty({}, 'passive', {
			get: function() {
				supports = true;
			}
		});
		window.addEventListener('e', null, options);
	} catch (e) {
		// continue regardless of error
	}
	return supports;
}());

// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
// https://github.com/chartjs/Chart.js/issues/4287
var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;

function addEventListener(node, type, listener) {
	node.addEventListener(type, listener, eventListenerOptions);
}

function removeEventListener(node, type, listener) {
	node.removeEventListener(type, listener, eventListenerOptions);
}

function createEvent(type, chart, x, y, nativeEvent) {
	return {
		type: type,
		chart: chart,
		native: nativeEvent || null,
		x: x !== undefined ? x : null,
		y: y !== undefined ? y : null,
	};
}

function fromNativeEvent(event, chart) {
	var type = EVENT_TYPES[event.type] || event.type;
	var pos = helpers.getRelativePosition(event, chart);
	return createEvent(type, chart, pos.x, pos.y, event);
}

function throttled(fn, thisArg) {
	var ticking = false;
	var args = [];

	return function() {
		args = Array.prototype.slice.call(arguments);
		thisArg = thisArg || this;

		if (!ticking) {
			ticking = true;
			helpers.requestAnimFrame.call(window, function() {
				ticking = false;
				fn.apply(thisArg, args);
			});
		}
	};
}

// Implementation based on https://github.com/marcj/css-element-queries
function createResizer(handler) {
	var resizer = document.createElement('div');
	var cls = CSS_PREFIX + 'size-monitor';
	var maxSize = 1000000;
	var style =
		'position:absolute;' +
		'left:0;' +
		'top:0;' +
		'right:0;' +
		'bottom:0;' +
		'overflow:hidden;' +
		'pointer-events:none;' +
		'visibility:hidden;' +
		'z-index:-1;';

	resizer.style.cssText = style;
	resizer.className = cls;
	resizer.innerHTML =
		'<div class="' + cls + '-expand" style="' + style + '">' +
			'<div style="' +
				'position:absolute;' +
				'width:' + maxSize + 'px;' +
				'height:' + maxSize + 'px;' +
				'left:0;' +
				'top:0">' +
			'</div>' +
		'</div>' +
		'<div class="' + cls + '-shrink" style="' + style + '">' +
			'<div style="' +
				'position:absolute;' +
				'width:200%;' +
				'height:200%;' +
				'left:0; ' +
				'top:0">' +
			'</div>' +
		'</div>';

	var expand = resizer.childNodes[0];
	var shrink = resizer.childNodes[1];

	resizer._reset = function() {
		expand.scrollLeft = maxSize;
		expand.scrollTop = maxSize;
		shrink.scrollLeft = maxSize;
		shrink.scrollTop = maxSize;
	};
	var onScroll = function() {
		resizer._reset();
		handler();
	};

	addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
	addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

	return resizer;
}

// https://davidwalsh.name/detect-node-insertion
function watchForRender(node, handler) {
	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
	var proxy = expando.renderProxy = function(e) {
		if (e.animationName === CSS_RENDER_ANIMATION) {
			handler();
		}
	};

	helpers.each(ANIMATION_START_EVENTS, function(type) {
		addEventListener(node, type, proxy);
	});

	// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
	// is removed then added back immediately (same animation frame?). Accessing the
	// `offsetParent` property will force a reflow and re-evaluate the CSS animation.
	// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
	// https://github.com/chartjs/Chart.js/issues/4737
	expando.reflow = !!node.offsetParent;

	node.classList.add(CSS_RENDER_MONITOR);
}

function unwatchForRender(node) {
	var expando = node[EXPANDO_KEY] || {};
	var proxy = expando.renderProxy;

	if (proxy) {
		helpers.each(ANIMATION_START_EVENTS, function(type) {
			removeEventListener(node, type, proxy);
		});

		delete expando.renderProxy;
	}

	node.classList.remove(CSS_RENDER_MONITOR);
}

function addResizeListener(node, listener, chart) {
	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

	// Let's keep track of this added resizer and thus avoid DOM query when removing it.
	var resizer = expando.resizer = createResizer(throttled(function() {
		if (expando.resizer) {
			return listener(createEvent('resize', chart));
		}
	}));

	// The resizer needs to be attached to the node parent, so we first need to be
	// sure that `node` is attached to the DOM before injecting the resizer element.
	watchForRender(node, function() {
		if (expando.resizer) {
			var container = node.parentNode;
			if (container && container !== resizer.parentNode) {
				container.insertBefore(resizer, container.firstChild);
			}

			// The container size might have changed, let's reset the resizer state.
			resizer._reset();
		}
	});
}

function removeResizeListener(node) {
	var expando = node[EXPANDO_KEY] || {};
	var resizer = expando.resizer;

	delete expando.resizer;
	unwatchForRender(node);

	if (resizer && resizer.parentNode) {
		resizer.parentNode.removeChild(resizer);
	}
}

function injectCSS(platform, css) {
	// http://stackoverflow.com/q/3922139
	var style = platform._style || document.createElement('style');
	if (!platform._style) {
		platform._style = style;
		css = '/* Chart.js */\n' + css;
		style.setAttribute('type', 'text/css');
		document.getElementsByTagName('head')[0].appendChild(style);
	}

	style.appendChild(document.createTextNode(css));
}

module.exports = {
	/**
	 * This property holds whether this platform is enabled for the current environment.
	 * Currently used by platform.js to select the proper implementation.
	 * @private
	 */
	_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

	initialize: function() {
		var keyframes = 'from{opacity:0.99}to{opacity:1}';

		injectCSS(this,
			// DOM rendering detection
			// https://davidwalsh.name/detect-node-insertion
			'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
			'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
			'.' + CSS_RENDER_MONITOR + '{' +
				'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
				'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
			'}'
		);
	},

	acquireContext: function(item, config) {
		if (typeof item === 'string') {
			item = document.getElementById(item);
		} else if (item.length) {
			// Support for array based queries (such as jQuery)
			item = item[0];
		}

		if (item && item.canvas) {
			// Support for any object associated to a canvas (including a context2d)
			item = item.canvas;
		}

		// To prevent canvas fingerprinting, some add-ons undefine the getContext
		// method, for example: https://github.com/kkapsner/CanvasBlocker
		// https://github.com/chartjs/Chart.js/issues/2807
		var context = item && item.getContext && item.getContext('2d');

		// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
		// inside an iframe or when running in a protected environment. We could guess the
		// types from their toString() value but let's keep things flexible and assume it's
		// a sufficient condition if the item has a context2D which has item as `canvas`.
		// https://github.com/chartjs/Chart.js/issues/3887
		// https://github.com/chartjs/Chart.js/issues/4102
		// https://github.com/chartjs/Chart.js/issues/4152
		if (context && context.canvas === item) {
			initCanvas(item, config);
			return context;
		}

		return null;
	},

	releaseContext: function(context) {
		var canvas = context.canvas;
		if (!canvas[EXPANDO_KEY]) {
			return;
		}

		var initial = canvas[EXPANDO_KEY].initial;
		['height', 'width'].forEach(function(prop) {
			var value = initial[prop];
			if (helpers.isNullOrUndef(value)) {
				canvas.removeAttribute(prop);
			} else {
				canvas.setAttribute(prop, value);
			}
		});

		helpers.each(initial.style || {}, function(value, key) {
			canvas.style[key] = value;
		});

		// The canvas render size might have been changed (and thus the state stack discarded),
		// we can't use save() and restore() to restore the initial state. So make sure that at
		// least the canvas context is reset to the default state by setting the canvas width.
		// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
		canvas.width = canvas.width;

		delete canvas[EXPANDO_KEY];
	},

	addEventListener: function(chart, type, listener) {
		var canvas = chart.canvas;
		if (type === 'resize') {
			// Note: the resize event is not supported on all browsers.
			addResizeListener(canvas, listener, chart);
			return;
		}

		var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
		var proxies = expando.proxies || (expando.proxies = {});
		var proxy = proxies[chart.id + '_' + type] = function(event) {
			listener(fromNativeEvent(event, chart));
		};

		addEventListener(canvas, type, proxy);
	},

	removeEventListener: function(chart, type, listener) {
		var canvas = chart.canvas;
		if (type === 'resize') {
			// Note: the resize event is not supported on all browsers.
			removeResizeListener(canvas, listener);
			return;
		}

		var expando = listener[EXPANDO_KEY] || {};
		var proxies = expando.proxies || {};
		var proxy = proxies[chart.id + '_' + type];
		if (!proxy) {
			return;
		}

		removeEventListener(canvas, type, proxy);
	}
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use EventTarget.addEventListener instead.
 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * @function Chart.helpers.addEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.addEvent = addEventListener;

/**
 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
 * @function Chart.helpers.removeEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.removeEvent = removeEventListener;

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/platforms/platform.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');
var basic = require('./platform.basic');
var dom = require('./platform.dom');

// @TODO Make possible to select another platform at build time.
var implementation = dom._enabled ? dom : basic;

/**
 * @namespace Chart.platform
 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
 * @since 2.4.0
 */
module.exports = helpers.extend({
	/**
	 * @since 2.7.0
	 */
	initialize: function() {},

	/**
	 * Called at chart construction time, returns a context2d instance implementing
	 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
	 * @param {*} item - The native item from which to acquire context (platform specific)
	 * @param {Object} options - The chart options
	 * @returns {CanvasRenderingContext2D} context2d instance
	 */
	acquireContext: function() {},

	/**
	 * Called at chart destruction time, releases any resources associated to the context
	 * previously returned by the acquireContext() method.
	 * @param {CanvasRenderingContext2D} context - The context2d instance
	 * @returns {Boolean} true if the method succeeded, else false
	 */
	releaseContext: function() {},

	/**
	 * Registers the specified listener on the given chart.
	 * @param {Chart} chart - Chart from which to listen for event
	 * @param {String} type - The ({@link IEvent}) type to listen for
	 * @param {Function} listener - Receives a notification (an object that implements
	 * the {@link IEvent} interface) when an event of the specified type occurs.
	 */
	addEventListener: function() {},

	/**
	 * Removes the specified listener previously registered with addEventListener.
	 * @param {Chart} chart -Chart from which to remove the listener
	 * @param {String} type - The ({@link IEvent}) type to remove
	 * @param {Function} listener - The listener function to remove from the event target.
	 */
	removeEventListener: function() {}

}, implementation);

/**
 * @interface IPlatform
 * Allows abstracting platform dependencies away from the chart
 * @borrows Chart.platform.acquireContext as acquireContext
 * @borrows Chart.platform.releaseContext as releaseContext
 * @borrows Chart.platform.addEventListener as addEventListener
 * @borrows Chart.platform.removeEventListener as removeEventListener
 */

/**
 * @interface IEvent
 * @prop {String} type - The event type name, possible values are:
 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
 */

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js","./platform.basic":"../node_modules/chart.js/src/platforms/platform.basic.js","./platform.dom":"../node_modules/chart.js/src/platforms/platform.dom.js"}],"../node_modules/chart.js/src/core/core.plugins.js":[function(require,module,exports) {
'use strict';

var defaults = require('./core.defaults');
var helpers = require('../helpers/index');

defaults._set('global', {
	plugins: {}
});

/**
 * The plugin service singleton
 * @namespace Chart.plugins
 * @since 2.1.0
 */
module.exports = {
	/**
	 * Globally registered plugins.
	 * @private
	 */
	_plugins: [],

	/**
	 * This identifier is used to invalidate the descriptors cache attached to each chart
	 * when a global plugin is registered or unregistered. In this case, the cache ID is
	 * incremented and descriptors are regenerated during following API calls.
	 * @private
	 */
	_cacheId: 0,

	/**
	 * Registers the given plugin(s) if not already registered.
	 * @param {Array|Object} plugins plugin instance(s).
	 */
	register: function(plugins) {
		var p = this._plugins;
		([]).concat(plugins).forEach(function(plugin) {
			if (p.indexOf(plugin) === -1) {
				p.push(plugin);
			}
		});

		this._cacheId++;
	},

	/**
	 * Unregisters the given plugin(s) only if registered.
	 * @param {Array|Object} plugins plugin instance(s).
	 */
	unregister: function(plugins) {
		var p = this._plugins;
		([]).concat(plugins).forEach(function(plugin) {
			var idx = p.indexOf(plugin);
			if (idx !== -1) {
				p.splice(idx, 1);
			}
		});

		this._cacheId++;
	},

	/**
	 * Remove all registered plugins.
	 * @since 2.1.5
	 */
	clear: function() {
		this._plugins = [];
		this._cacheId++;
	},

	/**
	 * Returns the number of registered plugins?
	 * @returns {Number}
	 * @since 2.1.5
	 */
	count: function() {
		return this._plugins.length;
	},

	/**
	 * Returns all registered plugin instances.
	 * @returns {Array} array of plugin objects.
	 * @since 2.1.5
	 */
	getAll: function() {
		return this._plugins;
	},

	/**
	 * Calls enabled plugins for `chart` on the specified hook and with the given args.
	 * This method immediately returns as soon as a plugin explicitly returns false. The
	 * returned value can be used, for instance, to interrupt the current action.
	 * @param {Object} chart - The chart instance for which plugins should be called.
	 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
	 * @param {Array} [args] - Extra arguments to apply to the hook call.
	 * @returns {Boolean} false if any of the plugins return false, else returns true.
	 */
	notify: function(chart, hook, args) {
		var descriptors = this.descriptors(chart);
		var ilen = descriptors.length;
		var i, descriptor, plugin, params, method;

		for (i = 0; i < ilen; ++i) {
			descriptor = descriptors[i];
			plugin = descriptor.plugin;
			method = plugin[hook];
			if (typeof method === 'function') {
				params = [chart].concat(args || []);
				params.push(descriptor.options);
				if (method.apply(plugin, params) === false) {
					return false;
				}
			}
		}

		return true;
	},

	/**
	 * Returns descriptors of enabled plugins for the given chart.
	 * @returns {Array} [{ plugin, options }]
	 * @private
	 */
	descriptors: function(chart) {
		var cache = chart.$plugins || (chart.$plugins = {});
		if (cache.id === this._cacheId) {
			return cache.descriptors;
		}

		var plugins = [];
		var descriptors = [];
		var config = (chart && chart.config) || {};
		var options = (config.options && config.options.plugins) || {};

		this._plugins.concat(config.plugins || []).forEach(function(plugin) {
			var idx = plugins.indexOf(plugin);
			if (idx !== -1) {
				return;
			}

			var id = plugin.id;
			var opts = options[id];
			if (opts === false) {
				return;
			}

			if (opts === true) {
				opts = helpers.clone(defaults.global.plugins[id]);
			}

			plugins.push(plugin);
			descriptors.push({
				plugin: plugin,
				options: opts || {}
			});
		});

		cache.descriptors = descriptors;
		cache.id = this._cacheId;
		return descriptors;
	},

	/**
	 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
	 * but in some cases, this reference can be changed by the user when updating options.
	 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
	 * @private
	 */
	_invalidate: function(chart) {
		delete chart.$plugins;
	}
};

/**
 * Plugin extension hooks.
 * @interface IPlugin
 * @since 2.1.0
 */
/**
 * @method IPlugin#beforeInit
 * @desc Called before initializing `chart`.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#afterInit
 * @desc Called after `chart` has been initialized and before the first update.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeUpdate
 * @desc Called before updating `chart`. If any plugin returns `false`, the update
 * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart update.
 */
/**
 * @method IPlugin#afterUpdate
 * @desc Called after `chart` has been updated and before rendering. Note that this
 * hook will not be called if the chart update has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeDatasetsUpdate
 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
 * the datasets update is cancelled until another `update` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} false to cancel the datasets update.
 * @since version 2.1.5
*/
/**
 * @method IPlugin#afterDatasetsUpdate
 * @desc Called after the `chart` datasets have been updated. Note that this hook
 * will not be called if the datasets update has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @since version 2.1.5
 */
/**
 * @method IPlugin#beforeDatasetUpdate
 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
 * returns `false`, the datasets update is cancelled until another `update` is triggered.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart datasets drawing.
 */
/**
 * @method IPlugin#afterDatasetUpdate
 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
 * that this hook will not be called if the datasets update has been previously cancelled.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeLayout
 * @desc Called before laying out `chart`. If any plugin returns `false`,
 * the layout update is cancelled until another `update` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart layout.
 */
/**
 * @method IPlugin#afterLayout
 * @desc Called after the `chart` has been layed out. Note that this hook will not
 * be called if the layout update has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeRender
 * @desc Called before rendering `chart`. If any plugin returns `false`,
 * the rendering is cancelled until another `render` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart rendering.
 */
/**
 * @method IPlugin#afterRender
 * @desc Called after the `chart` has been fully rendered (and animation completed). Note
 * that this hook will not be called if the rendering has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeDraw
 * @desc Called before drawing `chart` at every animation frame specified by the given
 * easing value. If any plugin returns `false`, the frame drawing is cancelled until
 * another `render` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart drawing.
 */
/**
 * @method IPlugin#afterDraw
 * @desc Called after the `chart` has been drawn for the specific easing value. Note
 * that this hook will not be called if the drawing has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeDatasetsDraw
 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
 * the datasets drawing is cancelled until another `render` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart datasets drawing.
 */
/**
 * @method IPlugin#afterDatasetsDraw
 * @desc Called after the `chart` datasets have been drawn. Note that this hook
 * will not be called if the datasets drawing has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeDatasetDraw
 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
 * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
 * is cancelled until another `render` is triggered.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart datasets drawing.
 */
/**
 * @method IPlugin#afterDatasetDraw
 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
 * (datasets are drawn in the reverse order). Note that this hook will not be called
 * if the datasets drawing has been previously cancelled.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeTooltipDraw
 * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
 * the tooltip drawing is cancelled until another `render` is triggered.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Object} args.tooltip - The tooltip.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart tooltip drawing.
 */
/**
 * @method IPlugin#afterTooltipDraw
 * @desc Called after drawing the `tooltip`. Note that this hook will not
 * be called if the tooltip drawing has been previously cancelled.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Object} args.tooltip - The tooltip.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#beforeEvent
 * @desc Called before processing the specified `event`. If any plugin returns `false`,
 * the event will be discarded.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {IEvent} event - The event object.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#afterEvent
 * @desc Called after the `event` has been consumed. Note that this hook
 * will not be called if the `event` has been previously discarded.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {IEvent} event - The event object.
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#resize
 * @desc Called after the chart as been resized.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
 * @param {Object} options - The plugin options.
 */
/**
 * @method IPlugin#destroy
 * @desc Called after the chart as been destroyed.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

},{"./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/core/core.ticks.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');

/**
 * Namespace to hold static tick generation functions
 * @namespace Chart.Ticks
 */
module.exports = {
	/**
	 * Namespace to hold formatters for different types of ticks
	 * @namespace Chart.Ticks.formatters
	 */
	formatters: {
		/**
		 * Formatter for value labels
		 * @method Chart.Ticks.formatters.values
		 * @param value the value to display
		 * @return {String|Array} the label to display
		 */
		values: function(value) {
			return helpers.isArray(value) ? value : '' + value;
		},

		/**
		 * Formatter for linear numeric ticks
		 * @method Chart.Ticks.formatters.linear
		 * @param tickValue {Number} the value to be formatted
		 * @param index {Number} the position of the tickValue parameter in the ticks array
		 * @param ticks {Array<Number>} the list of ticks being converted
		 * @return {String} string representation of the tickValue parameter
		 */
		linear: function(tickValue, index, ticks) {
			// If we have lots of ticks, don't use the ones
			var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

			// If we have a number like 2.5 as the delta, figure out how many decimal places we need
			if (Math.abs(delta) > 1) {
				if (tickValue !== Math.floor(tickValue)) {
					// not an integer
					delta = tickValue - Math.floor(tickValue);
				}
			}

			var logDelta = helpers.log10(Math.abs(delta));
			var tickString = '';

			if (tickValue !== 0) {
				var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
				if (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation
					var logTick = helpers.log10(Math.abs(tickValue));
					tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
				} else {
					var numDecimal = -1 * Math.floor(logDelta);
					numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString = tickValue.toFixed(numDecimal);
				}
			} else {
				tickString = '0'; // never show decimal places for 0
			}

			return tickString;
		},

		logarithmic: function(tickValue, index, ticks) {
			var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

			if (tickValue === 0) {
				return '0';
			} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
				return tickValue.toExponential();
			}
			return '';
		}
	}
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/core/core.scale.js":[function(require,module,exports) {
'use strict';

var defaults = require('./core.defaults');
var Element = require('./core.element');
var helpers = require('../helpers/index');
var Ticks = require('./core.ticks');

defaults._set('scale', {
	display: true,
	position: 'left',
	offset: false,

	// grid line settings
	gridLines: {
		display: true,
		color: 'rgba(0, 0, 0, 0.1)',
		lineWidth: 1,
		drawBorder: true,
		drawOnChartArea: true,
		drawTicks: true,
		tickMarkLength: 10,
		zeroLineWidth: 1,
		zeroLineColor: 'rgba(0,0,0,0.25)',
		zeroLineBorderDash: [],
		zeroLineBorderDashOffset: 0.0,
		offsetGridLines: false,
		borderDash: [],
		borderDashOffset: 0.0
	},

	// scale label
	scaleLabel: {
		// display property
		display: false,

		// actual label
		labelString: '',

		// line height
		lineHeight: 1.2,

		// top/bottom padding
		padding: {
			top: 4,
			bottom: 4
		}
	},

	// label settings
	ticks: {
		beginAtZero: false,
		minRotation: 0,
		maxRotation: 50,
		mirror: false,
		padding: 0,
		reverse: false,
		display: true,
		autoSkip: true,
		autoSkipPadding: 0,
		labelOffset: 0,
		// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
		callback: Ticks.formatters.values,
		minor: {},
		major: {}
	}
});

function labelsFromTicks(ticks) {
	var labels = [];
	var i, ilen;

	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
		labels.push(ticks[i].label);
	}

	return labels;
}

function getLineValue(scale, index, offsetGridLines) {
	var lineValue = scale.getPixelForTick(index);

	if (offsetGridLines) {
		if (index === 0) {
			lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
		} else {
			lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
		}
	}
	return lineValue;
}

function computeTextSize(context, tick, font) {
	return helpers.isArray(tick) ?
		helpers.longestText(context, font, tick) :
		context.measureText(tick).width;
}

function parseFontOptions(options) {
	var valueOrDefault = helpers.valueOrDefault;
	var globalDefaults = defaults.global;
	var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
	var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
	var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

	return {
		size: size,
		style: style,
		family: family,
		font: helpers.fontString(size, style, family)
	};
}

function parseLineHeight(options) {
	return helpers.options.toLineHeight(
		helpers.valueOrDefault(options.lineHeight, 1.2),
		helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
}

module.exports = Element.extend({
	/**
	 * Get the padding needed for the scale
	 * @method getPadding
	 * @private
	 * @returns {Padding} the necessary padding
	 */
	getPadding: function() {
		var me = this;
		return {
			left: me.paddingLeft || 0,
			top: me.paddingTop || 0,
			right: me.paddingRight || 0,
			bottom: me.paddingBottom || 0
		};
	},

	/**
	 * Returns the scale tick objects ({label, major})
	 * @since 2.7
	 */
	getTicks: function() {
		return this._ticks;
	},

	// These methods are ordered by lifecyle. Utilities then follow.
	// Any function defined here is inherited by all scale types.
	// Any function can be extended by the scale type

	mergeTicksOptions: function() {
		var ticks = this.options.ticks;
		if (ticks.minor === false) {
			ticks.minor = {
				display: false
			};
		}
		if (ticks.major === false) {
			ticks.major = {
				display: false
			};
		}
		for (var key in ticks) {
			if (key !== 'major' && key !== 'minor') {
				if (typeof ticks.minor[key] === 'undefined') {
					ticks.minor[key] = ticks[key];
				}
				if (typeof ticks.major[key] === 'undefined') {
					ticks.major[key] = ticks[key];
				}
			}
		}
	},
	beforeUpdate: function() {
		helpers.callback(this.options.beforeUpdate, [this]);
	},

	update: function(maxWidth, maxHeight, margins) {
		var me = this;
		var i, ilen, labels, label, ticks, tick;

		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
		me.beforeUpdate();

		// Absorb the master measurements
		me.maxWidth = maxWidth;
		me.maxHeight = maxHeight;
		me.margins = helpers.extend({
			left: 0,
			right: 0,
			top: 0,
			bottom: 0
		}, margins);
		me.longestTextCache = me.longestTextCache || {};

		// Dimensions
		me.beforeSetDimensions();
		me.setDimensions();
		me.afterSetDimensions();

		// Data min/max
		me.beforeDataLimits();
		me.determineDataLimits();
		me.afterDataLimits();

		// Ticks - `this.ticks` is now DEPRECATED!
		// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
		// and must not be accessed directly from outside this class. `this.ticks` being
		// around for long time and not marked as private, we can't change its structure
		// without unexpected breaking changes. If you need to access the scale ticks,
		// use scale.getTicks() instead.

		me.beforeBuildTicks();

		// New implementations should return an array of objects but for BACKWARD COMPAT,
		// we still support no return (`this.ticks` internally set by calling this method).
		ticks = me.buildTicks() || [];

		me.afterBuildTicks();

		me.beforeTickToLabelConversion();

		// New implementations should return the formatted tick labels but for BACKWARD
		// COMPAT, we still support no return (`this.ticks` internally changed by calling
		// this method and supposed to contain only string values).
		labels = me.convertTicksToLabels(ticks) || me.ticks;

		me.afterTickToLabelConversion();

		me.ticks = labels;   // BACKWARD COMPATIBILITY

		// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

		// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
		for (i = 0, ilen = labels.length; i < ilen; ++i) {
			label = labels[i];
			tick = ticks[i];
			if (!tick) {
				ticks.push(tick = {
					label: label,
					major: false
				});
			} else {
				tick.label = label;
			}
		}

		me._ticks = ticks;

		// Tick Rotation
		me.beforeCalculateTickRotation();
		me.calculateTickRotation();
		me.afterCalculateTickRotation();
		// Fit
		me.beforeFit();
		me.fit();
		me.afterFit();
		//
		me.afterUpdate();

		return me.minSize;

	},
	afterUpdate: function() {
		helpers.callback(this.options.afterUpdate, [this]);
	},

	//

	beforeSetDimensions: function() {
		helpers.callback(this.options.beforeSetDimensions, [this]);
	},
	setDimensions: function() {
		var me = this;
		// Set the unconstrained dimension before label rotation
		if (me.isHorizontal()) {
			// Reset position before calculating rotation
			me.width = me.maxWidth;
			me.left = 0;
			me.right = me.width;
		} else {
			me.height = me.maxHeight;

			// Reset position before calculating rotation
			me.top = 0;
			me.bottom = me.height;
		}

		// Reset padding
		me.paddingLeft = 0;
		me.paddingTop = 0;
		me.paddingRight = 0;
		me.paddingBottom = 0;
	},
	afterSetDimensions: function() {
		helpers.callback(this.options.afterSetDimensions, [this]);
	},

	// Data limits
	beforeDataLimits: function() {
		helpers.callback(this.options.beforeDataLimits, [this]);
	},
	determineDataLimits: helpers.noop,
	afterDataLimits: function() {
		helpers.callback(this.options.afterDataLimits, [this]);
	},

	//
	beforeBuildTicks: function() {
		helpers.callback(this.options.beforeBuildTicks, [this]);
	},
	buildTicks: helpers.noop,
	afterBuildTicks: function() {
		helpers.callback(this.options.afterBuildTicks, [this]);
	},

	beforeTickToLabelConversion: function() {
		helpers.callback(this.options.beforeTickToLabelConversion, [this]);
	},
	convertTicksToLabels: function() {
		var me = this;
		// Convert ticks to strings
		var tickOpts = me.options.ticks;
		me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
	},
	afterTickToLabelConversion: function() {
		helpers.callback(this.options.afterTickToLabelConversion, [this]);
	},

	//

	beforeCalculateTickRotation: function() {
		helpers.callback(this.options.beforeCalculateTickRotation, [this]);
	},
	calculateTickRotation: function() {
		var me = this;
		var context = me.ctx;
		var tickOpts = me.options.ticks;
		var labels = labelsFromTicks(me._ticks);

		// Get the width of each grid by calculating the difference
		// between x offsets between 0 and 1.
		var tickFont = parseFontOptions(tickOpts);
		context.font = tickFont.font;

		var labelRotation = tickOpts.minRotation || 0;

		if (labels.length && me.options.display && me.isHorizontal()) {
			var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
			var labelWidth = originalLabelWidth;
			var cosRotation, sinRotation;

			// Allow 3 pixels x2 padding either side for label readability
			var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

			// Max label rotation can be set or default to 90 - also act as a loop counter
			while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
				var angleRadians = helpers.toRadians(labelRotation);
				cosRotation = Math.cos(angleRadians);
				sinRotation = Math.sin(angleRadians);

				if (sinRotation * originalLabelWidth > me.maxHeight) {
					// go back one step
					labelRotation--;
					break;
				}

				labelRotation++;
				labelWidth = cosRotation * originalLabelWidth;
			}
		}

		me.labelRotation = labelRotation;
	},
	afterCalculateTickRotation: function() {
		helpers.callback(this.options.afterCalculateTickRotation, [this]);
	},

	//

	beforeFit: function() {
		helpers.callback(this.options.beforeFit, [this]);
	},
	fit: function() {
		var me = this;
		// Reset
		var minSize = me.minSize = {
			width: 0,
			height: 0
		};

		var labels = labelsFromTicks(me._ticks);

		var opts = me.options;
		var tickOpts = opts.ticks;
		var scaleLabelOpts = opts.scaleLabel;
		var gridLineOpts = opts.gridLines;
		var display = opts.display;
		var isHorizontal = me.isHorizontal();

		var tickFont = parseFontOptions(tickOpts);
		var tickMarkLength = opts.gridLines.tickMarkLength;

		// Width
		if (isHorizontal) {
			// subtract the margins to line up with the chartArea if we are a full width scale
			minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
		} else {
			minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
		}

		// height
		if (isHorizontal) {
			minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
		} else {
			minSize.height = me.maxHeight; // fill all the height
		}

		// Are we showing a title for the scale?
		if (scaleLabelOpts.display && display) {
			var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
			var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
			var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

			if (isHorizontal) {
				minSize.height += deltaHeight;
			} else {
				minSize.width += deltaHeight;
			}
		}

		// Don't bother fitting the ticks if we are not showing them
		if (tickOpts.display && display) {
			var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
			var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
			var lineSpace = tickFont.size * 0.5;
			var tickPadding = me.options.ticks.padding;

			if (isHorizontal) {
				// A horizontal axis is more constrained by the height.
				me.longestLabelWidth = largestTextWidth;

				var angleRadians = helpers.toRadians(me.labelRotation);
				var cosRotation = Math.cos(angleRadians);
				var sinRotation = Math.sin(angleRadians);

				// TODO - improve this calculation
				var labelHeight = (sinRotation * largestTextWidth)
					+ (tickFont.size * tallestLabelHeightInLines)
					+ (lineSpace * (tallestLabelHeightInLines - 1))
					+ lineSpace; // padding

				minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

				me.ctx.font = tickFont.font;
				var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
				var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

				// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
				// which means that the right padding is dominated by the font height
				if (me.labelRotation !== 0) {
					me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
					me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
				} else {
					me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
					me.paddingRight = lastLabelWidth / 2 + 3;
				}
			} else {
				// A vertical axis is more constrained by the width. Labels are the
				// dominant factor here, so get that length first and account for padding
				if (tickOpts.mirror) {
					largestTextWidth = 0;
				} else {
					// use lineSpace for consistency with horizontal axis
					// tickPadding is not implemented for horizontal
					largestTextWidth += tickPadding + lineSpace;
				}

				minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

				me.paddingTop = tickFont.size / 2;
				me.paddingBottom = tickFont.size / 2;
			}
		}

		me.handleMargins();

		me.width = minSize.width;
		me.height = minSize.height;
	},

	/**
	 * Handle margins and padding interactions
	 * @private
	 */
	handleMargins: function() {
		var me = this;
		if (me.margins) {
			me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
			me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
			me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
			me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
		}
	},

	afterFit: function() {
		helpers.callback(this.options.afterFit, [this]);
	},

	// Shared Methods
	isHorizontal: function() {
		return this.options.position === 'top' || this.options.position === 'bottom';
	},
	isFullWidth: function() {
		return (this.options.fullWidth);
	},

	// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
	getRightValue: function(rawValue) {
		// Null and undefined values first
		if (helpers.isNullOrUndef(rawValue)) {
			return NaN;
		}
		// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
		if (typeof rawValue === 'number' && !isFinite(rawValue)) {
			return NaN;
		}
		// If it is in fact an object, dive in one more level
		if (rawValue) {
			if (this.isHorizontal()) {
				if (rawValue.x !== undefined) {
					return this.getRightValue(rawValue.x);
				}
			} else if (rawValue.y !== undefined) {
				return this.getRightValue(rawValue.y);
			}
		}

		// Value is good, return it
		return rawValue;
	},

	/**
	 * Used to get the value to display in the tooltip for the data at the given index
	 * @param index
	 * @param datasetIndex
	 */
	getLabelForIndex: helpers.noop,

	/**
	 * Returns the location of the given data point. Value can either be an index or a numerical value
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 * @param value
	 * @param index
	 * @param datasetIndex
	 */
	getPixelForValue: helpers.noop,

	/**
	 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 * @param pixel
	 */
	getValueForPixel: helpers.noop,

	/**
	 * Returns the location of the tick at the given index
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 */
	getPixelForTick: function(index) {
		var me = this;
		var offset = me.options.offset;
		if (me.isHorizontal()) {
			var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
			var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
			var pixel = (tickWidth * index) + me.paddingLeft;

			if (offset) {
				pixel += tickWidth / 2;
			}

			var finalVal = me.left + Math.round(pixel);
			finalVal += me.isFullWidth() ? me.margins.left : 0;
			return finalVal;
		}
		var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
		return me.top + (index * (innerHeight / (me._ticks.length - 1)));
	},

	/**
	 * Utility for getting the pixel location of a percentage of scale
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 */
	getPixelForDecimal: function(decimal) {
		var me = this;
		if (me.isHorizontal()) {
			var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
			var valueOffset = (innerWidth * decimal) + me.paddingLeft;

			var finalVal = me.left + Math.round(valueOffset);
			finalVal += me.isFullWidth() ? me.margins.left : 0;
			return finalVal;
		}
		return me.top + (decimal * me.height);
	},

	/**
	 * Returns the pixel for the minimum chart value
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 */
	getBasePixel: function() {
		return this.getPixelForValue(this.getBaseValue());
	},

	getBaseValue: function() {
		var me = this;
		var min = me.min;
		var max = me.max;

		return me.beginAtZero ? 0 :
			min < 0 && max < 0 ? max :
			min > 0 && max > 0 ? min :
			0;
	},

	/**
	 * Returns a subset of ticks to be plotted to avoid overlapping labels.
	 * @private
	 */
	_autoSkip: function(ticks) {
		var skipRatio;
		var me = this;
		var isHorizontal = me.isHorizontal();
		var optionTicks = me.options.ticks.minor;
		var tickCount = ticks.length;
		var labelRotationRadians = helpers.toRadians(me.labelRotation);
		var cosRotation = Math.cos(labelRotationRadians);
		var longestRotatedLabel = me.longestLabelWidth * cosRotation;
		var result = [];
		var i, tick, shouldSkip;

		// figure out the maximum number of gridlines to show
		var maxTicks;
		if (optionTicks.maxTicksLimit) {
			maxTicks = optionTicks.maxTicksLimit;
		}

		if (isHorizontal) {
			skipRatio = false;

			if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
				skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
			}

			// if they defined a max number of optionTicks,
			// increase skipRatio until that number is met
			if (maxTicks && tickCount > maxTicks) {
				skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
			}
		}

		for (i = 0; i < tickCount; i++) {
			tick = ticks[i];

			// Since we always show the last tick,we need may need to hide the last shown one before
			shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
			if (shouldSkip && i !== tickCount - 1) {
				// leave tick in place but make sure it's not displayed (#4635)
				delete tick.label;
			}
			result.push(tick);
		}
		return result;
	},

	// Actually draw the scale on the canvas
	// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
	draw: function(chartArea) {
		var me = this;
		var options = me.options;
		if (!options.display) {
			return;
		}

		var context = me.ctx;
		var globalDefaults = defaults.global;
		var optionTicks = options.ticks.minor;
		var optionMajorTicks = options.ticks.major || optionTicks;
		var gridLines = options.gridLines;
		var scaleLabel = options.scaleLabel;

		var isRotated = me.labelRotation !== 0;
		var isHorizontal = me.isHorizontal();

		var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
		var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
		var tickFont = parseFontOptions(optionTicks);
		var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
		var majorTickFont = parseFontOptions(optionMajorTicks);

		var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

		var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
		var scaleLabelFont = parseFontOptions(scaleLabel);
		var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
		var labelRotationRadians = helpers.toRadians(me.labelRotation);

		var itemsToDraw = [];

		var axisWidth = me.options.gridLines.lineWidth;
		var xTickStart = options.position === 'right' ? me.left : me.right - axisWidth - tl;
		var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
		var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;
		var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;

		helpers.each(ticks, function(tick, index) {
			// autoskipper skipped this tick (#4635)
			if (helpers.isNullOrUndef(tick.label)) {
				return;
			}

			var label = tick.label;
			var lineWidth, lineColor, borderDash, borderDashOffset;
			if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
				// Draw the first index specially
				lineWidth = gridLines.zeroLineWidth;
				lineColor = gridLines.zeroLineColor;
				borderDash = gridLines.zeroLineBorderDash;
				borderDashOffset = gridLines.zeroLineBorderDashOffset;
			} else {
				lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
				lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
				borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
				borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
			}

			// Common properties
			var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
			var textAlign = 'middle';
			var textBaseline = 'middle';
			var tickPadding = optionTicks.padding;

			if (isHorizontal) {
				var labelYOffset = tl + tickPadding;

				if (options.position === 'bottom') {
					// bottom
					textBaseline = !isRotated ? 'top' : 'middle';
					textAlign = !isRotated ? 'center' : 'right';
					labelY = me.top + labelYOffset;
				} else {
					// top
					textBaseline = !isRotated ? 'bottom' : 'middle';
					textAlign = !isRotated ? 'center' : 'left';
					labelY = me.bottom - labelYOffset;
				}

				var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
				if (xLineValue < me.left) {
					lineColor = 'rgba(0,0,0,0)';
				}
				xLineValue += helpers.aliasPixel(lineWidth);

				labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

				tx1 = tx2 = x1 = x2 = xLineValue;
				ty1 = yTickStart;
				ty2 = yTickEnd;
				y1 = chartArea.top;
				y2 = chartArea.bottom + axisWidth;
			} else {
				var isLeft = options.position === 'left';
				var labelXOffset;

				if (optionTicks.mirror) {
					textAlign = isLeft ? 'left' : 'right';
					labelXOffset = tickPadding;
				} else {
					textAlign = isLeft ? 'right' : 'left';
					labelXOffset = tl + tickPadding;
				}

				labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

				var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
				if (yLineValue < me.top) {
					lineColor = 'rgba(0,0,0,0)';
				}
				yLineValue += helpers.aliasPixel(lineWidth);

				labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

				tx1 = xTickStart;
				tx2 = xTickEnd;
				x1 = chartArea.left;
				x2 = chartArea.right + axisWidth;
				ty1 = ty2 = y1 = y2 = yLineValue;
			}

			itemsToDraw.push({
				tx1: tx1,
				ty1: ty1,
				tx2: tx2,
				ty2: ty2,
				x1: x1,
				y1: y1,
				x2: x2,
				y2: y2,
				labelX: labelX,
				labelY: labelY,
				glWidth: lineWidth,
				glColor: lineColor,
				glBorderDash: borderDash,
				glBorderDashOffset: borderDashOffset,
				rotation: -1 * labelRotationRadians,
				label: label,
				major: tick.major,
				textBaseline: textBaseline,
				textAlign: textAlign
			});
		});

		// Draw all of the tick labels, tick marks, and grid lines at the correct places
		helpers.each(itemsToDraw, function(itemToDraw) {
			if (gridLines.display) {
				context.save();
				context.lineWidth = itemToDraw.glWidth;
				context.strokeStyle = itemToDraw.glColor;
				if (context.setLineDash) {
					context.setLineDash(itemToDraw.glBorderDash);
					context.lineDashOffset = itemToDraw.glBorderDashOffset;
				}

				context.beginPath();

				if (gridLines.drawTicks) {
					context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
					context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
				}

				if (gridLines.drawOnChartArea) {
					context.moveTo(itemToDraw.x1, itemToDraw.y1);
					context.lineTo(itemToDraw.x2, itemToDraw.y2);
				}

				context.stroke();
				context.restore();
			}

			if (optionTicks.display) {
				// Make sure we draw text in the correct color and font
				context.save();
				context.translate(itemToDraw.labelX, itemToDraw.labelY);
				context.rotate(itemToDraw.rotation);
				context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
				context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
				context.textBaseline = itemToDraw.textBaseline;
				context.textAlign = itemToDraw.textAlign;

				var label = itemToDraw.label;
				if (helpers.isArray(label)) {
					var lineCount = label.length;
					var lineHeight = tickFont.size * 1.5;
					var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;

					for (var i = 0; i < lineCount; ++i) {
						// We just make sure the multiline element is a string here..
						context.fillText('' + label[i], 0, y);
						// apply same lineSpacing as calculated @ L#320
						y += lineHeight;
					}
				} else {
					context.fillText(label, 0, 0);
				}
				context.restore();
			}
		});

		if (scaleLabel.display) {
			// Draw the scale label
			var scaleLabelX;
			var scaleLabelY;
			var rotation = 0;
			var halfLineHeight = parseLineHeight(scaleLabel) / 2;

			if (isHorizontal) {
				scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
				scaleLabelY = options.position === 'bottom'
					? me.bottom - halfLineHeight - scaleLabelPadding.bottom
					: me.top + halfLineHeight + scaleLabelPadding.top;
			} else {
				var isLeft = options.position === 'left';
				scaleLabelX = isLeft
					? me.left + halfLineHeight + scaleLabelPadding.top
					: me.right - halfLineHeight - scaleLabelPadding.top;
				scaleLabelY = me.top + ((me.bottom - me.top) / 2);
				rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
			}

			context.save();
			context.translate(scaleLabelX, scaleLabelY);
			context.rotate(rotation);
			context.textAlign = 'center';
			context.textBaseline = 'middle';
			context.fillStyle = scaleLabelFontColor; // render in correct colour
			context.font = scaleLabelFont.font;
			context.fillText(scaleLabel.labelString, 0, 0);
			context.restore();
		}

		if (gridLines.drawBorder) {
			// Draw the line at the edge of the axis
			context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
			context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
			var x1 = me.left;
			var x2 = me.right + axisWidth;
			var y1 = me.top;
			var y2 = me.bottom + axisWidth;

			var aliasPixel = helpers.aliasPixel(context.lineWidth);
			if (isHorizontal) {
				y1 = y2 = options.position === 'top' ? me.bottom : me.top;
				y1 += aliasPixel;
				y2 += aliasPixel;
			} else {
				x1 = x2 = options.position === 'left' ? me.right : me.left;
				x1 += aliasPixel;
				x2 += aliasPixel;
			}

			context.beginPath();
			context.moveTo(x1, y1);
			context.lineTo(x2, y2);
			context.stroke();
		}
	}
});

},{"./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","./core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","./core.ticks":"../node_modules/chart.js/src/core/core.ticks.js"}],"../node_modules/chart.js/src/core/core.tooltip.js":[function(require,module,exports) {
'use strict';

var defaults = require('./core.defaults');
var Element = require('./core.element');
var helpers = require('../helpers/index');

defaults._set('global', {
	tooltips: {
		enabled: true,
		custom: null,
		mode: 'nearest',
		position: 'average',
		intersect: true,
		backgroundColor: 'rgba(0,0,0,0.8)',
		titleFontStyle: 'bold',
		titleSpacing: 2,
		titleMarginBottom: 6,
		titleFontColor: '#fff',
		titleAlign: 'left',
		bodySpacing: 2,
		bodyFontColor: '#fff',
		bodyAlign: 'left',
		footerFontStyle: 'bold',
		footerSpacing: 2,
		footerMarginTop: 6,
		footerFontColor: '#fff',
		footerAlign: 'left',
		yPadding: 6,
		xPadding: 6,
		caretPadding: 2,
		caretSize: 5,
		cornerRadius: 6,
		multiKeyBackground: '#fff',
		displayColors: true,
		borderColor: 'rgba(0,0,0,0)',
		borderWidth: 0,
		callbacks: {
			// Args are: (tooltipItems, data)
			beforeTitle: helpers.noop,
			title: function(tooltipItems, data) {
				// Pick first xLabel for now
				var title = '';
				var labels = data.labels;
				var labelCount = labels ? labels.length : 0;

				if (tooltipItems.length > 0) {
					var item = tooltipItems[0];

					if (item.xLabel) {
						title = item.xLabel;
					} else if (labelCount > 0 && item.index < labelCount) {
						title = labels[item.index];
					}
				}

				return title;
			},
			afterTitle: helpers.noop,

			// Args are: (tooltipItems, data)
			beforeBody: helpers.noop,

			// Args are: (tooltipItem, data)
			beforeLabel: helpers.noop,
			label: function(tooltipItem, data) {
				var label = data.datasets[tooltipItem.datasetIndex].label || '';

				if (label) {
					label += ': ';
				}
				label += tooltipItem.yLabel;
				return label;
			},
			labelColor: function(tooltipItem, chart) {
				var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
				var activeElement = meta.data[tooltipItem.index];
				var view = activeElement._view;
				return {
					borderColor: view.borderColor,
					backgroundColor: view.backgroundColor
				};
			},
			labelTextColor: function() {
				return this._options.bodyFontColor;
			},
			afterLabel: helpers.noop,

			// Args are: (tooltipItems, data)
			afterBody: helpers.noop,

			// Args are: (tooltipItems, data)
			beforeFooter: helpers.noop,
			footer: helpers.noop,
			afterFooter: helpers.noop
		}
	}
});

var positioners = {
	/**
	 * Average mode places the tooltip at the average position of the elements shown
	 * @function Chart.Tooltip.positioners.average
	 * @param elements {ChartElement[]} the elements being displayed in the tooltip
	 * @returns {Point} tooltip position
	 */
	average: function(elements) {
		if (!elements.length) {
			return false;
		}

		var i, len;
		var x = 0;
		var y = 0;
		var count = 0;

		for (i = 0, len = elements.length; i < len; ++i) {
			var el = elements[i];
			if (el && el.hasValue()) {
				var pos = el.tooltipPosition();
				x += pos.x;
				y += pos.y;
				++count;
			}
		}

		return {
			x: Math.round(x / count),
			y: Math.round(y / count)
		};
	},

	/**
	 * Gets the tooltip position nearest of the item nearest to the event position
	 * @function Chart.Tooltip.positioners.nearest
	 * @param elements {Chart.Element[]} the tooltip elements
	 * @param eventPosition {Point} the position of the event in canvas coordinates
	 * @returns {Point} the tooltip position
	 */
	nearest: function(elements, eventPosition) {
		var x = eventPosition.x;
		var y = eventPosition.y;
		var minDistance = Number.POSITIVE_INFINITY;
		var i, len, nearestElement;

		for (i = 0, len = elements.length; i < len; ++i) {
			var el = elements[i];
			if (el && el.hasValue()) {
				var center = el.getCenterPoint();
				var d = helpers.distanceBetweenPoints(eventPosition, center);

				if (d < minDistance) {
					minDistance = d;
					nearestElement = el;
				}
			}
		}

		if (nearestElement) {
			var tp = nearestElement.tooltipPosition();
			x = tp.x;
			y = tp.y;
		}

		return {
			x: x,
			y: y
		};
	}
};

/**
 * Helper method to merge the opacity into a color
 */
function mergeOpacity(colorString, opacity) {
	var color = helpers.color(colorString);
	return color.alpha(opacity * color.alpha()).rgbaString();
}

// Helper to push or concat based on if the 2nd parameter is an array or not
function pushOrConcat(base, toPush) {
	if (toPush) {
		if (helpers.isArray(toPush)) {
			// base = base.concat(toPush);
			Array.prototype.push.apply(base, toPush);
		} else {
			base.push(toPush);
		}
	}

	return base;
}

/**
 * Returns array of strings split by newline
 * @param {String} value - The value to split by newline.
 * @returns {Array} value if newline present - Returned from String split() method
 * @function
 */
function splitNewlines(str) {
	if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
		return str.split('\n');
	}
	return str;
}


// Private helper to create a tooltip item model
// @param element : the chart element (point, arc, bar) to create the tooltip item for
// @return : new tooltip item
function createTooltipItem(element) {
	var xScale = element._xScale;
	var yScale = element._yScale || element._scale; // handle radar || polarArea charts
	var index = element._index;
	var datasetIndex = element._datasetIndex;

	return {
		xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
		yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
		index: index,
		datasetIndex: datasetIndex,
		x: element._model.x,
		y: element._model.y
	};
}

/**
 * Helper to get the reset model for the tooltip
 * @param tooltipOpts {Object} the tooltip options
 */
function getBaseModel(tooltipOpts) {
	var globalDefaults = defaults.global;
	var valueOrDefault = helpers.valueOrDefault;

	return {
		// Positioning
		xPadding: tooltipOpts.xPadding,
		yPadding: tooltipOpts.yPadding,
		xAlign: tooltipOpts.xAlign,
		yAlign: tooltipOpts.yAlign,

		// Body
		bodyFontColor: tooltipOpts.bodyFontColor,
		_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
		_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
		_bodyAlign: tooltipOpts.bodyAlign,
		bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
		bodySpacing: tooltipOpts.bodySpacing,

		// Title
		titleFontColor: tooltipOpts.titleFontColor,
		_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
		_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
		titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
		_titleAlign: tooltipOpts.titleAlign,
		titleSpacing: tooltipOpts.titleSpacing,
		titleMarginBottom: tooltipOpts.titleMarginBottom,

		// Footer
		footerFontColor: tooltipOpts.footerFontColor,
		_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
		_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
		footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
		_footerAlign: tooltipOpts.footerAlign,
		footerSpacing: tooltipOpts.footerSpacing,
		footerMarginTop: tooltipOpts.footerMarginTop,

		// Appearance
		caretSize: tooltipOpts.caretSize,
		cornerRadius: tooltipOpts.cornerRadius,
		backgroundColor: tooltipOpts.backgroundColor,
		opacity: 0,
		legendColorBackground: tooltipOpts.multiKeyBackground,
		displayColors: tooltipOpts.displayColors,
		borderColor: tooltipOpts.borderColor,
		borderWidth: tooltipOpts.borderWidth
	};
}

/**
 * Get the size of the tooltip
 */
function getTooltipSize(tooltip, model) {
	var ctx = tooltip._chart.ctx;

	var height = model.yPadding * 2; // Tooltip Padding
	var width = 0;

	// Count of all lines in the body
	var body = model.body;
	var combinedBodyLength = body.reduce(function(count, bodyItem) {
		return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
	}, 0);
	combinedBodyLength += model.beforeBody.length + model.afterBody.length;

	var titleLineCount = model.title.length;
	var footerLineCount = model.footer.length;
	var titleFontSize = model.titleFontSize;
	var bodyFontSize = model.bodyFontSize;
	var footerFontSize = model.footerFontSize;

	height += titleLineCount * titleFontSize; // Title Lines
	height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
	height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
	height += combinedBodyLength * bodyFontSize; // Body Lines
	height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
	height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
	height += footerLineCount * (footerFontSize); // Footer Lines
	height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

	// Title width
	var widthPadding = 0;
	var maxLineWidth = function(line) {
		width = Math.max(width, ctx.measureText(line).width + widthPadding);
	};

	ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
	helpers.each(model.title, maxLineWidth);

	// Body width
	ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
	helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

	// Body lines may include some extra width due to the color box
	widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
	helpers.each(body, function(bodyItem) {
		helpers.each(bodyItem.before, maxLineWidth);
		helpers.each(bodyItem.lines, maxLineWidth);
		helpers.each(bodyItem.after, maxLineWidth);
	});

	// Reset back to 0
	widthPadding = 0;

	// Footer width
	ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
	helpers.each(model.footer, maxLineWidth);

	// Add padding
	width += 2 * model.xPadding;

	return {
		width: width,
		height: height
	};
}

/**
 * Helper to get the alignment of a tooltip given the size
 */
function determineAlignment(tooltip, size) {
	var model = tooltip._model;
	var chart = tooltip._chart;
	var chartArea = tooltip._chart.chartArea;
	var xAlign = 'center';
	var yAlign = 'center';

	if (model.y < size.height) {
		yAlign = 'top';
	} else if (model.y > (chart.height - size.height)) {
		yAlign = 'bottom';
	}

	var lf, rf; // functions to determine left, right alignment
	var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
	var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
	var midX = (chartArea.left + chartArea.right) / 2;
	var midY = (chartArea.top + chartArea.bottom) / 2;

	if (yAlign === 'center') {
		lf = function(x) {
			return x <= midX;
		};
		rf = function(x) {
			return x > midX;
		};
	} else {
		lf = function(x) {
			return x <= (size.width / 2);
		};
		rf = function(x) {
			return x >= (chart.width - (size.width / 2));
		};
	}

	olf = function(x) {
		return x + size.width + model.caretSize + model.caretPadding > chart.width;
	};
	orf = function(x) {
		return x - size.width - model.caretSize - model.caretPadding < 0;
	};
	yf = function(y) {
		return y <= midY ? 'top' : 'bottom';
	};

	if (lf(model.x)) {
		xAlign = 'left';

		// Is tooltip too wide and goes over the right side of the chart.?
		if (olf(model.x)) {
			xAlign = 'center';
			yAlign = yf(model.y);
		}
	} else if (rf(model.x)) {
		xAlign = 'right';

		// Is tooltip too wide and goes outside left edge of canvas?
		if (orf(model.x)) {
			xAlign = 'center';
			yAlign = yf(model.y);
		}
	}

	var opts = tooltip._options;
	return {
		xAlign: opts.xAlign ? opts.xAlign : xAlign,
		yAlign: opts.yAlign ? opts.yAlign : yAlign
	};
}

/**
 * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
 */
function getBackgroundPoint(vm, size, alignment, chart) {
	// Background Position
	var x = vm.x;
	var y = vm.y;

	var caretSize = vm.caretSize;
	var caretPadding = vm.caretPadding;
	var cornerRadius = vm.cornerRadius;
	var xAlign = alignment.xAlign;
	var yAlign = alignment.yAlign;
	var paddingAndSize = caretSize + caretPadding;
	var radiusAndPadding = cornerRadius + caretPadding;

	if (xAlign === 'right') {
		x -= size.width;
	} else if (xAlign === 'center') {
		x -= (size.width / 2);
		if (x + size.width > chart.width) {
			x = chart.width - size.width;
		}
		if (x < 0) {
			x = 0;
		}
	}

	if (yAlign === 'top') {
		y += paddingAndSize;
	} else if (yAlign === 'bottom') {
		y -= size.height + paddingAndSize;
	} else {
		y -= (size.height / 2);
	}

	if (yAlign === 'center') {
		if (xAlign === 'left') {
			x += paddingAndSize;
		} else if (xAlign === 'right') {
			x -= paddingAndSize;
		}
	} else if (xAlign === 'left') {
		x -= radiusAndPadding;
	} else if (xAlign === 'right') {
		x += radiusAndPadding;
	}

	return {
		x: x,
		y: y
	};
}

/**
 * Helper to build before and after body lines
 */
function getBeforeAfterBodyLines(callback) {
	return pushOrConcat([], splitNewlines(callback));
}

var exports = module.exports = Element.extend({
	initialize: function() {
		this._model = getBaseModel(this._options);
		this._lastActive = [];
	},

	// Get the title
	// Args are: (tooltipItem, data)
	getTitle: function() {
		var me = this;
		var opts = me._options;
		var callbacks = opts.callbacks;

		var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
		var title = callbacks.title.apply(me, arguments);
		var afterTitle = callbacks.afterTitle.apply(me, arguments);

		var lines = [];
		lines = pushOrConcat(lines, splitNewlines(beforeTitle));
		lines = pushOrConcat(lines, splitNewlines(title));
		lines = pushOrConcat(lines, splitNewlines(afterTitle));

		return lines;
	},

	// Args are: (tooltipItem, data)
	getBeforeBody: function() {
		return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
	},

	// Args are: (tooltipItem, data)
	getBody: function(tooltipItems, data) {
		var me = this;
		var callbacks = me._options.callbacks;
		var bodyItems = [];

		helpers.each(tooltipItems, function(tooltipItem) {
			var bodyItem = {
				before: [],
				lines: [],
				after: []
			};
			pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
			pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
			pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));

			bodyItems.push(bodyItem);
		});

		return bodyItems;
	},

	// Args are: (tooltipItem, data)
	getAfterBody: function() {
		return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
	},

	// Get the footer and beforeFooter and afterFooter lines
	// Args are: (tooltipItem, data)
	getFooter: function() {
		var me = this;
		var callbacks = me._options.callbacks;

		var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
		var footer = callbacks.footer.apply(me, arguments);
		var afterFooter = callbacks.afterFooter.apply(me, arguments);

		var lines = [];
		lines = pushOrConcat(lines, splitNewlines(beforeFooter));
		lines = pushOrConcat(lines, splitNewlines(footer));
		lines = pushOrConcat(lines, splitNewlines(afterFooter));

		return lines;
	},

	update: function(changed) {
		var me = this;
		var opts = me._options;

		// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
		// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
		// which breaks any animations.
		var existingModel = me._model;
		var model = me._model = getBaseModel(opts);
		var active = me._active;

		var data = me._data;

		// In the case where active.length === 0 we need to keep these at existing values for good animations
		var alignment = {
			xAlign: existingModel.xAlign,
			yAlign: existingModel.yAlign
		};
		var backgroundPoint = {
			x: existingModel.x,
			y: existingModel.y
		};
		var tooltipSize = {
			width: existingModel.width,
			height: existingModel.height
		};
		var tooltipPosition = {
			x: existingModel.caretX,
			y: existingModel.caretY
		};

		var i, len;

		if (active.length) {
			model.opacity = 1;

			var labelColors = [];
			var labelTextColors = [];
			tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);

			var tooltipItems = [];
			for (i = 0, len = active.length; i < len; ++i) {
				tooltipItems.push(createTooltipItem(active[i]));
			}

			// If the user provided a filter function, use it to modify the tooltip items
			if (opts.filter) {
				tooltipItems = tooltipItems.filter(function(a) {
					return opts.filter(a, data);
				});
			}

			// If the user provided a sorting function, use it to modify the tooltip items
			if (opts.itemSort) {
				tooltipItems = tooltipItems.sort(function(a, b) {
					return opts.itemSort(a, b, data);
				});
			}

			// Determine colors for boxes
			helpers.each(tooltipItems, function(tooltipItem) {
				labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
				labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
			});


			// Build the Text Lines
			model.title = me.getTitle(tooltipItems, data);
			model.beforeBody = me.getBeforeBody(tooltipItems, data);
			model.body = me.getBody(tooltipItems, data);
			model.afterBody = me.getAfterBody(tooltipItems, data);
			model.footer = me.getFooter(tooltipItems, data);

			// Initial positioning and colors
			model.x = Math.round(tooltipPosition.x);
			model.y = Math.round(tooltipPosition.y);
			model.caretPadding = opts.caretPadding;
			model.labelColors = labelColors;
			model.labelTextColors = labelTextColors;

			// data points
			model.dataPoints = tooltipItems;

			// We need to determine alignment of the tooltip
			tooltipSize = getTooltipSize(this, model);
			alignment = determineAlignment(this, tooltipSize);
			// Final Size and Position
			backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
		} else {
			model.opacity = 0;
		}

		model.xAlign = alignment.xAlign;
		model.yAlign = alignment.yAlign;
		model.x = backgroundPoint.x;
		model.y = backgroundPoint.y;
		model.width = tooltipSize.width;
		model.height = tooltipSize.height;

		// Point where the caret on the tooltip points to
		model.caretX = tooltipPosition.x;
		model.caretY = tooltipPosition.y;

		me._model = model;

		if (changed && opts.custom) {
			opts.custom.call(me, model);
		}

		return me;
	},

	drawCaret: function(tooltipPoint, size) {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

		ctx.lineTo(caretPosition.x1, caretPosition.y1);
		ctx.lineTo(caretPosition.x2, caretPosition.y2);
		ctx.lineTo(caretPosition.x3, caretPosition.y3);
	},
	getCaretPosition: function(tooltipPoint, size, vm) {
		var x1, x2, x3, y1, y2, y3;
		var caretSize = vm.caretSize;
		var cornerRadius = vm.cornerRadius;
		var xAlign = vm.xAlign;
		var yAlign = vm.yAlign;
		var ptX = tooltipPoint.x;
		var ptY = tooltipPoint.y;
		var width = size.width;
		var height = size.height;

		if (yAlign === 'center') {
			y2 = ptY + (height / 2);

			if (xAlign === 'left') {
				x1 = ptX;
				x2 = x1 - caretSize;
				x3 = x1;

				y1 = y2 + caretSize;
				y3 = y2 - caretSize;
			} else {
				x1 = ptX + width;
				x2 = x1 + caretSize;
				x3 = x1;

				y1 = y2 - caretSize;
				y3 = y2 + caretSize;
			}
		} else {
			if (xAlign === 'left') {
				x2 = ptX + cornerRadius + (caretSize);
				x1 = x2 - caretSize;
				x3 = x2 + caretSize;
			} else if (xAlign === 'right') {
				x2 = ptX + width - cornerRadius - caretSize;
				x1 = x2 - caretSize;
				x3 = x2 + caretSize;
			} else {
				x2 = vm.caretX;
				x1 = x2 - caretSize;
				x3 = x2 + caretSize;
			}
			if (yAlign === 'top') {
				y1 = ptY;
				y2 = y1 - caretSize;
				y3 = y1;
			} else {
				y1 = ptY + height;
				y2 = y1 + caretSize;
				y3 = y1;
				// invert drawing order
				var tmp = x3;
				x3 = x1;
				x1 = tmp;
			}
		}
		return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
	},

	drawTitle: function(pt, vm, ctx, opacity) {
		var title = vm.title;

		if (title.length) {
			ctx.textAlign = vm._titleAlign;
			ctx.textBaseline = 'top';

			var titleFontSize = vm.titleFontSize;
			var titleSpacing = vm.titleSpacing;

			ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
			ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

			var i, len;
			for (i = 0, len = title.length; i < len; ++i) {
				ctx.fillText(title[i], pt.x, pt.y);
				pt.y += titleFontSize + titleSpacing; // Line Height and spacing

				if (i + 1 === title.length) {
					pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
				}
			}
		}
	},

	drawBody: function(pt, vm, ctx, opacity) {
		var bodyFontSize = vm.bodyFontSize;
		var bodySpacing = vm.bodySpacing;
		var body = vm.body;

		ctx.textAlign = vm._bodyAlign;
		ctx.textBaseline = 'top';
		ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

		// Before Body
		var xLinePadding = 0;
		var fillLineOfText = function(line) {
			ctx.fillText(line, pt.x + xLinePadding, pt.y);
			pt.y += bodyFontSize + bodySpacing;
		};

		// Before body lines
		ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
		helpers.each(vm.beforeBody, fillLineOfText);

		var drawColorBoxes = vm.displayColors;
		xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;

		// Draw body lines now
		helpers.each(body, function(bodyItem, i) {
			var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
			ctx.fillStyle = textColor;
			helpers.each(bodyItem.before, fillLineOfText);

			helpers.each(bodyItem.lines, function(line) {
				// Draw Legend-like boxes if needed
				if (drawColorBoxes) {
					// Fill a white rect so that colours merge nicely if the opacity is < 1
					ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
					ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

					// Border
					ctx.lineWidth = 1;
					ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
					ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

					// Inner square
					ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
					ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
					ctx.fillStyle = textColor;
				}

				fillLineOfText(line);
			});

			helpers.each(bodyItem.after, fillLineOfText);
		});

		// Reset back to 0 for after body
		xLinePadding = 0;

		// After body lines
		helpers.each(vm.afterBody, fillLineOfText);
		pt.y -= bodySpacing; // Remove last body spacing
	},

	drawFooter: function(pt, vm, ctx, opacity) {
		var footer = vm.footer;

		if (footer.length) {
			pt.y += vm.footerMarginTop;

			ctx.textAlign = vm._footerAlign;
			ctx.textBaseline = 'top';

			ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
			ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

			helpers.each(footer, function(line) {
				ctx.fillText(line, pt.x, pt.y);
				pt.y += vm.footerFontSize + vm.footerSpacing;
			});
		}
	},

	drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
		ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
		ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
		ctx.lineWidth = vm.borderWidth;
		var xAlign = vm.xAlign;
		var yAlign = vm.yAlign;
		var x = pt.x;
		var y = pt.y;
		var width = tooltipSize.width;
		var height = tooltipSize.height;
		var radius = vm.cornerRadius;

		ctx.beginPath();
		ctx.moveTo(x + radius, y);
		if (yAlign === 'top') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
		if (yAlign === 'center' && xAlign === 'right') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
		if (yAlign === 'bottom') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
		if (yAlign === 'center' && xAlign === 'left') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
		ctx.closePath();

		ctx.fill();

		if (vm.borderWidth > 0) {
			ctx.stroke();
		}
	},

	draw: function() {
		var ctx = this._chart.ctx;
		var vm = this._view;

		if (vm.opacity === 0) {
			return;
		}

		var tooltipSize = {
			width: vm.width,
			height: vm.height
		};
		var pt = {
			x: vm.x,
			y: vm.y
		};

		// IE11/Edge does not like very small opacities, so snap to 0
		var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

		// Truthy/falsey value for empty tooltip
		var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

		if (this._options.enabled && hasTooltipContent) {
			// Draw Background
			this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

			// Draw Title, Body, and Footer
			pt.x += vm.xPadding;
			pt.y += vm.yPadding;

			// Titles
			this.drawTitle(pt, vm, ctx, opacity);

			// Body
			this.drawBody(pt, vm, ctx, opacity);

			// Footer
			this.drawFooter(pt, vm, ctx, opacity);
		}
	},

	/**
	 * Handle an event
	 * @private
	 * @param {IEvent} event - The event to handle
	 * @returns {Boolean} true if the tooltip changed
	 */
	handleEvent: function(e) {
		var me = this;
		var options = me._options;
		var changed = false;

		me._lastActive = me._lastActive || [];

		// Find Active Elements for tooltips
		if (e.type === 'mouseout') {
			me._active = [];
		} else {
			me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
		}

		// Remember Last Actives
		changed = !helpers.arrayEquals(me._active, me._lastActive);

		// Only handle target event on tooltip change
		if (changed) {
			me._lastActive = me._active;

			if (options.enabled || options.custom) {
				me._eventPosition = {
					x: e.x,
					y: e.y
				};

				me.update(true);
				me.pivot();
			}
		}

		return changed;
	}
});

/**
 * @namespace Chart.Tooltip.positioners
 */
exports.positioners = positioners;


},{"./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","./core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/core/core.controller.js":[function(require,module,exports) {
'use strict';

var Animation = require('./core.animation');
var animations = require('./core.animations');
var defaults = require('./core.defaults');
var helpers = require('../helpers/index');
var Interaction = require('./core.interaction');
var layouts = require('./core.layouts');
var platform = require('../platforms/platform');
var plugins = require('./core.plugins');
var scaleService = require('../core/core.scaleService');
var Tooltip = require('./core.tooltip');

module.exports = function(Chart) {

	// Create a dictionary of chart types, to allow for extension of existing types
	Chart.types = {};

	// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
	// Destroy method on the chart will remove the instance of the chart from this reference.
	Chart.instances = {};

	// Controllers available for dataset visualization eg. bar, line, slice, etc.
	Chart.controllers = {};

	/**
	 * Initializes the given config with global and chart default values.
	 */
	function initConfig(config) {
		config = config || {};

		// Do NOT use configMerge() for the data object because this method merges arrays
		// and so would change references to labels and datasets, preventing data updates.
		var data = config.data = config.data || {};
		data.datasets = data.datasets || [];
		data.labels = data.labels || [];

		config.options = helpers.configMerge(
			defaults.global,
			defaults[config.type],
			config.options || {});

		return config;
	}

	/**
	 * Updates the config of the chart
	 * @param chart {Chart} chart to update the options for
	 */
	function updateConfig(chart) {
		var newOptions = chart.options;

		helpers.each(chart.scales, function(scale) {
			layouts.removeBox(chart, scale);
		});

		newOptions = helpers.configMerge(
			Chart.defaults.global,
			Chart.defaults[chart.config.type],
			newOptions);

		chart.options = chart.config.options = newOptions;
		chart.ensureScalesHaveIDs();
		chart.buildOrUpdateScales();
		// Tooltip
		chart.tooltip._options = newOptions.tooltips;
		chart.tooltip.initialize();
	}

	function positionIsHorizontal(position) {
		return position === 'top' || position === 'bottom';
	}

	helpers.extend(Chart.prototype, /** @lends Chart */ {
		/**
		 * @private
		 */
		construct: function(item, config) {
			var me = this;

			config = initConfig(config);

			var context = platform.acquireContext(item, config);
			var canvas = context && context.canvas;
			var height = canvas && canvas.height;
			var width = canvas && canvas.width;

			me.id = helpers.uid();
			me.ctx = context;
			me.canvas = canvas;
			me.config = config;
			me.width = width;
			me.height = height;
			me.aspectRatio = height ? width / height : null;
			me.options = config.options;
			me._bufferedRender = false;

			/**
			 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
			 * the "instance" still need to be defined since it might be called from plugins.
			 * @prop Chart#chart
			 * @deprecated since version 2.6.0
			 * @todo remove at version 3
			 * @private
			 */
			me.chart = me;
			me.controller = me; // chart.chart.controller #inception

			// Add the chart instance to the global namespace
			Chart.instances[me.id] = me;

			// Define alias to the config data: `chart.data === chart.config.data`
			Object.defineProperty(me, 'data', {
				get: function() {
					return me.config.data;
				},
				set: function(value) {
					me.config.data = value;
				}
			});

			if (!context || !canvas) {
				// The given item is not a compatible context2d element, let's return before finalizing
				// the chart initialization but after setting basic chart / controller properties that
				// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
				// https://github.com/chartjs/Chart.js/issues/2807
				console.error("Failed to create chart: can't acquire context from the given item");
				return;
			}

			me.initialize();
			me.update();
		},

		/**
		 * @private
		 */
		initialize: function() {
			var me = this;

			// Before init plugin notification
			plugins.notify(me, 'beforeInit');

			helpers.retinaScale(me, me.options.devicePixelRatio);

			me.bindEvents();

			if (me.options.responsive) {
				// Initial resize before chart draws (must be silent to preserve initial animations).
				me.resize(true);
			}

			// Make sure scales have IDs and are built before we build any controllers.
			me.ensureScalesHaveIDs();
			me.buildOrUpdateScales();
			me.initToolTip();

			// After init plugin notification
			plugins.notify(me, 'afterInit');

			return me;
		},

		clear: function() {
			helpers.canvas.clear(this);
			return this;
		},

		stop: function() {
			// Stops any current animation loop occurring
			animations.cancelAnimation(this);
			return this;
		},

		resize: function(silent) {
			var me = this;
			var options = me.options;
			var canvas = me.canvas;
			var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

			// the canvas render width and height will be casted to integers so make sure that
			// the canvas display style uses the same integer values to avoid blurring effect.

			// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed
			var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
			var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

			if (me.width === newWidth && me.height === newHeight) {
				return;
			}

			canvas.width = me.width = newWidth;
			canvas.height = me.height = newHeight;
			canvas.style.width = newWidth + 'px';
			canvas.style.height = newHeight + 'px';

			helpers.retinaScale(me, options.devicePixelRatio);

			if (!silent) {
				// Notify any plugins about the resize
				var newSize = {width: newWidth, height: newHeight};
				plugins.notify(me, 'resize', [newSize]);

				// Notify of resize
				if (me.options.onResize) {
					me.options.onResize(me, newSize);
				}

				me.stop();
				me.update({
					duration: me.options.responsiveAnimationDuration
				});
			}
		},

		ensureScalesHaveIDs: function() {
			var options = this.options;
			var scalesOptions = options.scales || {};
			var scaleOptions = options.scale;

			helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
				xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
			});

			helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
				yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
			});

			if (scaleOptions) {
				scaleOptions.id = scaleOptions.id || 'scale';
			}
		},

		/**
		 * Builds a map of scale ID to scale object for future lookup.
		 */
		buildOrUpdateScales: function() {
			var me = this;
			var options = me.options;
			var scales = me.scales || {};
			var items = [];
			var updated = Object.keys(scales).reduce(function(obj, id) {
				obj[id] = false;
				return obj;
			}, {});

			if (options.scales) {
				items = items.concat(
					(options.scales.xAxes || []).map(function(xAxisOptions) {
						return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
					}),
					(options.scales.yAxes || []).map(function(yAxisOptions) {
						return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
					})
				);
			}

			if (options.scale) {
				items.push({
					options: options.scale,
					dtype: 'radialLinear',
					isDefault: true,
					dposition: 'chartArea'
				});
			}

			helpers.each(items, function(item) {
				var scaleOptions = item.options;
				var id = scaleOptions.id;
				var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);

				if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
					scaleOptions.position = item.dposition;
				}

				updated[id] = true;
				var scale = null;
				if (id in scales && scales[id].type === scaleType) {
					scale = scales[id];
					scale.options = scaleOptions;
					scale.ctx = me.ctx;
					scale.chart = me;
				} else {
					var scaleClass = scaleService.getScaleConstructor(scaleType);
					if (!scaleClass) {
						return;
					}
					scale = new scaleClass({
						id: id,
						type: scaleType,
						options: scaleOptions,
						ctx: me.ctx,
						chart: me
					});
					scales[scale.id] = scale;
				}

				scale.mergeTicksOptions();

				// TODO(SB): I think we should be able to remove this custom case (options.scale)
				// and consider it as a regular scale part of the "scales"" map only! This would
				// make the logic easier and remove some useless? custom code.
				if (item.isDefault) {
					me.scale = scale;
				}
			});
			// clear up discarded scales
			helpers.each(updated, function(hasUpdated, id) {
				if (!hasUpdated) {
					delete scales[id];
				}
			});

			me.scales = scales;

			scaleService.addScalesToLayout(this);
		},

		buildOrUpdateControllers: function() {
			var me = this;
			var types = [];
			var newControllers = [];

			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				var meta = me.getDatasetMeta(datasetIndex);
				var type = dataset.type || me.config.type;

				if (meta.type && meta.type !== type) {
					me.destroyDatasetMeta(datasetIndex);
					meta = me.getDatasetMeta(datasetIndex);
				}
				meta.type = type;

				types.push(meta.type);

				if (meta.controller) {
					meta.controller.updateIndex(datasetIndex);
					meta.controller.linkScales();
				} else {
					var ControllerClass = Chart.controllers[meta.type];
					if (ControllerClass === undefined) {
						throw new Error('"' + meta.type + '" is not a chart type.');
					}

					meta.controller = new ControllerClass(me, datasetIndex);
					newControllers.push(meta.controller);
				}
			}, me);

			return newControllers;
		},

		/**
		 * Reset the elements of all datasets
		 * @private
		 */
		resetElements: function() {
			var me = this;
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.reset();
			}, me);
		},

		/**
		* Resets the chart back to it's state before the initial animation
		*/
		reset: function() {
			this.resetElements();
			this.tooltip.initialize();
		},

		update: function(config) {
			var me = this;

			if (!config || typeof config !== 'object') {
				// backwards compatibility
				config = {
					duration: config,
					lazy: arguments[1]
				};
			}

			updateConfig(me);

			// plugins options references might have change, let's invalidate the cache
			// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
			plugins._invalidate(me);

			if (plugins.notify(me, 'beforeUpdate') === false) {
				return;
			}

			// In case the entire data object changed
			me.tooltip._data = me.data;

			// Make sure dataset controllers are updated and new controllers are reset
			var newControllers = me.buildOrUpdateControllers();

			// Make sure all dataset controllers have correct meta data counts
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
			}, me);

			me.updateLayout();

			// Can only reset the new controllers after the scales have been updated
			if (me.options.animation && me.options.animation.duration) {
				helpers.each(newControllers, function(controller) {
					controller.reset();
				});
			}

			me.updateDatasets();

			// Need to reset tooltip in case it is displayed with elements that are removed
			// after update.
			me.tooltip.initialize();

			// Last active contains items that were previously in the tooltip.
			// When we reset the tooltip, we need to clear it
			me.lastActive = [];

			// Do this before render so that any plugins that need final scale updates can use it
			plugins.notify(me, 'afterUpdate');

			if (me._bufferedRender) {
				me._bufferedRequest = {
					duration: config.duration,
					easing: config.easing,
					lazy: config.lazy
				};
			} else {
				me.render(config);
			}
		},

		/**
		 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
		 * hook, in which case, plugins will not be called on `afterLayout`.
		 * @private
		 */
		updateLayout: function() {
			var me = this;

			if (plugins.notify(me, 'beforeLayout') === false) {
				return;
			}

			layouts.update(this, this.width, this.height);

			/**
			 * Provided for backward compatibility, use `afterLayout` instead.
			 * @method IPlugin#afterScaleUpdate
			 * @deprecated since version 2.5.0
			 * @todo remove at version 3
			 * @private
			 */
			plugins.notify(me, 'afterScaleUpdate');
			plugins.notify(me, 'afterLayout');
		},

		/**
		 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
		 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
		 * @private
		 */
		updateDatasets: function() {
			var me = this;

			if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
				return;
			}

			for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				me.updateDataset(i);
			}

			plugins.notify(me, 'afterDatasetsUpdate');
		},

		/**
		 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
		 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
		 * @private
		 */
		updateDataset: function(index) {
			var me = this;
			var meta = me.getDatasetMeta(index);
			var args = {
				meta: meta,
				index: index
			};

			if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
				return;
			}

			meta.controller.update();

			plugins.notify(me, 'afterDatasetUpdate', [args]);
		},

		render: function(config) {
			var me = this;

			if (!config || typeof config !== 'object') {
				// backwards compatibility
				config = {
					duration: config,
					lazy: arguments[1]
				};
			}

			var duration = config.duration;
			var lazy = config.lazy;

			if (plugins.notify(me, 'beforeRender') === false) {
				return;
			}

			var animationOptions = me.options.animation;
			var onComplete = function(animation) {
				plugins.notify(me, 'afterRender');
				helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
			};

			if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
				var animation = new Animation({
					numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
					easing: config.easing || animationOptions.easing,

					render: function(chart, animationObject) {
						var easingFunction = helpers.easing.effects[animationObject.easing];
						var currentStep = animationObject.currentStep;
						var stepDecimal = currentStep / animationObject.numSteps;

						chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
					},

					onAnimationProgress: animationOptions.onProgress,
					onAnimationComplete: onComplete
				});

				animations.addAnimation(me, animation, duration, lazy);
			} else {
				me.draw();

				// See https://github.com/chartjs/Chart.js/issues/3781
				onComplete(new Animation({numSteps: 0, chart: me}));
			}

			return me;
		},

		draw: function(easingValue) {
			var me = this;

			me.clear();

			if (helpers.isNullOrUndef(easingValue)) {
				easingValue = 1;
			}

			me.transition(easingValue);

			if (me.width <= 0 || me.height <= 0) {
				return;
			}

			if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
				return;
			}

			// Draw all the scales
			helpers.each(me.boxes, function(box) {
				box.draw(me.chartArea);
			}, me);

			if (me.scale) {
				me.scale.draw();
			}

			me.drawDatasets(easingValue);
			me._drawTooltip(easingValue);

			plugins.notify(me, 'afterDraw', [easingValue]);
		},

		/**
		 * @private
		 */
		transition: function(easingValue) {
			var me = this;

			for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
				if (me.isDatasetVisible(i)) {
					me.getDatasetMeta(i).controller.transition(easingValue);
				}
			}

			me.tooltip.transition(easingValue);
		},

		/**
		 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
		 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
		 * @private
		 */
		drawDatasets: function(easingValue) {
			var me = this;

			if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
				return;
			}

			// Draw datasets reversed to support proper line stacking
			for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
				if (me.isDatasetVisible(i)) {
					me.drawDataset(i, easingValue);
				}
			}

			plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
		},

		/**
		 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
		 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
		 * @private
		 */
		drawDataset: function(index, easingValue) {
			var me = this;
			var meta = me.getDatasetMeta(index);
			var args = {
				meta: meta,
				index: index,
				easingValue: easingValue
			};

			if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
				return;
			}

			meta.controller.draw(easingValue);

			plugins.notify(me, 'afterDatasetDraw', [args]);
		},

		/**
		 * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
		 * hook, in which case, plugins will not be called on `afterTooltipDraw`.
		 * @private
		 */
		_drawTooltip: function(easingValue) {
			var me = this;
			var tooltip = me.tooltip;
			var args = {
				tooltip: tooltip,
				easingValue: easingValue
			};

			if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
				return;
			}

			tooltip.draw();

			plugins.notify(me, 'afterTooltipDraw', [args]);
		},

		// Get the single element that was clicked on
		// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
		getElementAtEvent: function(e) {
			return Interaction.modes.single(this, e);
		},

		getElementsAtEvent: function(e) {
			return Interaction.modes.label(this, e, {intersect: true});
		},

		getElementsAtXAxis: function(e) {
			return Interaction.modes['x-axis'](this, e, {intersect: true});
		},

		getElementsAtEventForMode: function(e, mode, options) {
			var method = Interaction.modes[mode];
			if (typeof method === 'function') {
				return method(this, e, options);
			}

			return [];
		},

		getDatasetAtEvent: function(e) {
			return Interaction.modes.dataset(this, e, {intersect: true});
		},

		getDatasetMeta: function(datasetIndex) {
			var me = this;
			var dataset = me.data.datasets[datasetIndex];
			if (!dataset._meta) {
				dataset._meta = {};
			}

			var meta = dataset._meta[me.id];
			if (!meta) {
				meta = dataset._meta[me.id] = {
					type: null,
					data: [],
					dataset: null,
					controller: null,
					hidden: null,			// See isDatasetVisible() comment
					xAxisID: null,
					yAxisID: null
				};
			}

			return meta;
		},

		getVisibleDatasetCount: function() {
			var count = 0;
			for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
				if (this.isDatasetVisible(i)) {
					count++;
				}
			}
			return count;
		},

		isDatasetVisible: function(datasetIndex) {
			var meta = this.getDatasetMeta(datasetIndex);

			// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
			// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
			return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
		},

		generateLegend: function() {
			return this.options.legendCallback(this);
		},

		/**
		 * @private
		 */
		destroyDatasetMeta: function(datasetIndex) {
			var id = this.id;
			var dataset = this.data.datasets[datasetIndex];
			var meta = dataset._meta && dataset._meta[id];

			if (meta) {
				meta.controller.destroy();
				delete dataset._meta[id];
			}
		},

		destroy: function() {
			var me = this;
			var canvas = me.canvas;
			var i, ilen;

			me.stop();

			// dataset controllers need to cleanup associated data
			for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				me.destroyDatasetMeta(i);
			}

			if (canvas) {
				me.unbindEvents();
				helpers.canvas.clear(me);
				platform.releaseContext(me.ctx);
				me.canvas = null;
				me.ctx = null;
			}

			plugins.notify(me, 'destroy');

			delete Chart.instances[me.id];
		},

		toBase64Image: function() {
			return this.canvas.toDataURL.apply(this.canvas, arguments);
		},

		initToolTip: function() {
			var me = this;
			me.tooltip = new Tooltip({
				_chart: me,
				_chartInstance: me, // deprecated, backward compatibility
				_data: me.data,
				_options: me.options.tooltips
			}, me);
		},

		/**
		 * @private
		 */
		bindEvents: function() {
			var me = this;
			var listeners = me._listeners = {};
			var listener = function() {
				me.eventHandler.apply(me, arguments);
			};

			helpers.each(me.options.events, function(type) {
				platform.addEventListener(me, type, listener);
				listeners[type] = listener;
			});

			// Elements used to detect size change should not be injected for non responsive charts.
			// See https://github.com/chartjs/Chart.js/issues/2210
			if (me.options.responsive) {
				listener = function() {
					me.resize();
				};

				platform.addEventListener(me, 'resize', listener);
				listeners.resize = listener;
			}
		},

		/**
		 * @private
		 */
		unbindEvents: function() {
			var me = this;
			var listeners = me._listeners;
			if (!listeners) {
				return;
			}

			delete me._listeners;
			helpers.each(listeners, function(listener, type) {
				platform.removeEventListener(me, type, listener);
			});
		},

		updateHoverStyle: function(elements, mode, enabled) {
			var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
			var element, i, ilen;

			for (i = 0, ilen = elements.length; i < ilen; ++i) {
				element = elements[i];
				if (element) {
					this.getDatasetMeta(element._datasetIndex).controller[method](element);
				}
			}
		},

		/**
		 * @private
		 */
		eventHandler: function(e) {
			var me = this;
			var tooltip = me.tooltip;

			if (plugins.notify(me, 'beforeEvent', [e]) === false) {
				return;
			}

			// Buffer any update calls so that renders do not occur
			me._bufferedRender = true;
			me._bufferedRequest = null;

			var changed = me.handleEvent(e);
			// for smooth tooltip animations issue #4989
			// the tooltip should be the source of change
			// Animation check workaround:
			// tooltip._start will be null when tooltip isn't animating
			if (tooltip) {
				changed = tooltip._start
					? tooltip.handleEvent(e)
					: changed | tooltip.handleEvent(e);
			}

			plugins.notify(me, 'afterEvent', [e]);

			var bufferedRequest = me._bufferedRequest;
			if (bufferedRequest) {
				// If we have an update that was triggered, we need to do a normal render
				me.render(bufferedRequest);
			} else if (changed && !me.animating) {
				// If entering, leaving, or changing elements, animate the change via pivot
				me.stop();

				// We only need to render at this point. Updating will cause scales to be
				// recomputed generating flicker & using more memory than necessary.
				me.render({
					duration: me.options.hover.animationDuration,
					lazy: true
				});
			}

			me._bufferedRender = false;
			me._bufferedRequest = null;

			return me;
		},

		/**
		 * Handle an event
		 * @private
		 * @param {IEvent} event the event to handle
		 * @return {Boolean} true if the chart needs to re-render
		 */
		handleEvent: function(e) {
			var me = this;
			var options = me.options || {};
			var hoverOptions = options.hover;
			var changed = false;

			me.lastActive = me.lastActive || [];

			// Find Active Elements for hover and tooltips
			if (e.type === 'mouseout') {
				me.active = [];
			} else {
				me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
			}

			// Invoke onHover hook
			// Need to call with native event here to not break backwards compatibility
			helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

			if (e.type === 'mouseup' || e.type === 'click') {
				if (options.onClick) {
					// Use e.native here for backwards compatibility
					options.onClick.call(me, e.native, me.active);
				}
			}

			// Remove styling for last active (even if it may still be active)
			if (me.lastActive.length) {
				me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
			}

			// Built in hover styling
			if (me.active.length && hoverOptions.mode) {
				me.updateHoverStyle(me.active, hoverOptions.mode, true);
			}

			changed = !helpers.arrayEquals(me.active, me.lastActive);

			// Remember Last Actives
			me.lastActive = me.active;

			return changed;
		}
	});

	/**
	 * Provided for backward compatibility, use Chart instead.
	 * @class Chart.Controller
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.Controller = Chart;
};

},{"./core.animation":"../node_modules/chart.js/src/core/core.animation.js","./core.animations":"../node_modules/chart.js/src/core/core.animations.js","./core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","./core.interaction":"../node_modules/chart.js/src/core/core.interaction.js","./core.layouts":"../node_modules/chart.js/src/core/core.layouts.js","../platforms/platform":"../node_modules/chart.js/src/platforms/platform.js","./core.plugins":"../node_modules/chart.js/src/core/core.plugins.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js","./core.tooltip":"../node_modules/chart.js/src/core/core.tooltip.js"}],"../node_modules/chart.js/src/core/core.datasetController.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');

module.exports = function(Chart) {

	var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

	/**
	 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
	 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
	 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
	 */
	function listenArrayEvents(array, listener) {
		if (array._chartjs) {
			array._chartjs.listeners.push(listener);
			return;
		}

		Object.defineProperty(array, '_chartjs', {
			configurable: true,
			enumerable: false,
			value: {
				listeners: [listener]
			}
		});

		arrayEvents.forEach(function(key) {
			var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
			var base = array[key];

			Object.defineProperty(array, key, {
				configurable: true,
				enumerable: false,
				value: function() {
					var args = Array.prototype.slice.call(arguments);
					var res = base.apply(this, args);

					helpers.each(array._chartjs.listeners, function(object) {
						if (typeof object[method] === 'function') {
							object[method].apply(object, args);
						}
					});

					return res;
				}
			});
		});
	}

	/**
	 * Removes the given array event listener and cleanup extra attached properties (such as
	 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
	 */
	function unlistenArrayEvents(array, listener) {
		var stub = array._chartjs;
		if (!stub) {
			return;
		}

		var listeners = stub.listeners;
		var index = listeners.indexOf(listener);
		if (index !== -1) {
			listeners.splice(index, 1);
		}

		if (listeners.length > 0) {
			return;
		}

		arrayEvents.forEach(function(key) {
			delete array[key];
		});

		delete array._chartjs;
	}

	// Base class for all dataset controllers (line, bar, etc)
	Chart.DatasetController = function(chart, datasetIndex) {
		this.initialize(chart, datasetIndex);
	};

	helpers.extend(Chart.DatasetController.prototype, {

		/**
		 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
		 * @type {Chart.core.element}
		 */
		datasetElementType: null,

		/**
		 * Element type used to generate a meta data (e.g. Chart.element.Point).
		 * @type {Chart.core.element}
		 */
		dataElementType: null,

		initialize: function(chart, datasetIndex) {
			var me = this;
			me.chart = chart;
			me.index = datasetIndex;
			me.linkScales();
			me.addElements();
		},

		updateIndex: function(datasetIndex) {
			this.index = datasetIndex;
		},

		linkScales: function() {
			var me = this;
			var meta = me.getMeta();
			var dataset = me.getDataset();

			if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
				meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
			}
			if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
				meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
			}
		},

		getDataset: function() {
			return this.chart.data.datasets[this.index];
		},

		getMeta: function() {
			return this.chart.getDatasetMeta(this.index);
		},

		getScaleForId: function(scaleID) {
			return this.chart.scales[scaleID];
		},

		reset: function() {
			this.update(true);
		},

		/**
		 * @private
		 */
		destroy: function() {
			if (this._data) {
				unlistenArrayEvents(this._data, this);
			}
		},

		createMetaDataset: function() {
			var me = this;
			var type = me.datasetElementType;
			return type && new type({
				_chart: me.chart,
				_datasetIndex: me.index
			});
		},

		createMetaData: function(index) {
			var me = this;
			var type = me.dataElementType;
			return type && new type({
				_chart: me.chart,
				_datasetIndex: me.index,
				_index: index
			});
		},

		addElements: function() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data || [];
			var metaData = meta.data;
			var i, ilen;

			for (i = 0, ilen = data.length; i < ilen; ++i) {
				metaData[i] = metaData[i] || me.createMetaData(i);
			}

			meta.dataset = meta.dataset || me.createMetaDataset();
		},

		addElementAndReset: function(index) {
			var element = this.createMetaData(index);
			this.getMeta().data.splice(index, 0, element);
			this.updateElement(element, index, true);
		},

		buildOrUpdateElements: function() {
			var me = this;
			var dataset = me.getDataset();
			var data = dataset.data || (dataset.data = []);

			// In order to correctly handle data addition/deletion animation (an thus simulate
			// real-time charts), we need to monitor these data modifications and synchronize
			// the internal meta data accordingly.
			if (me._data !== data) {
				if (me._data) {
					// This case happens when the user replaced the data array instance.
					unlistenArrayEvents(me._data, me);
				}

				listenArrayEvents(data, me);
				me._data = data;
			}

			// Re-sync meta data in case the user replaced the data array or if we missed
			// any updates and so make sure that we handle number of datapoints changing.
			me.resyncElements();
		},

		update: helpers.noop,

		transition: function(easingValue) {
			var meta = this.getMeta();
			var elements = meta.data || [];
			var ilen = elements.length;
			var i = 0;

			for (; i < ilen; ++i) {
				elements[i].transition(easingValue);
			}

			if (meta.dataset) {
				meta.dataset.transition(easingValue);
			}
		},

		draw: function() {
			var meta = this.getMeta();
			var elements = meta.data || [];
			var ilen = elements.length;
			var i = 0;

			if (meta.dataset) {
				meta.dataset.draw();
			}

			for (; i < ilen; ++i) {
				elements[i].draw();
			}
		},

		removeHoverStyle: function(element) {
			helpers.merge(element._model, element.$previousStyle || {});
			delete element.$previousStyle;
		},

		setHoverStyle: function(element) {
			var dataset = this.chart.data.datasets[element._datasetIndex];
			var index = element._index;
			var custom = element.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var getHoverColor = helpers.getHoverColor;
			var model = element._model;

			element.$previousStyle = {
				backgroundColor: model.backgroundColor,
				borderColor: model.borderColor,
				borderWidth: model.borderWidth
			};

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		/**
		 * @private
		 */
		resyncElements: function() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data;
			var numMeta = meta.data.length;
			var numData = data.length;

			if (numData < numMeta) {
				meta.data.splice(numData, numMeta - numData);
			} else if (numData > numMeta) {
				me.insertElements(numMeta, numData - numMeta);
			}
		},

		/**
		 * @private
		 */
		insertElements: function(start, count) {
			for (var i = 0; i < count; ++i) {
				this.addElementAndReset(start + i);
			}
		},

		/**
		 * @private
		 */
		onDataPush: function() {
			this.insertElements(this.getDataset().data.length - 1, arguments.length);
		},

		/**
		 * @private
		 */
		onDataPop: function() {
			this.getMeta().data.pop();
		},

		/**
		 * @private
		 */
		onDataShift: function() {
			this.getMeta().data.shift();
		},

		/**
		 * @private
		 */
		onDataSplice: function(start, count) {
			this.getMeta().data.splice(start, count);
			this.insertElements(start, arguments.length - 2);
		},

		/**
		 * @private
		 */
		onDataUnshift: function() {
			this.insertElements(0, arguments.length);
		}
	});

	Chart.DatasetController.extend = helpers.inherits;
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/scales/scale.linearbase.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');
var Scale = require('../core/core.scale');

/**
 * Generate a set of linear ticks
 * @param generationOptions the options used to generate the ticks
 * @param dataRange the range of the data
 * @returns {Array<Number>} array of tick values
 */
function generateTicks(generationOptions, dataRange) {
	var ticks = [];
	// To get a "nice" value for the tick spacing, we will use the appropriately named
	// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
	// for details.

	var factor;
	var precision;
	var spacing;

	if (generationOptions.stepSize && generationOptions.stepSize > 0) {
		spacing = generationOptions.stepSize;
	} else {
		var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
		spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);

		precision = generationOptions.precision;
		if (precision !== undefined) {
			// If the user specified a precision, round to that number of decimal places
			factor = Math.pow(10, precision);
			spacing = Math.ceil(spacing * factor) / factor;
		}
	}
	var niceMin = Math.floor(dataRange.min / spacing) * spacing;
	var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

	// If min, max and stepSize is set and they make an evenly spaced scale use it.
	if (!helpers.isNullOrUndef(generationOptions.min) && !helpers.isNullOrUndef(generationOptions.max) && generationOptions.stepSize) {
		// If very close to our whole number, use it.
		if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
			niceMin = generationOptions.min;
			niceMax = generationOptions.max;
		}
	}

	var numSpaces = (niceMax - niceMin) / spacing;
	// If very close to our rounded value, use it.
	if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
		numSpaces = Math.round(numSpaces);
	} else {
		numSpaces = Math.ceil(numSpaces);
	}

	precision = 1;
	if (spacing < 1) {
		precision = Math.pow(10, 1 - Math.floor(helpers.log10(spacing)));
		niceMin = Math.round(niceMin * precision) / precision;
		niceMax = Math.round(niceMax * precision) / precision;
	}
	ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
	for (var j = 1; j < numSpaces; ++j) {
		ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
	}
	ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

	return ticks;
}

module.exports = function(Chart) {

	var noop = helpers.noop;

	Chart.LinearScaleBase = Scale.extend({
		getRightValue: function(value) {
			if (typeof value === 'string') {
				return +value;
			}
			return Scale.prototype.getRightValue.call(this, value);
		},

		handleTickRangeOptions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
			// do nothing since that would make the chart weird. If the user really wants a weird chart
			// axis, they can manually override it
			if (tickOpts.beginAtZero) {
				var minSign = helpers.sign(me.min);
				var maxSign = helpers.sign(me.max);

				if (minSign < 0 && maxSign < 0) {
					// move the top up to 0
					me.max = 0;
				} else if (minSign > 0 && maxSign > 0) {
					// move the bottom down to 0
					me.min = 0;
				}
			}

			var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
			var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

			if (tickOpts.min !== undefined) {
				me.min = tickOpts.min;
			} else if (tickOpts.suggestedMin !== undefined) {
				if (me.min === null) {
					me.min = tickOpts.suggestedMin;
				} else {
					me.min = Math.min(me.min, tickOpts.suggestedMin);
				}
			}

			if (tickOpts.max !== undefined) {
				me.max = tickOpts.max;
			} else if (tickOpts.suggestedMax !== undefined) {
				if (me.max === null) {
					me.max = tickOpts.suggestedMax;
				} else {
					me.max = Math.max(me.max, tickOpts.suggestedMax);
				}
			}

			if (setMin !== setMax) {
				// We set the min or the max but not both.
				// So ensure that our range is good
				// Inverted or 0 length range can happen when
				// ticks.min is set, and no datasets are visible
				if (me.min >= me.max) {
					if (setMin) {
						me.max = me.min + 1;
					} else {
						me.min = me.max - 1;
					}
				}
			}

			if (me.min === me.max) {
				me.max++;

				if (!tickOpts.beginAtZero) {
					me.min--;
				}
			}
		},
		getTickLimit: noop,
		handleDirectionalChanges: noop,

		buildTicks: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph. Make sure we always have at least 2 ticks
			var maxTicks = me.getTickLimit();
			maxTicks = Math.max(2, maxTicks);

			var numericGeneratorOptions = {
				maxTicks: maxTicks,
				min: tickOpts.min,
				max: tickOpts.max,
				precision: tickOpts.precision,
				stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
			};
			var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);

			me.handleDirectionalChanges();

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);

			if (tickOpts.reverse) {
				ticks.reverse();

				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function() {
			var me = this;
			me.ticksAsNumbers = me.ticks.slice();
			me.zeroLineIndex = me.ticks.indexOf(0);

			Scale.prototype.convertTicksToLabels.call(me);
		}
	});
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.scale":"../node_modules/chart.js/src/core/core.scale.js"}],"../node_modules/chart.js/src/scales/scale.category.js":[function(require,module,exports) {
'use strict';

var Scale = require('../core/core.scale');
var scaleService = require('../core/core.scaleService');

module.exports = function() {

	// Default config for a category scale
	var defaultConfig = {
		position: 'bottom'
	};

	var DatasetScale = Scale.extend({
		/**
		* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
		* else fall back to data.labels
		* @private
		*/
		getLabels: function() {
			var data = this.chart.data;
			return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
		},

		determineDataLimits: function() {
			var me = this;
			var labels = me.getLabels();
			me.minIndex = 0;
			me.maxIndex = labels.length - 1;
			var findIndex;

			if (me.options.ticks.min !== undefined) {
				// user specified min value
				findIndex = labels.indexOf(me.options.ticks.min);
				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
			}

			if (me.options.ticks.max !== undefined) {
				// user specified max value
				findIndex = labels.indexOf(me.options.ticks.max);
				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
			}

			me.min = labels[me.minIndex];
			me.max = labels[me.maxIndex];
		},

		buildTicks: function() {
			var me = this;
			var labels = me.getLabels();
			// If we are viewing some subset of labels, slice the original array
			me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
		},

		getLabelForIndex: function(index, datasetIndex) {
			var me = this;
			var data = me.chart.data;
			var isHorizontal = me.isHorizontal();

			if (data.yLabels && !isHorizontal) {
				return me.getRightValue(data.datasets[datasetIndex].data[index]);
			}
			return me.ticks[index - me.minIndex];
		},

		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: function(value, index) {
			var me = this;
			var offset = me.options.offset;
			// 1 is added because we need the length but we have the indexes
			var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);

			// If value is a data object, then index is the index in the data array,
			// not the index of the scale. We need to change that.
			var valueCategory;
			if (value !== undefined && value !== null) {
				valueCategory = me.isHorizontal() ? value.x : value.y;
			}
			if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
				var labels = me.getLabels();
				value = valueCategory || value;
				var idx = labels.indexOf(value);
				index = idx !== -1 ? idx : index;
			}

			if (me.isHorizontal()) {
				var valueWidth = me.width / offsetAmt;
				var widthOffset = (valueWidth * (index - me.minIndex));

				if (offset) {
					widthOffset += (valueWidth / 2);
				}

				return me.left + Math.round(widthOffset);
			}
			var valueHeight = me.height / offsetAmt;
			var heightOffset = (valueHeight * (index - me.minIndex));

			if (offset) {
				heightOffset += (valueHeight / 2);
			}

			return me.top + Math.round(heightOffset);
		},
		getPixelForTick: function(index) {
			return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var offset = me.options.offset;
			var value;
			var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
			var horz = me.isHorizontal();
			var valueDimension = (horz ? me.width : me.height) / offsetAmt;

			pixel -= horz ? me.left : me.top;

			if (offset) {
				pixel -= (valueDimension / 2);
			}

			if (pixel <= 0) {
				value = 0;
			} else {
				value = Math.round(pixel / valueDimension);
			}

			return value + me.minIndex;
		},
		getBasePixel: function() {
			return this.bottom;
		}
	});

	scaleService.registerScaleType('category', DatasetScale, defaultConfig);
};

},{"../core/core.scale":"../node_modules/chart.js/src/core/core.scale.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js"}],"../node_modules/chart.js/src/scales/scale.linear.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var helpers = require('../helpers/index');
var scaleService = require('../core/core.scaleService');
var Ticks = require('../core/core.ticks');

module.exports = function(Chart) {

	var defaultConfig = {
		position: 'left',
		ticks: {
			callback: Ticks.formatters.linear
		}
	};

	var LinearScale = Chart.LinearScaleBase.extend({

		determineDataLimits: function() {
			var me = this;
			var opts = me.options;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var isHorizontal = me.isHorizontal();
			var DEFAULT_MIN = 0;
			var DEFAULT_MAX = 1;

			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// First Calculate the range
			me.min = null;
			me.max = null;

			var hasStacks = opts.stacked;
			if (hasStacks === undefined) {
				helpers.each(datasets, function(dataset, datasetIndex) {
					if (hasStacks) {
						return;
					}

					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
						meta.stack !== undefined) {
						hasStacks = true;
					}
				});
			}

			if (opts.stacked || hasStacks) {
				var valuesPerStack = {};

				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var key = [
						meta.type,
						// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
						((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
						meta.stack
					].join('.');

					if (valuesPerStack[key] === undefined) {
						valuesPerStack[key] = {
							positiveValues: [],
							negativeValues: []
						};
					}

					// Store these per type
					var positiveValues = valuesPerStack[key].positiveValues;
					var negativeValues = valuesPerStack[key].negativeValues;

					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							positiveValues[index] = positiveValues[index] || 0;
							negativeValues[index] = negativeValues[index] || 0;

							if (opts.relativePoints) {
								positiveValues[index] = 100;
							} else if (value < 0) {
								negativeValues[index] += value;
							} else {
								positiveValues[index] += value;
							}
						});
					}
				});

				helpers.each(valuesPerStack, function(valuesForType) {
					var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
					var minVal = helpers.min(values);
					var maxVal = helpers.max(values);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});

			} else {
				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							if (me.min === null) {
								me.min = value;
							} else if (value < me.min) {
								me.min = value;
							}

							if (me.max === null) {
								me.max = value;
							} else if (value > me.max) {
								me.max = value;
							}
						});
					}
				});
			}

			me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
			me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			this.handleTickRangeOptions();
		},
		getTickLimit: function() {
			var maxTicks;
			var me = this;
			var tickOpts = me.options.ticks;

			if (me.isHorizontal()) {
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
			} else {
				// The factor of 2 used to scale the font size has been experimentally determined.
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
			}

			return maxTicks;
		},
		// Called after the ticks are built. We need
		handleDirectionalChanges: function() {
			if (!this.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				this.ticks.reverse();
			}
		},
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		// Utils
		getPixelForValue: function(value) {
			// This must be called after fit has been run so that
			// this.left, this.top, this.right, and this.bottom have been defined
			var me = this;
			var start = me.start;

			var rightValue = +me.getRightValue(value);
			var pixel;
			var range = me.end - start;

			if (me.isHorizontal()) {
				pixel = me.left + (me.width / range * (rightValue - start));
			} else {
				pixel = me.bottom - (me.height / range * (rightValue - start));
			}
			return pixel;
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var isHorizontal = me.isHorizontal();
			var innerDimension = isHorizontal ? me.width : me.height;
			var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
			return me.start + ((me.end - me.start) * offset);
		},
		getPixelForTick: function(index) {
			return this.getPixelForValue(this.ticksAsNumbers[index]);
		}
	});

	scaleService.registerScaleType('linear', LinearScale, defaultConfig);
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js","../core/core.ticks":"../node_modules/chart.js/src/core/core.ticks.js"}],"../node_modules/chart.js/src/scales/scale.logarithmic.js":[function(require,module,exports) {
'use strict';

var helpers = require('../helpers/index');
var Scale = require('../core/core.scale');
var scaleService = require('../core/core.scaleService');
var Ticks = require('../core/core.ticks');

/**
 * Generate a set of logarithmic ticks
 * @param generationOptions the options used to generate the ticks
 * @param dataRange the range of the data
 * @returns {Array<Number>} array of tick values
 */
function generateTicks(generationOptions, dataRange) {
	var ticks = [];
	var valueOrDefault = helpers.valueOrDefault;

	// Figure out what the max number of ticks we can support it is based on the size of
	// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
	// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
	// the graph
	var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

	var endExp = Math.floor(helpers.log10(dataRange.max));
	var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
	var exp, significand;

	if (tickVal === 0) {
		exp = Math.floor(helpers.log10(dataRange.minNotZero));
		significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

		ticks.push(tickVal);
		tickVal = significand * Math.pow(10, exp);
	} else {
		exp = Math.floor(helpers.log10(tickVal));
		significand = Math.floor(tickVal / Math.pow(10, exp));
	}
	var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

	do {
		ticks.push(tickVal);

		++significand;
		if (significand === 10) {
			significand = 1;
			++exp;
			precision = exp >= 0 ? 1 : precision;
		}

		tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
	} while (exp < endExp || (exp === endExp && significand < endSignificand));

	var lastTick = valueOrDefault(generationOptions.max, tickVal);
	ticks.push(lastTick);

	return ticks;
}


module.exports = function(Chart) {

	var defaultConfig = {
		position: 'left',

		// label settings
		ticks: {
			callback: Ticks.formatters.logarithmic
		}
	};

	var LogarithmicScale = Scale.extend({
		determineDataLimits: function() {
			var me = this;
			var opts = me.options;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var isHorizontal = me.isHorizontal();
			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// Calculate Range
			me.min = null;
			me.max = null;
			me.minNotZero = null;

			var hasStacks = opts.stacked;
			if (hasStacks === undefined) {
				helpers.each(datasets, function(dataset, datasetIndex) {
					if (hasStacks) {
						return;
					}

					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
						meta.stack !== undefined) {
						hasStacks = true;
					}
				});
			}

			if (opts.stacked || hasStacks) {
				var valuesPerStack = {};

				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var key = [
						meta.type,
						// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
						((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
						meta.stack
					].join('.');

					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						if (valuesPerStack[key] === undefined) {
							valuesPerStack[key] = [];
						}

						helpers.each(dataset.data, function(rawValue, index) {
							var values = valuesPerStack[key];
							var value = +me.getRightValue(rawValue);
							// invalid, hidden and negative values are ignored
							if (isNaN(value) || meta.data[index].hidden || value < 0) {
								return;
							}
							values[index] = values[index] || 0;
							values[index] += value;
						});
					}
				});

				helpers.each(valuesPerStack, function(valuesForType) {
					if (valuesForType.length > 0) {
						var minVal = helpers.min(valuesForType);
						var maxVal = helpers.max(valuesForType);
						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
					}
				});

			} else {
				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							// invalid, hidden and negative values are ignored
							if (isNaN(value) || meta.data[index].hidden || value < 0) {
								return;
							}

							if (me.min === null) {
								me.min = value;
							} else if (value < me.min) {
								me.min = value;
							}

							if (me.max === null) {
								me.max = value;
							} else if (value > me.max) {
								me.max = value;
							}

							if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
								me.minNotZero = value;
							}
						});
					}
				});
			}

			// Common base implementation to handle ticks.min, ticks.max
			this.handleTickRangeOptions();
		},
		handleTickRangeOptions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var valueOrDefault = helpers.valueOrDefault;
			var DEFAULT_MIN = 1;
			var DEFAULT_MAX = 10;

			me.min = valueOrDefault(tickOpts.min, me.min);
			me.max = valueOrDefault(tickOpts.max, me.max);

			if (me.min === me.max) {
				if (me.min !== 0 && me.min !== null) {
					me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
					me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
				} else {
					me.min = DEFAULT_MIN;
					me.max = DEFAULT_MAX;
				}
			}
			if (me.min === null) {
				me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
			}
			if (me.max === null) {
				me.max = me.min !== 0
					? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
					: DEFAULT_MAX;
			}
			if (me.minNotZero === null) {
				if (me.min > 0) {
					me.minNotZero = me.min;
				} else if (me.max < 1) {
					me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
				} else {
					me.minNotZero = DEFAULT_MIN;
				}
			}
		},
		buildTicks: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var reverse = !me.isHorizontal();

			var generationOptions = {
				min: tickOpts.min,
				max: tickOpts.max
			};
			var ticks = me.ticks = generateTicks(generationOptions, me);

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);

			if (tickOpts.reverse) {
				reverse = !reverse;
				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
			if (reverse) {
				ticks.reverse();
			}
		},
		convertTicksToLabels: function() {
			this.tickValues = this.ticks.slice();

			Scale.prototype.convertTicksToLabels.call(this);
		},
		// Get the correct tooltip label
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		getPixelForTick: function(index) {
			return this.getPixelForValue(this.tickValues[index]);
		},
		/**
		 * Returns the value of the first tick.
		 * @param {Number} value - The minimum not zero value.
		 * @return {Number} The first tick value.
		 * @private
		 */
		_getFirstTickValue: function(value) {
			var exp = Math.floor(helpers.log10(value));
			var significand = Math.floor(value / Math.pow(10, exp));

			return significand * Math.pow(10, exp);
		},
		getPixelForValue: function(value) {
			var me = this;
			var reverse = me.options.ticks.reverse;
			var log10 = helpers.log10;
			var firstTickValue = me._getFirstTickValue(me.minNotZero);
			var offset = 0;
			var innerDimension, pixel, start, end, sign;

			value = +me.getRightValue(value);
			if (reverse) {
				start = me.end;
				end = me.start;
				sign = -1;
			} else {
				start = me.start;
				end = me.end;
				sign = 1;
			}
			if (me.isHorizontal()) {
				innerDimension = me.width;
				pixel = reverse ? me.right : me.left;
			} else {
				innerDimension = me.height;
				sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
				pixel = reverse ? me.top : me.bottom;
			}
			if (value !== start) {
				if (start === 0) { // include zero tick
					offset = helpers.getValueOrDefault(
						me.options.ticks.fontSize,
						Chart.defaults.global.defaultFontSize
					);
					innerDimension -= offset;
					start = firstTickValue;
				}
				if (value !== 0) {
					offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
				}
				pixel += sign * offset;
			}
			return pixel;
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var reverse = me.options.ticks.reverse;
			var log10 = helpers.log10;
			var firstTickValue = me._getFirstTickValue(me.minNotZero);
			var innerDimension, start, end, value;

			if (reverse) {
				start = me.end;
				end = me.start;
			} else {
				start = me.start;
				end = me.end;
			}
			if (me.isHorizontal()) {
				innerDimension = me.width;
				value = reverse ? me.right - pixel : pixel - me.left;
			} else {
				innerDimension = me.height;
				value = reverse ? pixel - me.top : me.bottom - pixel;
			}
			if (value !== start) {
				if (start === 0) { // include zero tick
					var offset = helpers.getValueOrDefault(
						me.options.ticks.fontSize,
						Chart.defaults.global.defaultFontSize
					);
					value -= offset;
					innerDimension -= offset;
					start = firstTickValue;
				}
				value *= log10(end) - log10(start);
				value /= innerDimension;
				value = Math.pow(10, log10(start) + value);
			}
			return value;
		}
	});

	scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
};

},{"../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.scale":"../node_modules/chart.js/src/core/core.scale.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js","../core/core.ticks":"../node_modules/chart.js/src/core/core.ticks.js"}],"../node_modules/chart.js/src/scales/scale.radialLinear.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var helpers = require('../helpers/index');
var scaleService = require('../core/core.scaleService');
var Ticks = require('../core/core.ticks');

module.exports = function(Chart) {

	var globalDefaults = defaults.global;

	var defaultConfig = {
		display: true,

		// Boolean - Whether to animate scaling the chart from the centre
		animate: true,
		position: 'chartArea',

		angleLines: {
			display: true,
			color: 'rgba(0, 0, 0, 0.1)',
			lineWidth: 1
		},

		gridLines: {
			circular: false
		},

		// label settings
		ticks: {
			// Boolean - Show a backdrop to the scale label
			showLabelBackdrop: true,

			// String - The colour of the label backdrop
			backdropColor: 'rgba(255,255,255,0.75)',

			// Number - The backdrop padding above & below the label in pixels
			backdropPaddingY: 2,

			// Number - The backdrop padding to the side of the label in pixels
			backdropPaddingX: 2,

			callback: Ticks.formatters.linear
		},

		pointLabels: {
			// Boolean - if true, show point labels
			display: true,

			// Number - Point label font size in pixels
			fontSize: 10,

			// Function - Used to convert point labels
			callback: function(label) {
				return label;
			}
		}
	};

	function getValueCount(scale) {
		var opts = scale.options;
		return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
	}

	function getPointLabelFontOptions(scale) {
		var pointLabelOptions = scale.options.pointLabels;
		var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
		var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
		var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
		var font = helpers.fontString(fontSize, fontStyle, fontFamily);

		return {
			size: fontSize,
			style: fontStyle,
			family: fontFamily,
			font: font
		};
	}

	function measureLabelSize(ctx, fontSize, label) {
		if (helpers.isArray(label)) {
			return {
				w: helpers.longestText(ctx, ctx.font, label),
				h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
			};
		}

		return {
			w: ctx.measureText(label).width,
			h: fontSize
		};
	}

	function determineLimits(angle, pos, size, min, max) {
		if (angle === min || angle === max) {
			return {
				start: pos - (size / 2),
				end: pos + (size / 2)
			};
		} else if (angle < min || angle > max) {
			return {
				start: pos - size - 5,
				end: pos
			};
		}

		return {
			start: pos,
			end: pos + size + 5
		};
	}

	/**
	 * Helper function to fit a radial linear scale with point labels
	 */
	function fitWithPointLabels(scale) {
		/*
		 * Right, this is really confusing and there is a lot of maths going on here
		 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
		 *
		 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
		 *
		 * Solution:
		 *
		 * We assume the radius of the polygon is half the size of the canvas at first
		 * at each index we check if the text overlaps.
		 *
		 * Where it does, we store that angle and that index.
		 *
		 * After finding the largest index and angle we calculate how much we need to remove
		 * from the shape radius to move the point inwards by that x.
		 *
		 * We average the left and right distances to get the maximum shape radius that can fit in the box
		 * along with labels.
		 *
		 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
		 * on each side, removing that from the size, halving it and adding the left x protrusion width.
		 *
		 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
		 * and position it in the most space efficient manner
		 *
		 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
		 */

		var plFont = getPointLabelFontOptions(scale);

		// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
		// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
		var furthestLimits = {
			r: scale.width,
			l: 0,
			t: scale.height,
			b: 0
		};
		var furthestAngles = {};
		var i, textSize, pointPosition;

		scale.ctx.font = plFont.font;
		scale._pointLabelSizes = [];

		var valueCount = getValueCount(scale);
		for (i = 0; i < valueCount; i++) {
			pointPosition = scale.getPointPosition(i, largestPossibleRadius);
			textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
			scale._pointLabelSizes[i] = textSize;

			// Add quarter circle to make degree 0 mean top of circle
			var angleRadians = scale.getIndexAngle(i);
			var angle = helpers.toDegrees(angleRadians) % 360;
			var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
			var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

			if (hLimits.start < furthestLimits.l) {
				furthestLimits.l = hLimits.start;
				furthestAngles.l = angleRadians;
			}

			if (hLimits.end > furthestLimits.r) {
				furthestLimits.r = hLimits.end;
				furthestAngles.r = angleRadians;
			}

			if (vLimits.start < furthestLimits.t) {
				furthestLimits.t = vLimits.start;
				furthestAngles.t = angleRadians;
			}

			if (vLimits.end > furthestLimits.b) {
				furthestLimits.b = vLimits.end;
				furthestAngles.b = angleRadians;
			}
		}

		scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
	}

	/**
	 * Helper function to fit a radial linear scale with no point labels
	 */
	function fit(scale) {
		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
		scale.drawingArea = Math.round(largestPossibleRadius);
		scale.setCenterPoint(0, 0, 0, 0);
	}

	function getTextAlignForAngle(angle) {
		if (angle === 0 || angle === 180) {
			return 'center';
		} else if (angle < 180) {
			return 'left';
		}

		return 'right';
	}

	function fillText(ctx, text, position, fontSize) {
		if (helpers.isArray(text)) {
			var y = position.y;
			var spacing = 1.5 * fontSize;

			for (var i = 0; i < text.length; ++i) {
				ctx.fillText(text[i], position.x, y);
				y += spacing;
			}
		} else {
			ctx.fillText(text, position.x, position.y);
		}
	}

	function adjustPointPositionForLabelHeight(angle, textSize, position) {
		if (angle === 90 || angle === 270) {
			position.y -= (textSize.h / 2);
		} else if (angle > 270 || angle < 90) {
			position.y -= textSize.h;
		}
	}

	function drawPointLabels(scale) {
		var ctx = scale.ctx;
		var opts = scale.options;
		var angleLineOpts = opts.angleLines;
		var pointLabelOpts = opts.pointLabels;

		ctx.lineWidth = angleLineOpts.lineWidth;
		ctx.strokeStyle = angleLineOpts.color;

		var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

		// Point Label Font
		var plFont = getPointLabelFontOptions(scale);

		ctx.textBaseline = 'top';

		for (var i = getValueCount(scale) - 1; i >= 0; i--) {
			if (angleLineOpts.display) {
				var outerPosition = scale.getPointPosition(i, outerDistance);
				ctx.beginPath();
				ctx.moveTo(scale.xCenter, scale.yCenter);
				ctx.lineTo(outerPosition.x, outerPosition.y);
				ctx.stroke();
				ctx.closePath();
			}

			if (pointLabelOpts.display) {
				// Extra 3px out for some label spacing
				var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

				// Keep this in loop since we may support array properties here
				var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
				ctx.font = plFont.font;
				ctx.fillStyle = pointLabelFontColor;

				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians);
				ctx.textAlign = getTextAlignForAngle(angle);
				adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
				fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
			}
		}
	}

	function drawRadiusLine(scale, gridLineOpts, radius, index) {
		var ctx = scale.ctx;
		ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
		ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

		if (scale.options.gridLines.circular) {
			// Draw circular arcs between the points
			ctx.beginPath();
			ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
			ctx.closePath();
			ctx.stroke();
		} else {
			// Draw straight lines connecting each index
			var valueCount = getValueCount(scale);

			if (valueCount === 0) {
				return;
			}

			ctx.beginPath();
			var pointPosition = scale.getPointPosition(0, radius);
			ctx.moveTo(pointPosition.x, pointPosition.y);

			for (var i = 1; i < valueCount; i++) {
				pointPosition = scale.getPointPosition(i, radius);
				ctx.lineTo(pointPosition.x, pointPosition.y);
			}

			ctx.closePath();
			ctx.stroke();
		}
	}

	function numberOrZero(param) {
		return helpers.isNumber(param) ? param : 0;
	}

	var LinearRadialScale = Chart.LinearScaleBase.extend({
		setDimensions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			// Set the unconstrained dimension before label rotation
			me.width = me.maxWidth;
			me.height = me.maxHeight;
			me.xCenter = Math.round(me.width / 2);
			me.yCenter = Math.round(me.height / 2);

			var minSize = helpers.min([me.height, me.width]);
			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
		},
		determineDataLimits: function() {
			var me = this;
			var chart = me.chart;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;

			helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
				if (chart.isDatasetVisible(datasetIndex)) {
					var meta = chart.getDatasetMeta(datasetIndex);

					helpers.each(dataset.data, function(rawValue, index) {
						var value = +me.getRightValue(rawValue);
						if (isNaN(value) || meta.data[index].hidden) {
							return;
						}

						min = Math.min(value, min);
						max = Math.max(value, max);
					});
				}
			});

			me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
			me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			me.handleTickRangeOptions();
		},
		getTickLimit: function() {
			var tickOpts = this.options.ticks;
			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
		},
		convertTicksToLabels: function() {
			var me = this;

			Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

			// Point labels
			me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
		},
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		fit: function() {
			if (this.options.pointLabels.display) {
				fitWithPointLabels(this);
			} else {
				fit(this);
			}
		},
		/**
		 * Set radius reductions and determine new radius and center point
		 * @private
		 */
		setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
			var me = this;
			var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
			var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
			var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
			var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

			radiusReductionLeft = numberOrZero(radiusReductionLeft);
			radiusReductionRight = numberOrZero(radiusReductionRight);
			radiusReductionTop = numberOrZero(radiusReductionTop);
			radiusReductionBottom = numberOrZero(radiusReductionBottom);

			me.drawingArea = Math.min(
				Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
				Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
			me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
		},
		setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
			var me = this;
			var maxRight = me.width - rightMovement - me.drawingArea;
			var maxLeft = leftMovement + me.drawingArea;
			var maxTop = topMovement + me.drawingArea;
			var maxBottom = me.height - bottomMovement - me.drawingArea;

			me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
			me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
		},

		getIndexAngle: function(index) {
			var angleMultiplier = (Math.PI * 2) / getValueCount(this);
			var startAngle = this.chart.options && this.chart.options.startAngle ?
				this.chart.options.startAngle :
				0;

			var startAngleRadians = startAngle * Math.PI * 2 / 360;

			// Start from the top instead of right, so remove a quarter of the circle
			return index * angleMultiplier + startAngleRadians;
		},
		getDistanceFromCenterForValue: function(value) {
			var me = this;

			if (value === null) {
				return 0; // null always in center
			}

			// Take into account half font size + the yPadding of the top value
			var scalingFactor = me.drawingArea / (me.max - me.min);
			if (me.options.ticks.reverse) {
				return (me.max - value) * scalingFactor;
			}
			return (value - me.min) * scalingFactor;
		},
		getPointPosition: function(index, distanceFromCenter) {
			var me = this;
			var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
			return {
				x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
				y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
			};
		},
		getPointPositionForValue: function(index, value) {
			return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
		},

		getBasePosition: function() {
			var me = this;
			var min = me.min;
			var max = me.max;

			return me.getPointPositionForValue(0,
				me.beginAtZero ? 0 :
				min < 0 && max < 0 ? max :
				min > 0 && max > 0 ? min :
				0);
		},

		draw: function() {
			var me = this;
			var opts = me.options;
			var gridLineOpts = opts.gridLines;
			var tickOpts = opts.ticks;
			var valueOrDefault = helpers.valueOrDefault;

			if (opts.display) {
				var ctx = me.ctx;
				var startAngle = this.getIndexAngle(0);

				// Tick Font
				var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
				var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
				var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

				helpers.each(me.ticks, function(label, index) {
					// Don't draw a centre value (if it is minimum)
					if (index > 0 || tickOpts.reverse) {
						var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

						// Draw circular lines around the scale
						if (gridLineOpts.display && index !== 0) {
							drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
						}

						if (tickOpts.display) {
							var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = tickLabelFont;

							ctx.save();
							ctx.translate(me.xCenter, me.yCenter);
							ctx.rotate(startAngle);

							if (tickOpts.showLabelBackdrop) {
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = tickOpts.backdropColor;
								ctx.fillRect(
									-labelWidth / 2 - tickOpts.backdropPaddingX,
									-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
									labelWidth + tickOpts.backdropPaddingX * 2,
									tickFontSize + tickOpts.backdropPaddingY * 2
								);
							}

							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';
							ctx.fillStyle = tickFontColor;
							ctx.fillText(label, 0, -yCenterOffset);
							ctx.restore();
						}
					}
				});

				if (opts.angleLines.display || opts.pointLabels.display) {
					drawPointLabels(me);
				}
			}
		}
	});

	scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js","../core/core.ticks":"../node_modules/chart.js/src/core/core.ticks.js"}],"../node_modules/moment/moment.js":[function(require,module,exports) {
var define;
var global = arguments[3];
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],"../node_modules/chart.js/src/scales/scale.time.js":[function(require,module,exports) {
/* global window: false */
'use strict';

var moment = require('moment');
moment = typeof moment === 'function' ? moment : window.moment;

var defaults = require('../core/core.defaults');
var helpers = require('../helpers/index');
var Scale = require('../core/core.scale');
var scaleService = require('../core/core.scaleService');

// Integer constants are from the ES6 spec.
var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

var INTERVALS = {
	millisecond: {
		common: true,
		size: 1,
		steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
	},
	second: {
		common: true,
		size: 1000,
		steps: [1, 2, 5, 10, 15, 30]
	},
	minute: {
		common: true,
		size: 60000,
		steps: [1, 2, 5, 10, 15, 30]
	},
	hour: {
		common: true,
		size: 3600000,
		steps: [1, 2, 3, 6, 12]
	},
	day: {
		common: true,
		size: 86400000,
		steps: [1, 2, 5]
	},
	week: {
		common: false,
		size: 604800000,
		steps: [1, 2, 3, 4]
	},
	month: {
		common: true,
		size: 2.628e9,
		steps: [1, 2, 3]
	},
	quarter: {
		common: false,
		size: 7.884e9,
		steps: [1, 2, 3, 4]
	},
	year: {
		common: true,
		size: 3.154e10
	}
};

var UNITS = Object.keys(INTERVALS);

function sorter(a, b) {
	return a - b;
}

function arrayUnique(items) {
	var hash = {};
	var out = [];
	var i, ilen, item;

	for (i = 0, ilen = items.length; i < ilen; ++i) {
		item = items[i];
		if (!hash[item]) {
			hash[item] = true;
			out.push(item);
		}
	}

	return out;
}

/**
 * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
 * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
 * extremity (left + width or top + height). Note that it would be more optimized to directly
 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
 *
 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
 * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
 * If 'series', timestamps will be positioned at the same distance from each other. In this
 * case, only timestamps that break the time linearity are registered, meaning that in the
 * best case, all timestamps are linear, the table contains only min and max.
 */
function buildLookupTable(timestamps, min, max, distribution) {
	if (distribution === 'linear' || !timestamps.length) {
		return [
			{time: min, pos: 0},
			{time: max, pos: 1}
		];
	}

	var table = [];
	var items = [min];
	var i, ilen, prev, curr, next;

	for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
		curr = timestamps[i];
		if (curr > min && curr < max) {
			items.push(curr);
		}
	}

	items.push(max);

	for (i = 0, ilen = items.length; i < ilen; ++i) {
		next = items[i + 1];
		prev = items[i - 1];
		curr = items[i];

		// only add points that breaks the scale linearity
		if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
			table.push({time: curr, pos: i / (ilen - 1)});
		}
	}

	return table;
}

// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
function lookup(table, key, value) {
	var lo = 0;
	var hi = table.length - 1;
	var mid, i0, i1;

	while (lo >= 0 && lo <= hi) {
		mid = (lo + hi) >> 1;
		i0 = table[mid - 1] || null;
		i1 = table[mid];

		if (!i0) {
			// given value is outside table (before first item)
			return {lo: null, hi: i1};
		} else if (i1[key] < value) {
			lo = mid + 1;
		} else if (i0[key] > value) {
			hi = mid - 1;
		} else {
			return {lo: i0, hi: i1};
		}
	}

	// given value is outside table (after last item)
	return {lo: i1, hi: null};
}

/**
 * Linearly interpolates the given source `value` using the table items `skey` values and
 * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
 * index [0, 1] or [n - 1, n] are used for the interpolation.
 */
function interpolate(table, skey, sval, tkey) {
	var range = lookup(table, skey, sval);

	// Note: the lookup table ALWAYS contains at least 2 items (min and max)
	var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
	var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

	var span = next[skey] - prev[skey];
	var ratio = span ? (sval - prev[skey]) / span : 0;
	var offset = (next[tkey] - prev[tkey]) * ratio;

	return prev[tkey] + offset;
}

/**
 * Convert the given value to a moment object using the given time options.
 * @see http://momentjs.com/docs/#/parsing/
 */
function momentify(value, options) {
	var parser = options.parser;
	var format = options.parser || options.format;

	if (typeof parser === 'function') {
		return parser(value);
	}

	if (typeof value === 'string' && typeof format === 'string') {
		return moment(value, format);
	}

	if (!(value instanceof moment)) {
		value = moment(value);
	}

	if (value.isValid()) {
		return value;
	}

	// Labels are in an incompatible moment format and no `parser` has been provided.
	// The user might still use the deprecated `format` option to convert his inputs.
	if (typeof format === 'function') {
		return format(value);
	}

	return value;
}

function parse(input, scale) {
	if (helpers.isNullOrUndef(input)) {
		return null;
	}

	var options = scale.options.time;
	var value = momentify(scale.getRightValue(input), options);
	if (!value.isValid()) {
		return null;
	}

	if (options.round) {
		value.startOf(options.round);
	}

	return value.valueOf();
}

/**
 * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
 * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
 */
function determineStepSize(min, max, unit, capacity) {
	var range = max - min;
	var interval = INTERVALS[unit];
	var milliseconds = interval.size;
	var steps = interval.steps;
	var i, ilen, factor;

	if (!steps) {
		return Math.ceil(range / (capacity * milliseconds));
	}

	for (i = 0, ilen = steps.length; i < ilen; ++i) {
		factor = steps[i];
		if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
			break;
		}
	}

	return factor;
}

/**
 * Figures out what unit results in an appropriate number of auto-generated ticks
 */
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
	var ilen = UNITS.length;
	var i, interval, factor;

	for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
		interval = INTERVALS[UNITS[i]];
		factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

		if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
			return UNITS[i];
		}
	}

	return UNITS[ilen - 1];
}

/**
 * Figures out what unit to format a set of ticks with
 */
function determineUnitForFormatting(ticks, minUnit, min, max) {
	var duration = moment.duration(moment(max).diff(moment(min)));
	var ilen = UNITS.length;
	var i, unit;

	for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
		unit = UNITS[i];
		if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
			return unit;
		}
	}

	return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}

function determineMajorUnit(unit) {
	for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
		if (INTERVALS[UNITS[i]].common) {
			return UNITS[i];
		}
	}
}

/**
 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
 * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
 * Important: this method can return ticks outside the min and max range, it's the
 * responsibility of the calling code to clamp values if needed.
 */
function generate(min, max, capacity, options) {
	var timeOpts = options.time;
	var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
	var major = determineMajorUnit(minor);
	var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
	var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
	var majorTicksEnabled = options.ticks.major.enabled;
	var interval = INTERVALS[minor];
	var first = moment(min);
	var last = moment(max);
	var ticks = [];
	var time;

	if (!stepSize) {
		stepSize = determineStepSize(min, max, minor, capacity);
	}

	// For 'week' unit, handle the first day of week option
	if (weekday) {
		first = first.isoWeekday(weekday);
		last = last.isoWeekday(weekday);
	}

	// Align first/last ticks on unit
	first = first.startOf(weekday ? 'day' : minor);
	last = last.startOf(weekday ? 'day' : minor);

	// Make sure that the last tick include max
	if (last < max) {
		last.add(1, minor);
	}

	time = moment(first);

	if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
		// Align the first tick on the previous `minor` unit aligned on the `major` unit:
		// we first aligned time on the previous `major` unit then add the number of full
		// stepSize there is between first and the previous major time.
		time.startOf(major);
		time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
	}

	for (; time < last; time.add(stepSize, minor)) {
		ticks.push(+time);
	}

	ticks.push(+time);

	return ticks;
}

/**
 * Returns the right and left offsets from edges in the form of {left, right}.
 * Offsets are added when the `offset` option is true.
 */
function computeOffsets(table, ticks, min, max, options) {
	var left = 0;
	var right = 0;
	var upper, lower;

	if (options.offset && ticks.length) {
		if (!options.time.min) {
			upper = ticks.length > 1 ? ticks[1] : max;
			lower = ticks[0];
			left = (
				interpolate(table, 'time', upper, 'pos') -
				interpolate(table, 'time', lower, 'pos')
			) / 2;
		}
		if (!options.time.max) {
			upper = ticks[ticks.length - 1];
			lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
			right = (
				interpolate(table, 'time', upper, 'pos') -
				interpolate(table, 'time', lower, 'pos')
			) / 2;
		}
	}

	return {left: left, right: right};
}

function ticksFromTimestamps(values, majorUnit) {
	var ticks = [];
	var i, ilen, value, major;

	for (i = 0, ilen = values.length; i < ilen; ++i) {
		value = values[i];
		major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

		ticks.push({
			value: value,
			major: major
		});
	}

	return ticks;
}

function determineLabelFormat(data, timeOpts) {
	var i, momentDate, hasTime;
	var ilen = data.length;

	// find the label with the most parts (milliseconds, minutes, etc.)
	// format all labels with the same level of detail as the most specific label
	for (i = 0; i < ilen; i++) {
		momentDate = momentify(data[i], timeOpts);
		if (momentDate.millisecond() !== 0) {
			return 'MMM D, YYYY h:mm:ss.SSS a';
		}
		if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
			hasTime = true;
		}
	}
	if (hasTime) {
		return 'MMM D, YYYY h:mm:ss a';
	}
	return 'MMM D, YYYY';
}

module.exports = function() {

	var defaultConfig = {
		position: 'bottom',

		/**
		 * Data distribution along the scale:
		 * - 'linear': data are spread according to their time (distances can vary),
		 * - 'series': data are spread at the same distance from each other.
		 * @see https://github.com/chartjs/Chart.js/pull/4507
		 * @since 2.7.0
		 */
		distribution: 'linear',

		/**
		 * Scale boundary strategy (bypassed by min/max time options)
		 * - `data`: make sure data are fully visible, ticks outside are removed
		 * - `ticks`: make sure ticks are fully visible, data outside are truncated
		 * @see https://github.com/chartjs/Chart.js/pull/4556
		 * @since 2.7.0
		 */
		bounds: 'data',

		time: {
			parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
			format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
			unit: false, // false == automatic or override with week, month, year, etc.
			round: false, // none, or override with week, month, year, etc.
			displayFormat: false, // DEPRECATED
			isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
			minUnit: 'millisecond',

			// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
			displayFormats: {
				millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
				second: 'h:mm:ss a', // 11:20:01 AM
				minute: 'h:mm a', // 11:20 AM
				hour: 'hA', // 5PM
				day: 'MMM D', // Sep 4
				week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
				month: 'MMM YYYY', // Sept 2015
				quarter: '[Q]Q - YYYY', // Q3
				year: 'YYYY' // 2015
			},
		},
		ticks: {
			autoSkip: false,

			/**
			 * Ticks generation input values:
			 * - 'auto': generates "optimal" ticks based on scale size and time options.
			 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
			 * - 'labels': generates ticks from user given `data.labels` values ONLY.
			 * @see https://github.com/chartjs/Chart.js/pull/4507
			 * @since 2.7.0
			 */
			source: 'auto',

			major: {
				enabled: false
			}
		}
	};

	var TimeScale = Scale.extend({
		initialize: function() {
			if (!moment) {
				throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
			}

			this.mergeTicksOptions();

			Scale.prototype.initialize.call(this);
		},

		update: function() {
			var me = this;
			var options = me.options;

			// DEPRECATIONS: output a message only one time per update
			if (options.time && options.time.format) {
				console.warn('options.time.format is deprecated and replaced by options.time.parser.');
			}

			return Scale.prototype.update.apply(me, arguments);
		},

		/**
		 * Allows data to be referenced via 't' attribute
		 */
		getRightValue: function(rawValue) {
			if (rawValue && rawValue.t !== undefined) {
				rawValue = rawValue.t;
			}
			return Scale.prototype.getRightValue.call(this, rawValue);
		},

		determineDataLimits: function() {
			var me = this;
			var chart = me.chart;
			var timeOpts = me.options.time;
			var unit = timeOpts.unit || 'day';
			var min = MAX_INTEGER;
			var max = MIN_INTEGER;
			var timestamps = [];
			var datasets = [];
			var labels = [];
			var i, j, ilen, jlen, data, timestamp;

			// Convert labels to timestamps
			for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
				labels.push(parse(chart.data.labels[i], me));
			}

			// Convert data to timestamps
			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				if (chart.isDatasetVisible(i)) {
					data = chart.data.datasets[i].data;

					// Let's consider that all data have the same format.
					if (helpers.isObject(data[0])) {
						datasets[i] = [];

						for (j = 0, jlen = data.length; j < jlen; ++j) {
							timestamp = parse(data[j], me);
							timestamps.push(timestamp);
							datasets[i][j] = timestamp;
						}
					} else {
						timestamps.push.apply(timestamps, labels);
						datasets[i] = labels.slice(0);
					}
				} else {
					datasets[i] = [];
				}
			}

			if (labels.length) {
				// Sort labels **after** data have been converted
				labels = arrayUnique(labels).sort(sorter);
				min = Math.min(min, labels[0]);
				max = Math.max(max, labels[labels.length - 1]);
			}

			if (timestamps.length) {
				timestamps = arrayUnique(timestamps).sort(sorter);
				min = Math.min(min, timestamps[0]);
				max = Math.max(max, timestamps[timestamps.length - 1]);
			}

			min = parse(timeOpts.min, me) || min;
			max = parse(timeOpts.max, me) || max;

			// In case there is no valid min/max, set limits based on unit time option
			min = min === MAX_INTEGER ? +moment().startOf(unit) : min;
			max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;

			// Make sure that max is strictly higher than min (required by the lookup table)
			me.min = Math.min(min, max);
			me.max = Math.max(min + 1, max);

			// PRIVATE
			me._horizontal = me.isHorizontal();
			me._table = [];
			me._timestamps = {
				data: timestamps,
				datasets: datasets,
				labels: labels
			};
		},

		buildTicks: function() {
			var me = this;
			var min = me.min;
			var max = me.max;
			var options = me.options;
			var timeOpts = options.time;
			var timestamps = [];
			var ticks = [];
			var i, ilen, timestamp;

			switch (options.ticks.source) {
			case 'data':
				timestamps = me._timestamps.data;
				break;
			case 'labels':
				timestamps = me._timestamps.labels;
				break;
			case 'auto':
			default:
				timestamps = generate(min, max, me.getLabelCapacity(min), options);
			}

			if (options.bounds === 'ticks' && timestamps.length) {
				min = timestamps[0];
				max = timestamps[timestamps.length - 1];
			}

			// Enforce limits with user min/max options
			min = parse(timeOpts.min, me) || min;
			max = parse(timeOpts.max, me) || max;

			// Remove ticks outside the min/max range
			for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
				timestamp = timestamps[i];
				if (timestamp >= min && timestamp <= max) {
					ticks.push(timestamp);
				}
			}

			me.min = min;
			me.max = max;

			// PRIVATE
			me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
			me._majorUnit = determineMajorUnit(me._unit);
			me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
			me._offsets = computeOffsets(me._table, ticks, min, max, options);
			me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);

			return ticksFromTimestamps(ticks, me._majorUnit);
		},

		getLabelForIndex: function(index, datasetIndex) {
			var me = this;
			var data = me.chart.data;
			var timeOpts = me.options.time;
			var label = data.labels && index < data.labels.length ? data.labels[index] : '';
			var value = data.datasets[datasetIndex].data[index];

			if (helpers.isObject(value)) {
				label = me.getRightValue(value);
			}
			if (timeOpts.tooltipFormat) {
				return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
			}
			if (typeof label === 'string') {
				return label;
			}

			return momentify(label, timeOpts).format(me._labelFormat);
		},

		/**
		 * Function to format an individual tick mark
		 * @private
		 */
		tickFormatFunction: function(tick, index, ticks, formatOverride) {
			var me = this;
			var options = me.options;
			var time = tick.valueOf();
			var formats = options.time.displayFormats;
			var minorFormat = formats[me._unit];
			var majorUnit = me._majorUnit;
			var majorFormat = formats[majorUnit];
			var majorTime = tick.clone().startOf(majorUnit).valueOf();
			var majorTickOpts = options.ticks.major;
			var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
			var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
			var tickOpts = major ? majorTickOpts : options.ticks.minor;
			var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

			return formatter ? formatter(label, index, ticks) : label;
		},

		convertTicksToLabels: function(ticks) {
			var labels = [];
			var i, ilen;

			for (i = 0, ilen = ticks.length; i < ilen; ++i) {
				labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
			}

			return labels;
		},

		/**
		 * @private
		 */
		getPixelForOffset: function(time) {
			var me = this;
			var size = me._horizontal ? me.width : me.height;
			var start = me._horizontal ? me.left : me.top;
			var pos = interpolate(me._table, 'time', time, 'pos');

			return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
		},

		getPixelForValue: function(value, index, datasetIndex) {
			var me = this;
			var time = null;

			if (index !== undefined && datasetIndex !== undefined) {
				time = me._timestamps.datasets[datasetIndex][index];
			}

			if (time === null) {
				time = parse(value, me);
			}

			if (time !== null) {
				return me.getPixelForOffset(time);
			}
		},

		getPixelForTick: function(index) {
			var ticks = this.getTicks();
			return index >= 0 && index < ticks.length ?
				this.getPixelForOffset(ticks[index].value) :
				null;
		},

		getValueForPixel: function(pixel) {
			var me = this;
			var size = me._horizontal ? me.width : me.height;
			var start = me._horizontal ? me.left : me.top;
			var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
			var time = interpolate(me._table, 'pos', pos, 'time');

			return moment(time);
		},

		/**
		 * Crude approximation of what the label width might be
		 * @private
		 */
		getLabelWidth: function(label) {
			var me = this;
			var ticksOpts = me.options.ticks;
			var tickLabelWidth = me.ctx.measureText(label).width;
			var angle = helpers.toRadians(ticksOpts.maxRotation);
			var cosRotation = Math.cos(angle);
			var sinRotation = Math.sin(angle);
			var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

			return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
		},

		/**
		 * @private
		 */
		getLabelCapacity: function(exampleTime) {
			var me = this;

			var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation

			var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
			var tickLabelWidth = me.getLabelWidth(exampleLabel);
			var innerWidth = me.isHorizontal() ? me.width : me.height;

			var capacity = Math.floor(innerWidth / tickLabelWidth);
			return capacity > 0 ? capacity : 1;
		}
	});

	scaleService.registerScaleType('time', TimeScale, defaultConfig);
};

},{"moment":"../node_modules/moment/moment.js","../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.scale":"../node_modules/chart.js/src/core/core.scale.js","../core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js"}],"../node_modules/chart.js/src/controllers/controller.bar.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('bar', {
	hover: {
		mode: 'label'
	},

	scales: {
		xAxes: [{
			type: 'category',

			// Specific to Bar Controller
			categoryPercentage: 0.8,
			barPercentage: 0.9,

			// offset settings
			offset: true,

			// grid line settings
			gridLines: {
				offsetGridLines: true
			}
		}],

		yAxes: [{
			type: 'linear'
		}]
	}
});

defaults._set('horizontalBar', {
	hover: {
		mode: 'index',
		axis: 'y'
	},

	scales: {
		xAxes: [{
			type: 'linear',
			position: 'bottom'
		}],

		yAxes: [{
			position: 'left',
			type: 'category',

			// Specific to Horizontal Bar Controller
			categoryPercentage: 0.8,
			barPercentage: 0.9,

			// offset settings
			offset: true,

			// grid line settings
			gridLines: {
				offsetGridLines: true
			}
		}]
	},

	elements: {
		rectangle: {
			borderSkipped: 'left'
		}
	},

	tooltips: {
		callbacks: {
			title: function(item, data) {
				// Pick first xLabel for now
				var title = '';

				if (item.length > 0) {
					if (item[0].yLabel) {
						title = item[0].yLabel;
					} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
						title = data.labels[item[0].index];
					}
				}

				return title;
			},

			label: function(item, data) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				return datasetLabel + ': ' + item.xLabel;
			}
		},
		mode: 'index',
		axis: 'y'
	}
});

/**
 * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
 * @private
 */
function computeMinSampleSize(scale, pixels) {
	var min = scale.isHorizontal() ? scale.width : scale.height;
	var ticks = scale.getTicks();
	var prev, curr, i, ilen;

	for (i = 1, ilen = pixels.length; i < ilen; ++i) {
		min = Math.min(min, pixels[i] - pixels[i - 1]);
	}

	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
		curr = scale.getPixelForTick(i);
		min = i > 0 ? Math.min(min, curr - prev) : min;
		prev = curr;
	}

	return min;
}

/**
 * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
 * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
 * mode currently always generates bars equally sized (until we introduce scriptable options?).
 * @private
 */
function computeFitCategoryTraits(index, ruler, options) {
	var thickness = options.barThickness;
	var count = ruler.stackCount;
	var curr = ruler.pixels[index];
	var size, ratio;

	if (helpers.isNullOrUndef(thickness)) {
		size = ruler.min * options.categoryPercentage;
		ratio = options.barPercentage;
	} else {
		// When bar thickness is enforced, category and bar percentages are ignored.
		// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
		// and deprecate barPercentage since this value is ignored when thickness is absolute.
		size = thickness * count;
		ratio = 1;
	}

	return {
		chunk: size / count,
		ratio: ratio,
		start: curr - (size / 2)
	};
}

/**
 * Computes an "optimal" category that globally arranges bars side by side (no gap when
 * percentage options are 1), based on the previous and following categories. This mode
 * generates bars with different widths when data are not evenly spaced.
 * @private
 */
function computeFlexCategoryTraits(index, ruler, options) {
	var pixels = ruler.pixels;
	var curr = pixels[index];
	var prev = index > 0 ? pixels[index - 1] : null;
	var next = index < pixels.length - 1 ? pixels[index + 1] : null;
	var percent = options.categoryPercentage;
	var start, size;

	if (prev === null) {
		// first data: its size is double based on the next point or,
		// if it's also the last data, we use the scale end extremity.
		prev = curr - (next === null ? ruler.end - curr : next - curr);
	}

	if (next === null) {
		// last data: its size is also double based on the previous point.
		next = curr + curr - prev;
	}

	start = curr - ((curr - prev) / 2) * percent;
	size = ((next - prev) / 2) * percent;

	return {
		chunk: size / ruler.stackCount,
		ratio: options.barPercentage,
		start: start
	};
}

module.exports = function(Chart) {

	Chart.controllers.bar = Chart.DatasetController.extend({

		dataElementType: elements.Rectangle,

		initialize: function() {
			var me = this;
			var meta;

			Chart.DatasetController.prototype.initialize.apply(me, arguments);

			meta = me.getMeta();
			meta.stack = me.getDataset().stack;
			meta.bar = true;
		},

		update: function(reset) {
			var me = this;
			var rects = me.getMeta().data;
			var i, ilen;

			me._ruler = me.getRuler();

			for (i = 0, ilen = rects.length; i < ilen; ++i) {
				me.updateElement(rects[i], i, reset);
			}
		},

		updateElement: function(rectangle, index, reset) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var dataset = me.getDataset();
			var custom = rectangle.custom || {};
			var rectangleOptions = chart.options.elements.rectangle;

			rectangle._xScale = me.getScaleForId(meta.xAxisID);
			rectangle._yScale = me.getScaleForId(meta.yAxisID);
			rectangle._datasetIndex = me.index;
			rectangle._index = index;

			rectangle._model = {
				datasetLabel: dataset.label,
				label: chart.data.labels[index],
				borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
				backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
				borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
				borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
			};

			me.updateElementGeometry(rectangle, index, reset);

			rectangle.pivot();
		},

		/**
		 * @private
		 */
		updateElementGeometry: function(rectangle, index, reset) {
			var me = this;
			var model = rectangle._model;
			var vscale = me.getValueScale();
			var base = vscale.getBasePixel();
			var horizontal = vscale.isHorizontal();
			var ruler = me._ruler || me.getRuler();
			var vpixels = me.calculateBarValuePixels(me.index, index);
			var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

			model.horizontal = horizontal;
			model.base = reset ? base : vpixels.base;
			model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
			model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
			model.height = horizontal ? ipixels.size : undefined;
			model.width = horizontal ? undefined : ipixels.size;
		},

		/**
		 * @private
		 */
		getValueScaleId: function() {
			return this.getMeta().yAxisID;
		},

		/**
		 * @private
		 */
		getIndexScaleId: function() {
			return this.getMeta().xAxisID;
		},

		/**
		 * @private
		 */
		getValueScale: function() {
			return this.getScaleForId(this.getValueScaleId());
		},

		/**
		 * @private
		 */
		getIndexScale: function() {
			return this.getScaleForId(this.getIndexScaleId());
		},

		/**
		 * Returns the stacks based on groups and bar visibility.
		 * @param {Number} [last] - The dataset index
		 * @returns {Array} The stack list
		 * @private
		 */
		_getStacks: function(last) {
			var me = this;
			var chart = me.chart;
			var scale = me.getIndexScale();
			var stacked = scale.options.stacked;
			var ilen = last === undefined ? chart.data.datasets.length : last + 1;
			var stacks = [];
			var i, meta;

			for (i = 0; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				if (meta.bar && chart.isDatasetVisible(i) &&
					(stacked === false ||
					(stacked === true && stacks.indexOf(meta.stack) === -1) ||
					(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
					stacks.push(meta.stack);
				}
			}

			return stacks;
		},

		/**
		 * Returns the effective number of stacks based on groups and bar visibility.
		 * @private
		 */
		getStackCount: function() {
			return this._getStacks().length;
		},

		/**
		 * Returns the stack index for the given dataset based on groups and bar visibility.
		 * @param {Number} [datasetIndex] - The dataset index
		 * @param {String} [name] - The stack name to find
		 * @returns {Number} The stack index
		 * @private
		 */
		getStackIndex: function(datasetIndex, name) {
			var stacks = this._getStacks(datasetIndex);
			var index = (name !== undefined)
				? stacks.indexOf(name)
				: -1; // indexOf returns -1 if element is not present

			return (index === -1)
				? stacks.length - 1
				: index;
		},

		/**
		 * @private
		 */
		getRuler: function() {
			var me = this;
			var scale = me.getIndexScale();
			var stackCount = me.getStackCount();
			var datasetIndex = me.index;
			var isHorizontal = scale.isHorizontal();
			var start = isHorizontal ? scale.left : scale.top;
			var end = start + (isHorizontal ? scale.width : scale.height);
			var pixels = [];
			var i, ilen, min;

			for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
				pixels.push(scale.getPixelForValue(null, i, datasetIndex));
			}

			min = helpers.isNullOrUndef(scale.options.barThickness)
				? computeMinSampleSize(scale, pixels)
				: -1;

			return {
				min: min,
				pixels: pixels,
				start: start,
				end: end,
				stackCount: stackCount,
				scale: scale
			};
		},

		/**
		 * Note: pixel values are not clamped to the scale area.
		 * @private
		 */
		calculateBarValuePixels: function(datasetIndex, index) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var scale = me.getValueScale();
			var datasets = chart.data.datasets;
			var value = scale.getRightValue(datasets[datasetIndex].data[index]);
			var stacked = scale.options.stacked;
			var stack = meta.stack;
			var start = 0;
			var i, imeta, ivalue, base, head, size;

			if (stacked || (stacked === undefined && stack !== undefined)) {
				for (i = 0; i < datasetIndex; ++i) {
					imeta = chart.getDatasetMeta(i);

					if (imeta.bar &&
						imeta.stack === stack &&
						imeta.controller.getValueScaleId() === scale.id &&
						chart.isDatasetVisible(i)) {

						ivalue = scale.getRightValue(datasets[i].data[index]);
						if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
							start += ivalue;
						}
					}
				}
			}

			base = scale.getPixelForValue(start);
			head = scale.getPixelForValue(start + value);
			size = (head - base) / 2;

			return {
				size: size,
				base: base,
				head: head,
				center: head + size / 2
			};
		},

		/**
		 * @private
		 */
		calculateBarIndexPixels: function(datasetIndex, index, ruler) {
			var me = this;
			var options = ruler.scale.options;
			var range = options.barThickness === 'flex'
				? computeFlexCategoryTraits(index, ruler, options)
				: computeFitCategoryTraits(index, ruler, options);

			var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
			var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
			var size = Math.min(
				helpers.valueOrDefault(options.maxBarThickness, Infinity),
				range.chunk * range.ratio);

			return {
				base: center - size / 2,
				head: center + size / 2,
				center: center,
				size: size
			};
		},

		draw: function() {
			var me = this;
			var chart = me.chart;
			var scale = me.getValueScale();
			var rects = me.getMeta().data;
			var dataset = me.getDataset();
			var ilen = rects.length;
			var i = 0;

			helpers.canvas.clipArea(chart.ctx, chart.chartArea);

			for (; i < ilen; ++i) {
				if (!isNaN(scale.getRightValue(dataset.data[i]))) {
					rects[i].draw();
				}
			}

			helpers.canvas.unclipArea(chart.ctx);
		},
	});

	Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
		/**
		 * @private
		 */
		getValueScaleId: function() {
			return this.getMeta().xAxisID;
		},

		/**
		 * @private
		 */
		getIndexScaleId: function() {
			return this.getMeta().yAxisID;
		}
	});
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/controllers/controller.bubble.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('bubble', {
	hover: {
		mode: 'single'
	},

	scales: {
		xAxes: [{
			type: 'linear', // bubble should probably use a linear scale by default
			position: 'bottom',
			id: 'x-axis-0' // need an ID so datasets can reference the scale
		}],
		yAxes: [{
			type: 'linear',
			position: 'left',
			id: 'y-axis-0'
		}]
	},

	tooltips: {
		callbacks: {
			title: function() {
				// Title doesn't make sense for scatter since we format the data as a point
				return '';
			},
			label: function(item, data) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				var dataPoint = data.datasets[item.datasetIndex].data[item.index];
				return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
			}
		}
	}
});


module.exports = function(Chart) {

	Chart.controllers.bubble = Chart.DatasetController.extend({
		/**
		 * @protected
		 */
		dataElementType: elements.Point,

		/**
		 * @protected
		 */
		update: function(reset) {
			var me = this;
			var meta = me.getMeta();
			var points = meta.data;

			// Update Points
			helpers.each(points, function(point, index) {
				me.updateElement(point, index, reset);
			});
		},

		/**
		 * @protected
		 */
		updateElement: function(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);
			var options = me._resolveElementOptions(point, index);
			var data = me.getDataset().data[index];
			var dsIndex = me.index;

			var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
			var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

			point._xScale = xScale;
			point._yScale = yScale;
			point._options = options;
			point._datasetIndex = dsIndex;
			point._index = index;
			point._model = {
				backgroundColor: options.backgroundColor,
				borderColor: options.borderColor,
				borderWidth: options.borderWidth,
				hitRadius: options.hitRadius,
				pointStyle: options.pointStyle,
				rotation: options.rotation,
				radius: reset ? 0 : options.radius,
				skip: custom.skip || isNaN(x) || isNaN(y),
				x: x,
				y: y,
			};

			point.pivot();
		},

		/**
		 * @protected
		 */
		setHoverStyle: function(point) {
			var model = point._model;
			var options = point._options;
			point.$previousStyle = {
				backgroundColor: model.backgroundColor,
				borderColor: model.borderColor,
				borderWidth: model.borderWidth,
				radius: model.radius
			};
			model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
			model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
			model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
			model.radius = options.radius + options.hoverRadius;
		},

		/**
		 * @private
		 */
		_resolveElementOptions: function(point, index) {
			var me = this;
			var chart = me.chart;
			var datasets = chart.data.datasets;
			var dataset = datasets[me.index];
			var custom = point.custom || {};
			var options = chart.options.elements.point;
			var resolve = helpers.options.resolve;
			var data = dataset.data[index];
			var values = {};
			var i, ilen, key;

			// Scriptable options
			var context = {
				chart: chart,
				dataIndex: index,
				dataset: dataset,
				datasetIndex: me.index
			};

			var keys = [
				'backgroundColor',
				'borderColor',
				'borderWidth',
				'hoverBackgroundColor',
				'hoverBorderColor',
				'hoverBorderWidth',
				'hoverRadius',
				'hitRadius',
				'pointStyle',
				'rotation'
			];

			for (i = 0, ilen = keys.length; i < ilen; ++i) {
				key = keys[i];
				values[key] = resolve([
					custom[key],
					dataset[key],
					options[key]
				], context, index);
			}

			// Custom radius resolution
			values.radius = resolve([
				custom.radius,
				data ? data.r : undefined,
				dataset.radius,
				options.radius
			], context, index);
			return values;
		}
	});
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/controllers/controller.doughnut.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('doughnut', {
	animation: {
		// Boolean - Whether we animate the rotation of the Doughnut
		animateRotate: true,
		// Boolean - Whether we animate scaling the Doughnut from the centre
		animateScale: false
	},
	hover: {
		mode: 'single'
	},
	legendCallback: function(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = data.datasets;
		var labels = data.labels;

		if (datasets.length) {
			for (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				if (labels[i]) {
					text.push(labels[i]);
				}
				text.push('</li>');
			}
		}

		text.push('</ul>');
		return text.join('');
	},
	legend: {
		labels: {
			generateLabels: function(chart) {
				var data = chart.data;
				if (data.labels.length && data.datasets.length) {
					return data.labels.map(function(label, i) {
						var meta = chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc && arc.custom || {};
						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
						var arcOpts = chart.options.elements.arc;
						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

						return {
							text: label,
							fillStyle: fill,
							strokeStyle: stroke,
							lineWidth: bw,
							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Extra data used for toggling the correct item
							index: i
						};
					});
				}
				return [];
			}
		},

		onClick: function(e, legendItem) {
			var index = legendItem.index;
			var chart = this.chart;
			var i, ilen, meta;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				// toggle visibility of index if exists
				if (meta.data[index]) {
					meta.data[index].hidden = !meta.data[index].hidden;
				}
			}

			chart.update();
		}
	},

	// The percentage of the chart that we cut out of the middle.
	cutoutPercentage: 50,

	// The rotation of the chart, where the first data arc begins.
	rotation: Math.PI * -0.5,

	// The total circumference of the chart.
	circumference: Math.PI * 2.0,

	// Need to override these to give a nice default
	tooltips: {
		callbacks: {
			title: function() {
				return '';
			},
			label: function(tooltipItem, data) {
				var dataLabel = data.labels[tooltipItem.index];
				var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

				if (helpers.isArray(dataLabel)) {
					// show value on first line of multiline label
					// need to clone because we are changing the value
					dataLabel = dataLabel.slice();
					dataLabel[0] += value;
				} else {
					dataLabel += value;
				}

				return dataLabel;
			}
		}
	}
});

defaults._set('pie', helpers.clone(defaults.doughnut));
defaults._set('pie', {
	cutoutPercentage: 0
});

module.exports = function(Chart) {

	Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

		dataElementType: elements.Arc,

		linkScales: helpers.noop,

		// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
		getRingIndex: function(datasetIndex) {
			var ringIndex = 0;

			for (var j = 0; j < datasetIndex; ++j) {
				if (this.chart.isDatasetVisible(j)) {
					++ringIndex;
				}
			}

			return ringIndex;
		},

		update: function(reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
			var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
			var minSize = Math.min(availableWidth, availableHeight);
			var offset = {x: 0, y: 0};
			var meta = me.getMeta();
			var cutoutPercentage = opts.cutoutPercentage;
			var circumference = opts.circumference;

			// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
			if (circumference < Math.PI * 2.0) {
				var startAngle = opts.rotation % (Math.PI * 2.0);
				startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
				var endAngle = startAngle + circumference;
				var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
				var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
				var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
				var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
				var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
				var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
				var cutout = cutoutPercentage / 100.0;
				var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
				var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
				var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
				minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
				offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
			}

			chart.borderWidth = me.getMaxBorderWidth(meta.data);
			chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
			chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
			chart.offsetX = offset.x * chart.outerRadius;
			chart.offsetY = offset.y * chart.outerRadius;

			meta.total = me.calculateTotal();

			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
			me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

			helpers.each(meta.data, function(arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		updateElement: function(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var opts = chart.options;
			var animationOpts = opts.animation;
			var centerX = (chartArea.left + chartArea.right) / 2;
			var centerY = (chartArea.top + chartArea.bottom) / 2;
			var startAngle = opts.rotation; // non reset case handled later
			var endAngle = opts.rotation; // non reset case handled later
			var dataset = me.getDataset();
			var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
			var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
			var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
			var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,

				// Desired view properties
				_model: {
					x: centerX + chart.offsetX,
					y: centerY + chart.offsetY,
					startAngle: startAngle,
					endAngle: endAngle,
					circumference: circumference,
					outerRadius: outerRadius,
					innerRadius: innerRadius,
					label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
				}
			});

			var model = arc._model;

			// Resets the visual styles
			var custom = arc.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var elementOpts = this.chart.options.elements.arc;
			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);

			// Set correct angles if not resetting
			if (!reset || !animationOpts.animateRotate) {
				if (index === 0) {
					model.startAngle = opts.rotation;
				} else {
					model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
				}

				model.endAngle = model.startAngle + model.circumference;
			}

			arc.pivot();
		},

		calculateTotal: function() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var total = 0;
			var value;

			helpers.each(meta.data, function(element, index) {
				value = dataset.data[index];
				if (!isNaN(value) && !element.hidden) {
					total += Math.abs(value);
				}
			});

			/* if (total === 0) {
				total = NaN;
			}*/

			return total;
		},

		calculateCircumference: function(value) {
			var total = this.getMeta().total;
			if (total > 0 && !isNaN(value)) {
				return (Math.PI * 2.0) * (Math.abs(value) / total);
			}
			return 0;
		},

		// gets the max border or hover width to properly scale pie charts
		getMaxBorderWidth: function(arcs) {
			var max = 0;
			var index = this.index;
			var length = arcs.length;
			var borderWidth;
			var hoverWidth;

			for (var i = 0; i < length; i++) {
				borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
				hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

				max = borderWidth > max ? borderWidth : max;
				max = hoverWidth > max ? hoverWidth : max;
			}
			return max;
		}
	});
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/controllers/controller.line.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('line', {
	showLines: true,
	spanGaps: false,

	hover: {
		mode: 'label'
	},

	scales: {
		xAxes: [{
			type: 'category',
			id: 'x-axis-0'
		}],
		yAxes: [{
			type: 'linear',
			id: 'y-axis-0'
		}]
	}
});

module.exports = function(Chart) {

	function lineEnabled(dataset, options) {
		return helpers.valueOrDefault(dataset.showLine, options.showLines);
	}

	Chart.controllers.line = Chart.DatasetController.extend({

		datasetElementType: elements.Line,

		dataElementType: elements.Point,

		update: function(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data || [];
			var options = me.chart.options;
			var lineElementOptions = options.elements.line;
			var scale = me.getScaleForId(meta.yAxisID);
			var i, ilen, custom;
			var dataset = me.getDataset();
			var showLine = lineEnabled(dataset, options);

			// Update Line
			if (showLine) {
				custom = line.custom || {};

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
					dataset.lineTension = dataset.tension;
				}

				// Utility
				line._scale = scale;
				line._datasetIndex = me.index;
				// Data
				line._children = points;
				// Model
				line._model = {
					// Appearance
					// The default behavior of lines is to break at null values, according
					// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
					// This option gives lines the ability to span gaps
					spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
					cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
				};

				line.pivot();
			}

			// Update Points
			for (i = 0, ilen = points.length; i < ilen; ++i) {
				me.updateElement(points[i], i, reset);
			}

			if (showLine && line._model.tension !== 0) {
				me.updateBezierControlPoints();
			}

			// Now pivot the point for animation
			for (i = 0, ilen = points.length; i < ilen; ++i) {
				points[i].pivot();
			}
		},

		getPointBackgroundColor: function(point, index) {
			var backgroundColor = this.chart.options.elements.point.backgroundColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (custom.backgroundColor) {
				backgroundColor = custom.backgroundColor;
			} else if (dataset.pointBackgroundColor) {
				backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
			} else if (dataset.backgroundColor) {
				backgroundColor = dataset.backgroundColor;
			}

			return backgroundColor;
		},

		getPointBorderColor: function(point, index) {
			var borderColor = this.chart.options.elements.point.borderColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (custom.borderColor) {
				borderColor = custom.borderColor;
			} else if (dataset.pointBorderColor) {
				borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
			} else if (dataset.borderColor) {
				borderColor = dataset.borderColor;
			}

			return borderColor;
		},

		getPointBorderWidth: function(point, index) {
			var borderWidth = this.chart.options.elements.point.borderWidth;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (!isNaN(custom.borderWidth)) {
				borderWidth = custom.borderWidth;
			} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
				borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
			} else if (!isNaN(dataset.borderWidth)) {
				borderWidth = dataset.borderWidth;
			}

			return borderWidth;
		},

		getPointRotation: function(point, index) {
			var pointRotation = this.chart.options.elements.point.rotation;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (!isNaN(custom.rotation)) {
				pointRotation = custom.rotation;
			} else if (!isNaN(dataset.pointRotation) || helpers.isArray(dataset.pointRotation)) {
				pointRotation = helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointRotation);
			}
			return pointRotation;
		},

		updateElement: function(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var datasetIndex = me.index;
			var value = dataset.data[index];
			var yScale = me.getScaleForId(meta.yAxisID);
			var xScale = me.getScaleForId(meta.xAxisID);
			var pointOptions = me.chart.options.elements.point;
			var x, y;

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}
			if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
			y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

			// Utility
			point._xScale = xScale;
			point._yScale = yScale;
			point._datasetIndex = datasetIndex;
			point._index = index;

			// Desired view properties
			point._model = {
				x: x,
				y: y,
				skip: custom.skip || isNaN(x) || isNaN(y),
				// Appearance
				radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
				pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
				rotation: me.getPointRotation(point, index),
				backgroundColor: me.getPointBackgroundColor(point, index),
				borderColor: me.getPointBorderColor(point, index),
				borderWidth: me.getPointBorderWidth(point, index),
				tension: meta.dataset._model ? meta.dataset._model.tension : 0,
				steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
				// Tooltip
				hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
			};
		},

		calculatePointY: function(value, index, datasetIndex) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var sumPos = 0;
			var sumNeg = 0;
			var i, ds, dsMeta;

			if (yScale.options.stacked) {
				for (i = 0; i < datasetIndex; i++) {
					ds = chart.data.datasets[i];
					dsMeta = chart.getDatasetMeta(i);
					if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
						var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
						if (stackedRightValue < 0) {
							sumNeg += stackedRightValue || 0;
						} else {
							sumPos += stackedRightValue || 0;
						}
					}
				}

				var rightValue = Number(yScale.getRightValue(value));
				if (rightValue < 0) {
					return yScale.getPixelForValue(sumNeg + rightValue);
				}
				return yScale.getPixelForValue(sumPos + rightValue);
			}

			return yScale.getPixelForValue(value);
		},

		updateBezierControlPoints: function() {
			var me = this;
			var meta = me.getMeta();
			var area = me.chart.chartArea;
			var points = (meta.data || []);
			var i, ilen, point, model, controlPoints;

			// Only consider points that are drawn in case the spanGaps option is used
			if (meta.dataset._model.spanGaps) {
				points = points.filter(function(pt) {
					return !pt._model.skip;
				});
			}

			function capControlPoint(pt, min, max) {
				return Math.max(Math.min(pt, max), min);
			}

			if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
				helpers.splineCurveMonotone(points);
			} else {
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					point = points[i];
					model = point._model;
					controlPoints = helpers.splineCurve(
						helpers.previousItem(points, i)._model,
						model,
						helpers.nextItem(points, i)._model,
						meta.dataset._model.tension
					);
					model.controlPointPreviousX = controlPoints.previous.x;
					model.controlPointPreviousY = controlPoints.previous.y;
					model.controlPointNextX = controlPoints.next.x;
					model.controlPointNextY = controlPoints.next.y;
				}
			}

			if (me.chart.options.elements.line.capBezierPoints) {
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					model = points[i]._model;
					model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
					model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
					model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
					model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
				}
			}
		},

		draw: function() {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var points = meta.data || [];
			var area = chart.chartArea;
			var ilen = points.length;
			var halfBorderWidth;
			var i = 0;

			if (lineEnabled(me.getDataset(), chart.options)) {
				halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;

				helpers.canvas.clipArea(chart.ctx, {
					left: area.left,
					right: area.right,
					top: area.top - halfBorderWidth,
					bottom: area.bottom + halfBorderWidth
				});

				meta.dataset.draw();

				helpers.canvas.unclipArea(chart.ctx);
			}

			// Draw the points
			for (; i < ilen; ++i) {
				points[i].draw(area);
			}
		},

		setHoverStyle: function(element) {
			// Point
			var dataset = this.chart.data.datasets[element._datasetIndex];
			var index = element._index;
			var custom = element.custom || {};
			var model = element._model;

			element.$previousStyle = {
				backgroundColor: model.backgroundColor,
				borderColor: model.borderColor,
				borderWidth: model.borderWidth,
				radius: model.radius
			};

			model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
		},
	});
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/controllers/controller.polarArea.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('polarArea', {
	scale: {
		type: 'radialLinear',
		angleLines: {
			display: false
		},
		gridLines: {
			circular: true
		},
		pointLabels: {
			display: false
		},
		ticks: {
			beginAtZero: true
		}
	},

	// Boolean - Whether to animate the rotation of the chart
	animation: {
		animateRotate: true,
		animateScale: true
	},

	startAngle: -0.5 * Math.PI,
	legendCallback: function(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = data.datasets;
		var labels = data.labels;

		if (datasets.length) {
			for (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				if (labels[i]) {
					text.push(labels[i]);
				}
				text.push('</li>');
			}
		}

		text.push('</ul>');
		return text.join('');
	},
	legend: {
		labels: {
			generateLabels: function(chart) {
				var data = chart.data;
				if (data.labels.length && data.datasets.length) {
					return data.labels.map(function(label, i) {
						var meta = chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc.custom || {};
						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
						var arcOpts = chart.options.elements.arc;
						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

						return {
							text: label,
							fillStyle: fill,
							strokeStyle: stroke,
							lineWidth: bw,
							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Extra data used for toggling the correct item
							index: i
						};
					});
				}
				return [];
			}
		},

		onClick: function(e, legendItem) {
			var index = legendItem.index;
			var chart = this.chart;
			var i, ilen, meta;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				meta.data[index].hidden = !meta.data[index].hidden;
			}

			chart.update();
		}
	},

	// Need to override these to give a nice default
	tooltips: {
		callbacks: {
			title: function() {
				return '';
			},
			label: function(item, data) {
				return data.labels[item.index] + ': ' + item.yLabel;
			}
		}
	}
});

module.exports = function(Chart) {

	Chart.controllers.polarArea = Chart.DatasetController.extend({

		dataElementType: elements.Arc,

		linkScales: helpers.noop,

		update: function(reset) {
			var me = this;
			var dataset = me.getDataset();
			var meta = me.getMeta();
			var start = me.chart.options.startAngle || 0;
			var starts = me._starts = [];
			var angles = me._angles = [];
			var i, ilen, angle;

			me._updateRadius();

			meta.count = me.countVisibleElements();

			for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
				starts[i] = start;
				angle = me._computeAngle(i);
				angles[i] = angle;
				start += angle;
			}

			helpers.each(meta.data, function(arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		/**
		 * @private
		 */
		_updateRadius: function() {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);

			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
			chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
			me.innerRadius = me.outerRadius - chart.radiusLength;
		},

		updateElement: function(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var dataset = me.getDataset();
			var opts = chart.options;
			var animationOpts = opts.animation;
			var scale = chart.scale;
			var labels = chart.data.labels;

			var centerX = scale.xCenter;
			var centerY = scale.yCenter;

			// var negHalfPI = -0.5 * Math.PI;
			var datasetStartAngle = opts.startAngle;
			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
			var startAngle = me._starts[index];
			var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);

			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: centerX,
					y: centerY,
					innerRadius: 0,
					outerRadius: reset ? resetRadius : distance,
					startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
					endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
					label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
				}
			});

			// Apply border and fill style
			var elementOpts = this.chart.options.elements.arc;
			var custom = arc.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var model = arc._model;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);

			arc.pivot();
		},

		countVisibleElements: function() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var count = 0;

			helpers.each(meta.data, function(element, index) {
				if (!isNaN(dataset.data[index]) && !element.hidden) {
					count++;
				}
			});

			return count;
		},

		/**
		 * @private
		 */
		_computeAngle: function(index) {
			var me = this;
			var count = this.getMeta().count;
			var dataset = me.getDataset();
			var meta = me.getMeta();

			if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
				return 0;
			}

			// Scriptable options
			var context = {
				chart: me.chart,
				dataIndex: index,
				dataset: dataset,
				datasetIndex: me.index
			};

			return helpers.options.resolve([
				me.chart.options.elements.arc.angle,
				(2 * Math.PI) / count
			], context, index);
		}
	});
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/controllers/controller.radar.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('radar', {
	scale: {
		type: 'radialLinear'
	},
	elements: {
		line: {
			tension: 0 // no bezier in radar
		}
	}
});

module.exports = function(Chart) {

	Chart.controllers.radar = Chart.DatasetController.extend({

		datasetElementType: elements.Line,

		dataElementType: elements.Point,

		linkScales: helpers.noop,

		update: function(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data;
			var custom = line.custom || {};
			var dataset = me.getDataset();
			var lineElementOptions = me.chart.options.elements.line;
			var scale = me.chart.scale;

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
				dataset.lineTension = dataset.tension;
			}

			helpers.extend(meta.dataset, {
				// Utility
				_datasetIndex: me.index,
				_scale: scale,
				// Data
				_children: points,
				_loop: true,
				// Model
				_model: {
					// Appearance
					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
				}
			});

			meta.dataset.pivot();

			// Update Points
			helpers.each(points, function(point, index) {
				me.updateElement(point, index, reset);
			}, me);

			// Update bezier control points
			me.updateBezierControlPoints();
		},
		updateElement: function(point, index, reset) {
			var me = this;
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var scale = me.chart.scale;
			var pointElementOptions = me.chart.options.elements.point;
			var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}
			if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			helpers.extend(point, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
					y: reset ? scale.yCenter : pointPosition.y,

					// Appearance
					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
					radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
					pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
					rotation: custom.rotation ? custom.rotation : helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointElementOptions.rotation),

					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
				}
			});

			point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
		},
		updateBezierControlPoints: function() {
			var chartArea = this.chart.chartArea;
			var meta = this.getMeta();

			helpers.each(meta.data, function(point, index) {
				var model = point._model;
				var controlPoints = helpers.splineCurve(
					helpers.previousItem(meta.data, index, true)._model,
					model,
					helpers.nextItem(meta.data, index, true)._model,
					model.tension
				);

				// Prevent the bezier going outside of the bounds of the graph
				model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
				model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

				model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
				model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

				// Now pivot the point for animation
				point.pivot();
			});
		},

		setHoverStyle: function(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;

			point.$previousStyle = {
				backgroundColor: model.backgroundColor,
				borderColor: model.borderColor,
				borderWidth: model.borderWidth,
				radius: model.radius
			};

			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},
	});
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/controllers/controller.scatter.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');

defaults._set('scatter', {
	hover: {
		mode: 'single'
	},

	scales: {
		xAxes: [{
			id: 'x-axis-1',    // need an ID so datasets can reference the scale
			type: 'linear',    // scatter should not use a category axis
			position: 'bottom'
		}],
		yAxes: [{
			id: 'y-axis-1',
			type: 'linear',
			position: 'left'
		}]
	},

	showLines: false,

	tooltips: {
		callbacks: {
			title: function() {
				return '';     // doesn't make sense for scatter since data are formatted as a point
			},
			label: function(item) {
				return '(' + item.xLabel + ', ' + item.yLabel + ')';
			}
		}
	}
});

module.exports = function(Chart) {

	// Scatter charts use line controllers
	Chart.controllers.scatter = Chart.controllers.line;

};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js"}],"../node_modules/chart.js/src/charts/Chart.Bar.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {

	Chart.Bar = function(context, config) {
		config.type = 'bar';

		return new Chart(context, config);
	};

};

},{}],"../node_modules/chart.js/src/charts/Chart.Bubble.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {

	Chart.Bubble = function(context, config) {
		config.type = 'bubble';
		return new Chart(context, config);
	};

};

},{}],"../node_modules/chart.js/src/charts/Chart.Doughnut.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {

	Chart.Doughnut = function(context, config) {
		config.type = 'doughnut';

		return new Chart(context, config);
	};

};

},{}],"../node_modules/chart.js/src/charts/Chart.Line.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {

	Chart.Line = function(context, config) {
		config.type = 'line';

		return new Chart(context, config);
	};

};

},{}],"../node_modules/chart.js/src/charts/Chart.PolarArea.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {

	Chart.PolarArea = function(context, config) {
		config.type = 'polarArea';

		return new Chart(context, config);
	};

};

},{}],"../node_modules/chart.js/src/charts/Chart.Radar.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {

	Chart.Radar = function(context, config) {
		config.type = 'radar';

		return new Chart(context, config);
	};

};

},{}],"../node_modules/chart.js/src/charts/Chart.Scatter.js":[function(require,module,exports) {
'use strict';

module.exports = function(Chart) {
	Chart.Scatter = function(context, config) {
		config.type = 'scatter';
		return new Chart(context, config);
	};
};

},{}],"../node_modules/chart.js/src/plugins/plugin.filler.js":[function(require,module,exports) {
/**
 * Plugin based on discussion from the following Chart.js issues:
 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
 */

'use strict';

var defaults = require('../core/core.defaults');
var elements = require('../elements/index');
var helpers = require('../helpers/index');

defaults._set('global', {
	plugins: {
		filler: {
			propagate: true
		}
	}
});

var mappers = {
	dataset: function(source) {
		var index = source.fill;
		var chart = source.chart;
		var meta = chart.getDatasetMeta(index);
		var visible = meta && chart.isDatasetVisible(index);
		var points = (visible && meta.dataset._children) || [];
		var length = points.length || 0;

		return !length ? null : function(point, i) {
			return (i < length && points[i]._view) || null;
		};
	},

	boundary: function(source) {
		var boundary = source.boundary;
		var x = boundary ? boundary.x : null;
		var y = boundary ? boundary.y : null;

		return function(point) {
			return {
				x: x === null ? point.x : x,
				y: y === null ? point.y : y,
			};
		};
	}
};

// @todo if (fill[0] === '#')
function decodeFill(el, index, count) {
	var model = el._model || {};
	var fill = model.fill;
	var target;

	if (fill === undefined) {
		fill = !!model.backgroundColor;
	}

	if (fill === false || fill === null) {
		return false;
	}

	if (fill === true) {
		return 'origin';
	}

	target = parseFloat(fill, 10);
	if (isFinite(target) && Math.floor(target) === target) {
		if (fill[0] === '-' || fill[0] === '+') {
			target = index + target;
		}

		if (target === index || target < 0 || target >= count) {
			return false;
		}

		return target;
	}

	switch (fill) {
	// compatibility
	case 'bottom':
		return 'start';
	case 'top':
		return 'end';
	case 'zero':
		return 'origin';
	// supported boundaries
	case 'origin':
	case 'start':
	case 'end':
		return fill;
	// invalid fill values
	default:
		return false;
	}
}

function computeBoundary(source) {
	var model = source.el._model || {};
	var scale = source.el._scale || {};
	var fill = source.fill;
	var target = null;
	var horizontal;

	if (isFinite(fill)) {
		return null;
	}

	// Backward compatibility: until v3, we still need to support boundary values set on
	// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
	// controllers might still use it (e.g. the Smith chart).

	if (fill === 'start') {
		target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
	} else if (fill === 'end') {
		target = model.scaleTop === undefined ? scale.top : model.scaleTop;
	} else if (model.scaleZero !== undefined) {
		target = model.scaleZero;
	} else if (scale.getBasePosition) {
		target = scale.getBasePosition();
	} else if (scale.getBasePixel) {
		target = scale.getBasePixel();
	}

	if (target !== undefined && target !== null) {
		if (target.x !== undefined && target.y !== undefined) {
			return target;
		}

		if (typeof target === 'number' && isFinite(target)) {
			horizontal = scale.isHorizontal();
			return {
				x: horizontal ? target : null,
				y: horizontal ? null : target
			};
		}
	}

	return null;
}

function resolveTarget(sources, index, propagate) {
	var source = sources[index];
	var fill = source.fill;
	var visited = [index];
	var target;

	if (!propagate) {
		return fill;
	}

	while (fill !== false && visited.indexOf(fill) === -1) {
		if (!isFinite(fill)) {
			return fill;
		}

		target = sources[fill];
		if (!target) {
			return false;
		}

		if (target.visible) {
			return fill;
		}

		visited.push(fill);
		fill = target.fill;
	}

	return false;
}

function createMapper(source) {
	var fill = source.fill;
	var type = 'dataset';

	if (fill === false) {
		return null;
	}

	if (!isFinite(fill)) {
		type = 'boundary';
	}

	return mappers[type](source);
}

function isDrawable(point) {
	return point && !point.skip;
}

function drawArea(ctx, curve0, curve1, len0, len1) {
	var i;

	if (!len0 || !len1) {
		return;
	}

	// building first area curve (normal)
	ctx.moveTo(curve0[0].x, curve0[0].y);
	for (i = 1; i < len0; ++i) {
		helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
	}

	// joining the two area curves
	ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

	// building opposite area curve (reverse)
	for (i = len1 - 1; i > 0; --i) {
		helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
	}
}

function doFill(ctx, points, mapper, view, color, loop) {
	var count = points.length;
	var span = view.spanGaps;
	var curve0 = [];
	var curve1 = [];
	var len0 = 0;
	var len1 = 0;
	var i, ilen, index, p0, p1, d0, d1;

	ctx.beginPath();

	for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
		index = i % count;
		p0 = points[index]._view;
		p1 = mapper(p0, index, view);
		d0 = isDrawable(p0);
		d1 = isDrawable(p1);

		if (d0 && d1) {
			len0 = curve0.push(p0);
			len1 = curve1.push(p1);
		} else if (len0 && len1) {
			if (!span) {
				drawArea(ctx, curve0, curve1, len0, len1);
				len0 = len1 = 0;
				curve0 = [];
				curve1 = [];
			} else {
				if (d0) {
					curve0.push(p0);
				}
				if (d1) {
					curve1.push(p1);
				}
			}
		}
	}

	drawArea(ctx, curve0, curve1, len0, len1);

	ctx.closePath();
	ctx.fillStyle = color;
	ctx.fill();
}

module.exports = {
	id: 'filler',

	afterDatasetsUpdate: function(chart, options) {
		var count = (chart.data.datasets || []).length;
		var propagate = options.propagate;
		var sources = [];
		var meta, i, el, source;

		for (i = 0; i < count; ++i) {
			meta = chart.getDatasetMeta(i);
			el = meta.dataset;
			source = null;

			if (el && el._model && el instanceof elements.Line) {
				source = {
					visible: chart.isDatasetVisible(i),
					fill: decodeFill(el, i, count),
					chart: chart,
					el: el
				};
			}

			meta.$filler = source;
			sources.push(source);
		}

		for (i = 0; i < count; ++i) {
			source = sources[i];
			if (!source) {
				continue;
			}

			source.fill = resolveTarget(sources, i, propagate);
			source.boundary = computeBoundary(source);
			source.mapper = createMapper(source);
		}
	},

	beforeDatasetDraw: function(chart, args) {
		var meta = args.meta.$filler;
		if (!meta) {
			return;
		}

		var ctx = chart.ctx;
		var el = meta.el;
		var view = el._view;
		var points = el._children || [];
		var mapper = meta.mapper;
		var color = view.backgroundColor || defaults.global.defaultColor;

		if (mapper && color && points.length) {
			helpers.canvas.clipArea(ctx, chart.chartArea);
			doFill(ctx, points, mapper, view, color, el._loop);
			helpers.canvas.unclipArea(ctx);
		}
	}
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../elements/index":"../node_modules/chart.js/src/elements/index.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js"}],"../node_modules/chart.js/src/plugins/plugin.legend.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var Element = require('../core/core.element');
var helpers = require('../helpers/index');
var layouts = require('../core/core.layouts');

var noop = helpers.noop;

defaults._set('global', {
	legend: {
		display: true,
		position: 'top',
		fullWidth: true,
		reverse: false,
		weight: 1000,

		// a callback that will handle
		onClick: function(e, legendItem) {
			var index = legendItem.datasetIndex;
			var ci = this.chart;
			var meta = ci.getDatasetMeta(index);

			// See controller.isDatasetVisible comment
			meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

			// We hid a dataset ... rerender the chart
			ci.update();
		},

		onHover: null,

		labels: {
			boxWidth: 40,
			padding: 10,
			// Generates labels shown in the legend
			// Valid properties to return:
			// text : text to display
			// fillStyle : fill of coloured box
			// strokeStyle: stroke of coloured box
			// hidden : if this legend item refers to a hidden item
			// lineCap : cap style for line
			// lineDash
			// lineDashOffset :
			// lineJoin :
			// lineWidth :
			generateLabels: function(chart) {
				var data = chart.data;
				return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
					return {
						text: dataset.label,
						fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
						hidden: !chart.isDatasetVisible(i),
						lineCap: dataset.borderCapStyle,
						lineDash: dataset.borderDash,
						lineDashOffset: dataset.borderDashOffset,
						lineJoin: dataset.borderJoinStyle,
						lineWidth: dataset.borderWidth,
						strokeStyle: dataset.borderColor,
						pointStyle: dataset.pointStyle,

						// Below is extra data used for toggling the datasets
						datasetIndex: i
					};
				}, this) : [];
			}
		}
	},

	legendCallback: function(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');
		for (var i = 0; i < chart.data.datasets.length; i++) {
			text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
			if (chart.data.datasets[i].label) {
				text.push(chart.data.datasets[i].label);
			}
			text.push('</li>');
		}
		text.push('</ul>');
		return text.join('');
	}
});

/**
 * Helper function to get the box width based on the usePointStyle option
 * @param labelopts {Object} the label options on the legend
 * @param fontSize {Number} the label font size
 * @return {Number} width of the color box area
 */
function getBoxWidth(labelOpts, fontSize) {
	return labelOpts.usePointStyle ?
		fontSize * Math.SQRT2 :
		labelOpts.boxWidth;
}

/**
 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
 */
var Legend = Element.extend({

	initialize: function(config) {
		helpers.extend(this, config);

		// Contains hit boxes for each dataset (in dataset order)
		this.legendHitBoxes = [];

		// Are we in doughnut mode which has a different data type
		this.doughnutMode = false;
	},

	// These methods are ordered by lifecycle. Utilities then follow.
	// Any function defined here is inherited by all legend types.
	// Any function can be extended by the legend type

	beforeUpdate: noop,
	update: function(maxWidth, maxHeight, margins) {
		var me = this;

		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
		me.beforeUpdate();

		// Absorb the master measurements
		me.maxWidth = maxWidth;
		me.maxHeight = maxHeight;
		me.margins = margins;

		// Dimensions
		me.beforeSetDimensions();
		me.setDimensions();
		me.afterSetDimensions();
		// Labels
		me.beforeBuildLabels();
		me.buildLabels();
		me.afterBuildLabels();

		// Fit
		me.beforeFit();
		me.fit();
		me.afterFit();
		//
		me.afterUpdate();

		return me.minSize;
	},
	afterUpdate: noop,

	//

	beforeSetDimensions: noop,
	setDimensions: function() {
		var me = this;
		// Set the unconstrained dimension before label rotation
		if (me.isHorizontal()) {
			// Reset position before calculating rotation
			me.width = me.maxWidth;
			me.left = 0;
			me.right = me.width;
		} else {
			me.height = me.maxHeight;

			// Reset position before calculating rotation
			me.top = 0;
			me.bottom = me.height;
		}

		// Reset padding
		me.paddingLeft = 0;
		me.paddingTop = 0;
		me.paddingRight = 0;
		me.paddingBottom = 0;

		// Reset minSize
		me.minSize = {
			width: 0,
			height: 0
		};
	},
	afterSetDimensions: noop,

	//

	beforeBuildLabels: noop,
	buildLabels: function() {
		var me = this;
		var labelOpts = me.options.labels || {};
		var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

		if (labelOpts.filter) {
			legendItems = legendItems.filter(function(item) {
				return labelOpts.filter(item, me.chart.data);
			});
		}

		if (me.options.reverse) {
			legendItems.reverse();
		}

		me.legendItems = legendItems;
	},
	afterBuildLabels: noop,

	//

	beforeFit: noop,
	fit: function() {
		var me = this;
		var opts = me.options;
		var labelOpts = opts.labels;
		var display = opts.display;

		var ctx = me.ctx;

		var globalDefault = defaults.global;
		var valueOrDefault = helpers.valueOrDefault;
		var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
		var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
		var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
		var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

		// Reset hit boxes
		var hitboxes = me.legendHitBoxes = [];

		var minSize = me.minSize;
		var isHorizontal = me.isHorizontal();

		if (isHorizontal) {
			minSize.width = me.maxWidth; // fill all the width
			minSize.height = display ? 10 : 0;
		} else {
			minSize.width = display ? 10 : 0;
			minSize.height = me.maxHeight; // fill all the height
		}

		// Increase sizes here
		if (display) {
			ctx.font = labelFont;

			if (isHorizontal) {
				// Labels

				// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
				var lineWidths = me.lineWidths = [0];
				var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

				ctx.textAlign = 'left';
				ctx.textBaseline = 'top';

				helpers.each(me.legendItems, function(legendItem, i) {
					var boxWidth = getBoxWidth(labelOpts, fontSize);
					var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

					if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
						totalHeight += fontSize + (labelOpts.padding);
						lineWidths[lineWidths.length] = me.left;
					}

					// Store the hitbox width and height here. Final position will be updated in `draw`
					hitboxes[i] = {
						left: 0,
						top: 0,
						width: width,
						height: fontSize
					};

					lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
				});

				minSize.height += totalHeight;

			} else {
				var vPadding = labelOpts.padding;
				var columnWidths = me.columnWidths = [];
				var totalWidth = labelOpts.padding;
				var currentColWidth = 0;
				var currentColHeight = 0;
				var itemHeight = fontSize + vPadding;

				helpers.each(me.legendItems, function(legendItem, i) {
					var boxWidth = getBoxWidth(labelOpts, fontSize);
					var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

					// If too tall, go to new column
					if (currentColHeight + itemHeight > minSize.height) {
						totalWidth += currentColWidth + labelOpts.padding;
						columnWidths.push(currentColWidth); // previous column width

						currentColWidth = 0;
						currentColHeight = 0;
					}

					// Get max width
					currentColWidth = Math.max(currentColWidth, itemWidth);
					currentColHeight += itemHeight;

					// Store the hitbox width and height here. Final position will be updated in `draw`
					hitboxes[i] = {
						left: 0,
						top: 0,
						width: itemWidth,
						height: fontSize
					};
				});

				totalWidth += currentColWidth;
				columnWidths.push(currentColWidth);
				minSize.width += totalWidth;
			}
		}

		me.width = minSize.width;
		me.height = minSize.height;
	},
	afterFit: noop,

	// Shared Methods
	isHorizontal: function() {
		return this.options.position === 'top' || this.options.position === 'bottom';
	},

	// Actually draw the legend on the canvas
	draw: function() {
		var me = this;
		var opts = me.options;
		var labelOpts = opts.labels;
		var globalDefault = defaults.global;
		var lineDefault = globalDefault.elements.line;
		var legendWidth = me.width;
		var lineWidths = me.lineWidths;

		if (opts.display) {
			var ctx = me.ctx;
			var valueOrDefault = helpers.valueOrDefault;
			var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
			var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
			var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
			var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
			var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
			var cursor;

			// Canvas setup
			ctx.textAlign = 'left';
			ctx.textBaseline = 'middle';
			ctx.lineWidth = 0.5;
			ctx.strokeStyle = fontColor; // for strikethrough effect
			ctx.fillStyle = fontColor; // render in correct colour
			ctx.font = labelFont;

			var boxWidth = getBoxWidth(labelOpts, fontSize);
			var hitboxes = me.legendHitBoxes;

			// current position
			var drawLegendBox = function(x, y, legendItem) {
				if (isNaN(boxWidth) || boxWidth <= 0) {
					return;
				}

				// Set the ctx for the box
				ctx.save();

				ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
				ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
				ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
				ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
				ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
				ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
				var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);

				if (ctx.setLineDash) {
					// IE 9 and 10 do not support line dash
					ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
				}

				if (opts.labels && opts.labels.usePointStyle) {
					// Recalculate x and y for drawPoint() because its expecting
					// x and y to be center of figure (instead of top left)
					var radius = fontSize * Math.SQRT2 / 2;
					var offSet = radius / Math.SQRT2;
					var centerX = x + offSet;
					var centerY = y + offSet;

					// Draw pointStyle as legend symbol
					helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
				} else {
					// Draw box as legend symbol
					if (!isLineWidthZero) {
						ctx.strokeRect(x, y, boxWidth, fontSize);
					}
					ctx.fillRect(x, y, boxWidth, fontSize);
				}

				ctx.restore();
			};
			var fillText = function(x, y, legendItem, textWidth) {
				var halfFontSize = fontSize / 2;
				var xLeft = boxWidth + halfFontSize + x;
				var yMiddle = y + halfFontSize;

				ctx.fillText(legendItem.text, xLeft, yMiddle);

				if (legendItem.hidden) {
					// Strikethrough the text if hidden
					ctx.beginPath();
					ctx.lineWidth = 2;
					ctx.moveTo(xLeft, yMiddle);
					ctx.lineTo(xLeft + textWidth, yMiddle);
					ctx.stroke();
				}
			};

			// Horizontal
			var isHorizontal = me.isHorizontal();
			if (isHorizontal) {
				cursor = {
					x: me.left + ((legendWidth - lineWidths[0]) / 2),
					y: me.top + labelOpts.padding,
					line: 0
				};
			} else {
				cursor = {
					x: me.left + labelOpts.padding,
					y: me.top + labelOpts.padding,
					line: 0
				};
			}

			var itemHeight = fontSize + labelOpts.padding;
			helpers.each(me.legendItems, function(legendItem, i) {
				var textWidth = ctx.measureText(legendItem.text).width;
				var width = boxWidth + (fontSize / 2) + textWidth;
				var x = cursor.x;
				var y = cursor.y;

				if (isHorizontal) {
					if (x + width >= legendWidth) {
						y = cursor.y += itemHeight;
						cursor.line++;
						x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
					}
				} else if (y + itemHeight > me.bottom) {
					x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
					y = cursor.y = me.top + labelOpts.padding;
					cursor.line++;
				}

				drawLegendBox(x, y, legendItem);

				hitboxes[i].left = x;
				hitboxes[i].top = y;

				// Fill the actual label
				fillText(x, y, legendItem, textWidth);

				if (isHorizontal) {
					cursor.x += width + (labelOpts.padding);
				} else {
					cursor.y += itemHeight;
				}

			});
		}
	},

	/**
	 * Handle an event
	 * @private
	 * @param {IEvent} event - The event to handle
	 * @return {Boolean} true if a change occured
	 */
	handleEvent: function(e) {
		var me = this;
		var opts = me.options;
		var type = e.type === 'mouseup' ? 'click' : e.type;
		var changed = false;

		if (type === 'mousemove') {
			if (!opts.onHover) {
				return;
			}
		} else if (type === 'click') {
			if (!opts.onClick) {
				return;
			}
		} else {
			return;
		}

		// Chart event already has relative position in it
		var x = e.x;
		var y = e.y;

		if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
			// See if we are touching one of the dataset boxes
			var lh = me.legendHitBoxes;
			for (var i = 0; i < lh.length; ++i) {
				var hitBox = lh[i];

				if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
					// Touching an element
					if (type === 'click') {
						// use e.native for backwards compatibility
						opts.onClick.call(me, e.native, me.legendItems[i]);
						changed = true;
						break;
					} else if (type === 'mousemove') {
						// use e.native for backwards compatibility
						opts.onHover.call(me, e.native, me.legendItems[i]);
						changed = true;
						break;
					}
				}
			}
		}

		return changed;
	}
});

function createNewLegendAndAttach(chart, legendOpts) {
	var legend = new Legend({
		ctx: chart.ctx,
		options: legendOpts,
		chart: chart
	});

	layouts.configure(chart, legend, legendOpts);
	layouts.addBox(chart, legend);
	chart.legend = legend;
}

module.exports = {
	id: 'legend',

	/**
	 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
	 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
	 * the plugin, which one will be re-exposed in the chart.js file.
	 * https://github.com/chartjs/Chart.js/pull/2640
	 * @private
	 */
	_element: Legend,

	beforeInit: function(chart) {
		var legendOpts = chart.options.legend;

		if (legendOpts) {
			createNewLegendAndAttach(chart, legendOpts);
		}
	},

	beforeUpdate: function(chart) {
		var legendOpts = chart.options.legend;
		var legend = chart.legend;

		if (legendOpts) {
			helpers.mergeIf(legendOpts, defaults.global.legend);

			if (legend) {
				layouts.configure(chart, legend, legendOpts);
				legend.options = legendOpts;
			} else {
				createNewLegendAndAttach(chart, legendOpts);
			}
		} else if (legend) {
			layouts.removeBox(chart, legend);
			delete chart.legend;
		}
	},

	afterEvent: function(chart, e) {
		var legend = chart.legend;
		if (legend) {
			legend.handleEvent(e);
		}
	}
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../core/core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.layouts":"../node_modules/chart.js/src/core/core.layouts.js"}],"../node_modules/chart.js/src/plugins/plugin.title.js":[function(require,module,exports) {
'use strict';

var defaults = require('../core/core.defaults');
var Element = require('../core/core.element');
var helpers = require('../helpers/index');
var layouts = require('../core/core.layouts');

var noop = helpers.noop;

defaults._set('global', {
	title: {
		display: false,
		fontStyle: 'bold',
		fullWidth: true,
		lineHeight: 1.2,
		padding: 10,
		position: 'top',
		text: '',
		weight: 2000         // by default greater than legend (1000) to be above
	}
});

/**
 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
 */
var Title = Element.extend({
	initialize: function(config) {
		var me = this;
		helpers.extend(me, config);

		// Contains hit boxes for each dataset (in dataset order)
		me.legendHitBoxes = [];
	},

	// These methods are ordered by lifecycle. Utilities then follow.

	beforeUpdate: noop,
	update: function(maxWidth, maxHeight, margins) {
		var me = this;

		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
		me.beforeUpdate();

		// Absorb the master measurements
		me.maxWidth = maxWidth;
		me.maxHeight = maxHeight;
		me.margins = margins;

		// Dimensions
		me.beforeSetDimensions();
		me.setDimensions();
		me.afterSetDimensions();
		// Labels
		me.beforeBuildLabels();
		me.buildLabels();
		me.afterBuildLabels();

		// Fit
		me.beforeFit();
		me.fit();
		me.afterFit();
		//
		me.afterUpdate();

		return me.minSize;

	},
	afterUpdate: noop,

	//

	beforeSetDimensions: noop,
	setDimensions: function() {
		var me = this;
		// Set the unconstrained dimension before label rotation
		if (me.isHorizontal()) {
			// Reset position before calculating rotation
			me.width = me.maxWidth;
			me.left = 0;
			me.right = me.width;
		} else {
			me.height = me.maxHeight;

			// Reset position before calculating rotation
			me.top = 0;
			me.bottom = me.height;
		}

		// Reset padding
		me.paddingLeft = 0;
		me.paddingTop = 0;
		me.paddingRight = 0;
		me.paddingBottom = 0;

		// Reset minSize
		me.minSize = {
			width: 0,
			height: 0
		};
	},
	afterSetDimensions: noop,

	//

	beforeBuildLabels: noop,
	buildLabels: noop,
	afterBuildLabels: noop,

	//

	beforeFit: noop,
	fit: function() {
		var me = this;
		var valueOrDefault = helpers.valueOrDefault;
		var opts = me.options;
		var display = opts.display;
		var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
		var minSize = me.minSize;
		var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
		var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
		var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;

		if (me.isHorizontal()) {
			minSize.width = me.maxWidth; // fill all the width
			minSize.height = textSize;
		} else {
			minSize.width = textSize;
			minSize.height = me.maxHeight; // fill all the height
		}

		me.width = minSize.width;
		me.height = minSize.height;

	},
	afterFit: noop,

	// Shared Methods
	isHorizontal: function() {
		var pos = this.options.position;
		return pos === 'top' || pos === 'bottom';
	},

	// Actually draw the title block on the canvas
	draw: function() {
		var me = this;
		var ctx = me.ctx;
		var valueOrDefault = helpers.valueOrDefault;
		var opts = me.options;
		var globalDefaults = defaults.global;

		if (opts.display) {
			var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
			var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
			var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
			var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
			var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
			var offset = lineHeight / 2 + opts.padding;
			var rotation = 0;
			var top = me.top;
			var left = me.left;
			var bottom = me.bottom;
			var right = me.right;
			var maxWidth, titleX, titleY;

			ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
			ctx.font = titleFont;

			// Horizontal
			if (me.isHorizontal()) {
				titleX = left + ((right - left) / 2); // midpoint of the width
				titleY = top + offset;
				maxWidth = right - left;
			} else {
				titleX = opts.position === 'left' ? left + offset : right - offset;
				titleY = top + ((bottom - top) / 2);
				maxWidth = bottom - top;
				rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
			}

			ctx.save();
			ctx.translate(titleX, titleY);
			ctx.rotate(rotation);
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';

			var text = opts.text;
			if (helpers.isArray(text)) {
				var y = 0;
				for (var i = 0; i < text.length; ++i) {
					ctx.fillText(text[i], 0, y, maxWidth);
					y += lineHeight;
				}
			} else {
				ctx.fillText(text, 0, 0, maxWidth);
			}

			ctx.restore();
		}
	}
});

function createNewTitleBlockAndAttach(chart, titleOpts) {
	var title = new Title({
		ctx: chart.ctx,
		options: titleOpts,
		chart: chart
	});

	layouts.configure(chart, title, titleOpts);
	layouts.addBox(chart, title);
	chart.titleBlock = title;
}

module.exports = {
	id: 'title',

	/**
	 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
	 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
	 * the plugin, which one will be re-exposed in the chart.js file.
	 * https://github.com/chartjs/Chart.js/pull/2640
	 * @private
	 */
	_element: Title,

	beforeInit: function(chart) {
		var titleOpts = chart.options.title;

		if (titleOpts) {
			createNewTitleBlockAndAttach(chart, titleOpts);
		}
	},

	beforeUpdate: function(chart) {
		var titleOpts = chart.options.title;
		var titleBlock = chart.titleBlock;

		if (titleOpts) {
			helpers.mergeIf(titleOpts, defaults.global.title);

			if (titleBlock) {
				layouts.configure(chart, titleBlock, titleOpts);
				titleBlock.options = titleOpts;
			} else {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		} else if (titleBlock) {
			layouts.removeBox(chart, titleBlock);
			delete chart.titleBlock;
		}
	}
};

},{"../core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","../core/core.element":"../node_modules/chart.js/src/core/core.element.js","../helpers/index":"../node_modules/chart.js/src/helpers/index.js","../core/core.layouts":"../node_modules/chart.js/src/core/core.layouts.js"}],"../node_modules/chart.js/src/plugins/index.js":[function(require,module,exports) {
'use strict';

module.exports = {};
module.exports.filler = require('./plugin.filler');
module.exports.legend = require('./plugin.legend');
module.exports.title = require('./plugin.title');

},{"./plugin.filler":"../node_modules/chart.js/src/plugins/plugin.filler.js","./plugin.legend":"../node_modules/chart.js/src/plugins/plugin.legend.js","./plugin.title":"../node_modules/chart.js/src/plugins/plugin.title.js"}],"../node_modules/chart.js/src/chart.js":[function(require,module,exports) {
/**
 * @namespace Chart
 */
var Chart = require('./core/core')();

Chart.helpers = require('./helpers/index');

// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
require('./core/core.helpers')(Chart);

Chart.Animation = require('./core/core.animation');
Chart.animationService = require('./core/core.animations');
Chart.defaults = require('./core/core.defaults');
Chart.Element = require('./core/core.element');
Chart.elements = require('./elements/index');
Chart.Interaction = require('./core/core.interaction');
Chart.layouts = require('./core/core.layouts');
Chart.platform = require('./platforms/platform');
Chart.plugins = require('./core/core.plugins');
Chart.Scale = require('./core/core.scale');
Chart.scaleService = require('./core/core.scaleService');
Chart.Ticks = require('./core/core.ticks');
Chart.Tooltip = require('./core/core.tooltip');

require('./core/core.controller')(Chart);
require('./core/core.datasetController')(Chart);

require('./scales/scale.linearbase')(Chart);
require('./scales/scale.category')(Chart);
require('./scales/scale.linear')(Chart);
require('./scales/scale.logarithmic')(Chart);
require('./scales/scale.radialLinear')(Chart);
require('./scales/scale.time')(Chart);

// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
require('./controllers/controller.bar')(Chart);
require('./controllers/controller.bubble')(Chart);
require('./controllers/controller.doughnut')(Chart);
require('./controllers/controller.line')(Chart);
require('./controllers/controller.polarArea')(Chart);
require('./controllers/controller.radar')(Chart);
require('./controllers/controller.scatter')(Chart);

require('./charts/Chart.Bar')(Chart);
require('./charts/Chart.Bubble')(Chart);
require('./charts/Chart.Doughnut')(Chart);
require('./charts/Chart.Line')(Chart);
require('./charts/Chart.PolarArea')(Chart);
require('./charts/Chart.Radar')(Chart);
require('./charts/Chart.Scatter')(Chart);

// Loading built-in plugins
var plugins = require('./plugins');
for (var k in plugins) {
	if (plugins.hasOwnProperty(k)) {
		Chart.plugins.register(plugins[k]);
	}
}

Chart.platform.initialize();

module.exports = Chart;
if (typeof window !== 'undefined') {
	window.Chart = Chart;
}

// DEPRECATIONS

/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Legend
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */
Chart.Legend = plugins.legend._element;

/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Title
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */
Chart.Title = plugins.title._element;

/**
 * Provided for backward compatibility, use Chart.plugins instead
 * @namespace Chart.pluginService
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */
Chart.pluginService = Chart.plugins;

/**
 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
 * effect, instead simply create/register plugins via plain JavaScript objects.
 * @interface Chart.PluginBase
 * @deprecated since version 2.5.0
 * @todo remove at version 3
 * @private
 */
Chart.PluginBase = Chart.Element.extend({});

/**
 * Provided for backward compatibility, use Chart.helpers.canvas instead.
 * @namespace Chart.canvasHelpers
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */
Chart.canvasHelpers = Chart.helpers.canvas;

/**
 * Provided for backward compatibility, use Chart.layouts instead.
 * @namespace Chart.layoutService
 * @deprecated since version 2.8.0
 * @todo remove at version 3
 * @private
 */
Chart.layoutService = Chart.layouts;

},{"./core/core":"../node_modules/chart.js/src/core/core.js","./helpers/index":"../node_modules/chart.js/src/helpers/index.js","./core/core.helpers":"../node_modules/chart.js/src/core/core.helpers.js","./core/core.animation":"../node_modules/chart.js/src/core/core.animation.js","./core/core.animations":"../node_modules/chart.js/src/core/core.animations.js","./core/core.defaults":"../node_modules/chart.js/src/core/core.defaults.js","./core/core.element":"../node_modules/chart.js/src/core/core.element.js","./elements/index":"../node_modules/chart.js/src/elements/index.js","./core/core.interaction":"../node_modules/chart.js/src/core/core.interaction.js","./core/core.layouts":"../node_modules/chart.js/src/core/core.layouts.js","./platforms/platform":"../node_modules/chart.js/src/platforms/platform.js","./core/core.plugins":"../node_modules/chart.js/src/core/core.plugins.js","./core/core.scale":"../node_modules/chart.js/src/core/core.scale.js","./core/core.scaleService":"../node_modules/chart.js/src/core/core.scaleService.js","./core/core.ticks":"../node_modules/chart.js/src/core/core.ticks.js","./core/core.tooltip":"../node_modules/chart.js/src/core/core.tooltip.js","./core/core.controller":"../node_modules/chart.js/src/core/core.controller.js","./core/core.datasetController":"../node_modules/chart.js/src/core/core.datasetController.js","./scales/scale.linearbase":"../node_modules/chart.js/src/scales/scale.linearbase.js","./scales/scale.category":"../node_modules/chart.js/src/scales/scale.category.js","./scales/scale.linear":"../node_modules/chart.js/src/scales/scale.linear.js","./scales/scale.logarithmic":"../node_modules/chart.js/src/scales/scale.logarithmic.js","./scales/scale.radialLinear":"../node_modules/chart.js/src/scales/scale.radialLinear.js","./scales/scale.time":"../node_modules/chart.js/src/scales/scale.time.js","./controllers/controller.bar":"../node_modules/chart.js/src/controllers/controller.bar.js","./controllers/controller.bubble":"../node_modules/chart.js/src/controllers/controller.bubble.js","./controllers/controller.doughnut":"../node_modules/chart.js/src/controllers/controller.doughnut.js","./controllers/controller.line":"../node_modules/chart.js/src/controllers/controller.line.js","./controllers/controller.polarArea":"../node_modules/chart.js/src/controllers/controller.polarArea.js","./controllers/controller.radar":"../node_modules/chart.js/src/controllers/controller.radar.js","./controllers/controller.scatter":"../node_modules/chart.js/src/controllers/controller.scatter.js","./charts/Chart.Bar":"../node_modules/chart.js/src/charts/Chart.Bar.js","./charts/Chart.Bubble":"../node_modules/chart.js/src/charts/Chart.Bubble.js","./charts/Chart.Doughnut":"../node_modules/chart.js/src/charts/Chart.Doughnut.js","./charts/Chart.Line":"../node_modules/chart.js/src/charts/Chart.Line.js","./charts/Chart.PolarArea":"../node_modules/chart.js/src/charts/Chart.PolarArea.js","./charts/Chart.Radar":"../node_modules/chart.js/src/charts/Chart.Radar.js","./charts/Chart.Scatter":"../node_modules/chart.js/src/charts/Chart.Scatter.js","./plugins":"../node_modules/chart.js/src/plugins/index.js"}],"../node_modules/chartjs-plugin-deferred/dist/chartjs-plugin-deferred.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*
 * @license
 * chartjs-plugin-deferred
 * http://chartjs.org/
 * Version: 1.0.1
 *
 * Copyright 2018 Simon Brunel
 * Released under the MIT license
 * https://github.com/chartjs/chartjs-plugin-deferred/blob/master/LICENSE.md
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('chart.js')) :
	typeof define === 'function' && define.amd ? define(['chart.js'], factory) :
	(factory(global.Chart));
}(this, (function (Chart) { 'use strict';

Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;

'use strict';

var helpers = Chart.helpers;
var STUB_KEY = '$chartjs_deferred';
var MODEL_KEY = '$deferred';

/**
 * Plugin based on discussion from Chart.js issue #2745.
 * @see https://github.com/chartjs/Chart.js/issues/2745
 */
Chart.defaults.global.plugins.deferred = {
	xOffset: 0,
	yOffset: 0,
	delay: 0
};

function defer(fn, delay) {
	if (delay) {
		window.setTimeout(fn, delay);
	} else {
		helpers.requestAnimFrame.call(window, fn);
	}
}

function computeOffset(value, base) {
	var number = parseInt(value, 10);
	if (isNaN(number)) {
		return 0;
	} else if (typeof value === 'string' && value.indexOf('%') !== -1) {
		return number / 100 * base;
	}
	return number;
}

function chartInViewport(chart) {
	var options = chart[MODEL_KEY].options;
	var canvas = chart.chart.canvas;

	// http://stackoverflow.com/a/21696585
	if (!canvas || canvas.offsetParent === null) {
		return false;
	}

	var rect = canvas.getBoundingClientRect();
	var dy = computeOffset(options.yOffset || 0, rect.height);
	var dx = computeOffset(options.xOffset || 0, rect.width);

	return rect.right - dx >= 0
		&& rect.bottom - dy >= 0
		&& rect.left + dx <= window.innerWidth
		&& rect.top + dy <= window.innerHeight;
}

function onScroll(event) {
	var node = event.target;
	var stub = node[STUB_KEY];
	if (stub.ticking) {
		return;
	}

	stub.ticking = true;
	defer(function() {
		var charts = stub.charts.slice();
		var ilen = charts.length;
		var chart, i;

		for (i = 0; i < ilen; ++i) {
			chart = charts[i];
			if (chartInViewport(chart)) {
				unwatch(chart); // eslint-disable-line
				chart[MODEL_KEY].appeared = true;
				chart.update();
			}
		}

		stub.ticking = false;
	});
}

function isScrollable(node) {
	var type = node.nodeType;
	if (type === Node.ELEMENT_NODE) {
		var overflowX = helpers.getStyle(node, 'overflow-x');
		var overflowY = helpers.getStyle(node, 'overflow-y');
		return overflowX === 'auto' || overflowX === 'scroll'
			|| overflowY === 'auto' || overflowY === 'scroll';
	}

	return node.nodeType === Node.DOCUMENT_NODE;
}

function watch(chart) {
	var canvas = chart.chart.canvas;
	var parent = canvas.parentElement;
	var stub, charts;

	while (parent) {
		if (isScrollable(parent)) {
			stub = parent[STUB_KEY] || (parent[STUB_KEY] = {});
			charts = stub.charts || (stub.charts = []);
			if (charts.length === 0) {
				helpers.addEvent(parent, 'scroll', onScroll);
			}

			charts.push(chart);
			chart[MODEL_KEY].elements.push(parent);
		}

		parent = parent.parentElement || parent.ownerDocument;
	}
}

function unwatch(chart) {
	chart[MODEL_KEY].elements.forEach(function(element) {
		var charts = element[STUB_KEY].charts;
		charts.splice(charts.indexOf(chart), 1);
		if (!charts.length) {
			helpers.removeEvent(element, 'scroll', onScroll);
			delete element[STUB_KEY];
		}
	});

	chart[MODEL_KEY].elements = [];
}

Chart.plugins.register({
	id: 'deferred',

	beforeInit: function(chart, options) {
		chart[MODEL_KEY] = {
			options: options,
			appeared: false,
			delayed: false,
			loaded: false,
			elements: []
		};

		watch(chart);
	},

	beforeDatasetsUpdate: function(chart, options) {
		var model = chart[MODEL_KEY];
		if (!model.loaded) {
			if (!model.appeared && !chartInViewport(chart)) {
				// cancel the datasets update
				return false;
			}

			model.appeared = true;
			model.loaded = true;
			unwatch(chart);

			if (options.delay > 0) {
				model.delayed = true;
				defer(function() {
					model.delayed = false;
					chart.update();
				}, options.delay);

				return false;
			}
		}

		if (model.delayed) {
			// in case of delayed update, ensure to block external requests, such
			// as interacting with the legend label, or direct calls to update()
			return false;
		}
	},

	destroy: function(chart) {
		unwatch(chart);
	}
});

})));

},{"chart.js":"../node_modules/chart.js/src/chart.js"}],"js/frostbite2019/data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shortNames = exports.stages = exports.globalStats = exports.banPairs = exports.stageStats = void 0;
var stageStats = [{
  stage: 'Pokmon Stadium 2',
  shortName: 'PS2',
  gamesPlayed: 428,
  setsPlayed: 360,
  gamesBanned: 29,
  setsBanned: 27,
  starter: true
}, {
  stage: 'Smashville',
  shortName: 'SV',
  gamesPlayed: 124,
  setsPlayed: 114,
  gamesBanned: 92,
  setsBanned: 90,
  starter: true
}, {
  stage: 'Battlefield',
  shortName: 'BF',
  gamesPlayed: 161,
  setsPlayed: 149,
  gamesBanned: 117,
  setsBanned: 116,
  starter: true
}, {
  stage: 'Final Destination',
  shortName: 'FD',
  gamesPlayed: 79,
  setsPlayed: 75,
  gamesBanned: 201,
  setsBanned: 187,
  starter: true
}, {
  stage: 'Lylat Cruise',
  shortName: 'Lylat',
  gamesPlayed: 37,
  setsPlayed: 37,
  gamesBanned: 172,
  setsBanned: 170,
  starter: false
}, {
  stage: 'Town And City',
  shortName: 'T&C',
  gamesPlayed: 139,
  setsPlayed: 135,
  gamesBanned: 44,
  setsBanned: 44,
  starter: true
}, {
  stage: "Yoshi's Island (Brawl)",
  shortName: 'Y.Island',
  gamesPlayed: 20,
  setsPlayed: 20,
  gamesBanned: 218,
  setsBanned: 210,
  starter: false
}, {
  stage: 'Kalos Pokmon League',
  shortName: 'Kalos',
  gamesPlayed: 64,
  setsPlayed: 62,
  gamesBanned: 140,
  setsBanned: 140,
  starter: false
}, {
  stage: "Yoshi's Story",
  shortName: 'Y.Story',
  gamesPlayed: 31,
  setsPlayed: 31,
  gamesBanned: 141,
  setsBanned: 135,
  starter: false
}];
exports.stageStats = stageStats;
var banPairs = [{
  stageA: 'Pokmon Stadium 2',
  'Pokmon Stadium 2': 0,
  Smashville: 3,
  Battlefield: 5,
  'Final Destination': 7,
  'Lylat Cruise': 2,
  'Town And City': 5,
  "Yoshi's Island (Brawl)": 4,
  'Kalos Pokmon League': 1,
  "Yoshi's Story": 2
}, {
  stageA: 'Smashville',
  'Pokmon Stadium 2': 3,
  Smashville: 0,
  Battlefield: 5,
  'Final Destination': 22,
  'Lylat Cruise': 10,
  'Town And City': 6,
  "Yoshi's Island (Brawl)": 31,
  'Kalos Pokmon League': 6,
  "Yoshi's Story": 9
}, {
  stageA: 'Battlefield',
  'Pokmon Stadium 2': 5,
  Smashville: 5,
  Battlefield: 0,
  'Final Destination': 11,
  'Lylat Cruise': 19,
  'Town And City': 4,
  "Yoshi's Island (Brawl)": 18,
  'Kalos Pokmon League': 3,
  "Yoshi's Story": 52
}, {
  stageA: 'Final Destination',
  'Pokmon Stadium 2': 7,
  Smashville: 22,
  Battlefield: 11,
  'Final Destination': 0,
  'Lylat Cruise': 26,
  'Town And City': 13,
  "Yoshi's Island (Brawl)": 39,
  'Kalos Pokmon League': 74,
  "Yoshi's Story": 9
}, {
  stageA: 'Lylat Cruise',
  'Pokmon Stadium 2': 2,
  Smashville: 10,
  Battlefield: 19,
  'Final Destination': 26,
  'Lylat Cruise': 0,
  'Town And City': 6,
  "Yoshi's Island (Brawl)": 64,
  'Kalos Pokmon League': 20,
  "Yoshi's Story": 25
}, {
  stageA: 'Town And City',
  'Pokmon Stadium 2': 5,
  Smashville: 6,
  Battlefield: 4,
  'Final Destination': 13,
  'Lylat Cruise': 6,
  'Town And City': 0,
  "Yoshi's Island (Brawl)": 3,
  'Kalos Pokmon League': 7,
  "Yoshi's Story": 0
}, {
  stageA: "Yoshi's Island (Brawl)",
  'Pokmon Stadium 2': 4,
  Smashville: 31,
  Battlefield: 18,
  'Final Destination': 39,
  'Lylat Cruise': 64,
  'Town And City': 3,
  "Yoshi's Island (Brawl)": 0,
  'Kalos Pokmon League': 22,
  "Yoshi's Story": 37
}, {
  stageA: 'Kalos Pokmon League',
  'Pokmon Stadium 2': 1,
  Smashville: 6,
  Battlefield: 3,
  'Final Destination': 74,
  'Lylat Cruise': 20,
  'Town And City': 7,
  "Yoshi's Island (Brawl)": 22,
  'Kalos Pokmon League': 0,
  "Yoshi's Story": 7
}, {
  stageA: "Yoshi's Story",
  'Pokmon Stadium 2': 2,
  Smashville: 9,
  Battlefield: 52,
  'Final Destination': 9,
  'Lylat Cruise': 25,
  'Town And City': 0,
  "Yoshi's Island (Brawl)": 37,
  'Kalos Pokmon League': 7,
  "Yoshi's Story": 0
}];
exports.banPairs = banPairs;
var globalStats = {
  totalGames: 1083,
  totalSets: 535,
  totalBans: 1154,
  setsWithBanRecorded: 466,
  totalBanPairs: 577
};
exports.globalStats = globalStats;
var stages = ['Pokmon Stadium 2', 'Smashville', 'Battlefield', 'Final Destination', 'Lylat Cruise', 'Town And City', "Yoshi's Island (Brawl)", 'Kalos Pokmon League', "Yoshi's Story"];
exports.stages = stages;
var shortNames = ['PS2', 'SV', 'BF', 'FD', 'Lylat', 'T&C', 'Y.Island', 'Kalos', 'Y.Story'];
exports.shortNames = shortNames;
},{}],"js/frostbite2019/playrate-charts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderPlayRateCharts = void 0;

var _chart = _interopRequireDefault(require("chart.js"));

var _chartjsPluginDeferred = _interopRequireDefault(require("chartjs-plugin-deferred"));

var _data = require("./data");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RenderPlayRateCharts = function RenderPlayRateCharts() {
  var dataSortedByPlayed = Array.from(_data.stageStats).sort(function (a, b) {
    if (a.gamesPlayed > b.gamesPlayed) return -1;
    if (a.gamesPlayed < b.gamesPlayed) return 1;
    return 0;
  });
  var shortLabelsPlayed = dataSortedByPlayed.map(function (a) {
    return a.shortName;
  });
  var stageLabelsPlayed = dataSortedByPlayed.map(function (a) {
    return a.stage;
  });
  var gamesPlayedBars = new _chart.default(document.getElementById("games-played-bars").getContext('2d'), {
    type: 'horizontalBar',
    data: {
      labels: window.innerWidth < 640 ? shortLabelsPlayed : stageLabelsPlayed,
      datasets: [{
        data: dataSortedByPlayed.map(function (a) {
          return a.gamesPlayed;
        }),
        backgroundColor: 'RGBA(171, 0, 14, .8)',
        hoverBackgroundColor: 'RGBA(130, 16, 15, 1)',
        datalabels: {
          display: false
        }
      }]
    },
    options: {
      title: {
        text: 'Total Games Played'
      },
      legend: {
        display: false
      },
      plugins: {
        datalabels: {}
      }
    }
  });
  var setsPlayedBars = new _chart.default(document.getElementById("sets-played-bars").getContext('2d'), {
    type: 'horizontalBar',
    data: {
      labels: window.innerWidth < 640 ? shortLabelsPlayed : stageLabelsPlayed,
      datasets: [{
        data: dataSortedByPlayed.map(function (a) {
          return a.setsPlayed / _data.globalStats.totalSets * 100;
        }),
        backgroundColor: 'RGBA(171, 0, 14, .8)',
        hoverBackgroundColor: 'RGBA(130, 16, 15, 1)',
        datalabels: {
          display: false
        }
      }]
    },
    options: {
      title: {
        text: 'Played In % Of Sets'
      },
      legend: {
        display: false
      },
      plugins: {
        datalabels: {}
      }
    }
  });
};

exports.RenderPlayRateCharts = RenderPlayRateCharts;
},{"chart.js":"../node_modules/chart.js/src/chart.js","chartjs-plugin-deferred":"../node_modules/chartjs-plugin-deferred/dist/chartjs-plugin-deferred.js","./data":"js/frostbite2019/data.js"}],"../node_modules/tabulator-tables/dist/js/tabulator.js":[function(require,module,exports) {
var define;
var global = arguments[3];
var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/* Tabulator v4.2.0 (c) Oliver Folkerd */;(function(global,factory){if((typeof exports==='undefined'?'undefined':_typeof(exports))==='object'&&typeof module!=='undefined'){module.exports=factory();}else if(typeof define==='function'&&define.amd){define(factory);}else{global.Tabulator=factory();}})(this,function(){'use strict';// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
if(!Array.prototype.findIndex){Object.defineProperty(Array.prototype,'findIndex',{value:function value(predicate){// 1. Let O be ? ToObject(this value).
if(this==null){throw new TypeError('"this" is null or not defined');}var o=Object(this);// 2. Let len be ? ToLength(? Get(O, "length")).
var len=o.length>>>0;// 3. If IsCallable(predicate) is false, throw a TypeError exception.
if(typeof predicate!=='function'){throw new TypeError('predicate must be a function');}// 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
var thisArg=arguments[1];// 5. Let k be 0.
var k=0;// 6. Repeat, while k < len
while(k<len){// a. Let Pk be ! ToString(k).
// b. Let kValue be ? Get(O, Pk).
// c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
// d. If testResult is true, return k.
var kValue=o[k];if(predicate.call(thisArg,kValue,k,o)){return k;}// e. Increase k by 1.
k++;}// 7. Return -1.
return-1;}});}// https://tc39.github.io/ecma262/#sec-array.prototype.find
if(!Array.prototype.find){Object.defineProperty(Array.prototype,'find',{value:function value(predicate){// 1. Let O be ? ToObject(this value).
if(this==null){throw new TypeError('"this" is null or not defined');}var o=Object(this);// 2. Let len be ? ToLength(? Get(O, "length")).
var len=o.length>>>0;// 3. If IsCallable(predicate) is false, throw a TypeError exception.
if(typeof predicate!=='function'){throw new TypeError('predicate must be a function');}// 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
var thisArg=arguments[1];// 5. Let k be 0.
var k=0;// 6. Repeat, while k < len
while(k<len){// a. Let Pk be ! ToString(k).
// b. Let kValue be ? Get(O, Pk).
// c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
// d. If testResult is true, return kValue.
var kValue=o[k];if(predicate.call(thisArg,kValue,k,o)){return kValue;}// e. Increase k by 1.
k++;}// 7. Return undefined.
return undefined;}});}var ColumnManager=function ColumnManager(table){this.table=table;//hold parent table
this.headersElement=this.createHeadersElement();this.element=this.createHeaderElement();//containing element
this.rowManager=null;//hold row manager object
this.columns=[];// column definition object
this.columnsByIndex=[];//columns by index
this.columnsByField=[];//columns by field
this.scrollLeft=0;this.element.insertBefore(this.headersElement,this.element.firstChild);};////////////// Setup Functions /////////////////
ColumnManager.prototype.createHeadersElement=function(){var el=document.createElement("div");el.classList.add("tabulator-headers");return el;};ColumnManager.prototype.createHeaderElement=function(){var el=document.createElement("div");el.classList.add("tabulator-header");return el;};ColumnManager.prototype.initialize=function(){var self=this;//scroll body along with header
self.element.addEventListener("scroll",function(){self.table.rowManager.scrollHorizontal(self.element.scrollLeft);});};//link to row manager
ColumnManager.prototype.setRowManager=function(manager){this.rowManager=manager;};//return containing element
ColumnManager.prototype.getElement=function(){return this.element;};//return header containing element
ColumnManager.prototype.getHeadersElement=function(){return this.headersElement;};//scroll horizontally to match table body
ColumnManager.prototype.scrollHorizontal=function(left){var hozAdjust=0,scrollWidth=this.element.scrollWidth-this.table.element.clientWidth;this.element.scrollLeft=left;//adjust for vertical scrollbar moving table when present
if(left>scrollWidth){hozAdjust=left-scrollWidth;this.element.style.marginLeft=-hozAdjust+"px";}else{this.element.style.marginLeft=0;}//keep frozen columns fixed in position
//this._calcFrozenColumnsPos(hozAdjust + 3);
this.scrollLeft=left;if(this.table.modExists("frozenColumns")){this.table.modules.frozenColumns.layout();}};///////////// Column Setup Functions /////////////
ColumnManager.prototype.generateColumnsFromRowData=function(data){var cols=[],row,sorter;if(data&&data.length){row=data[0];for(var key in row){var col={field:key,title:key};var _value=row[key];switch(typeof _value==='undefined'?'undefined':_typeof(_value)){case"undefined":sorter="string";break;case"boolean":sorter="boolean";break;case"object":if(Array.isArray(_value)){sorter="array";}else{sorter="string";}break;default:if(!isNaN(_value)&&_value!==""){sorter="number";}else{if(_value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)){sorter="alphanum";}else{sorter="string";}}break;}col.sorter=sorter;cols.push(col);}this.table.options.columns=cols;this.setColumns(this.table.options.columns);}};ColumnManager.prototype.setColumns=function(cols,row){var self=this;while(self.headersElement.firstChild){self.headersElement.removeChild(self.headersElement.firstChild);}self.columns=[];self.columnsByIndex=[];self.columnsByField=[];//reset frozen columns
if(self.table.modExists("frozenColumns")){self.table.modules.frozenColumns.reset();}cols.forEach(function(def,i){self._addColumn(def);});self._reIndexColumns();if(self.table.options.responsiveLayout&&self.table.modExists("responsiveLayout",true)){self.table.modules.responsiveLayout.initialize();}self.redraw(true);};ColumnManager.prototype._addColumn=function(definition,before,nextToColumn){var column=new Column(definition,this),colEl=column.getElement(),index=nextToColumn?this.findColumnIndex(nextToColumn):nextToColumn;if(nextToColumn&&index>-1){var parentIndex=this.columns.indexOf(nextToColumn.getTopColumn());var nextEl=nextToColumn.getElement();if(before){this.columns.splice(parentIndex,0,column);nextEl.parentNode.insertBefore(colEl,nextEl);}else{this.columns.splice(parentIndex+1,0,column);nextEl.parentNode.insertBefore(colEl,nextEl.nextSibling);}}else{if(before){this.columns.unshift(column);this.headersElement.insertBefore(column.getElement(),this.headersElement.firstChild);}else{this.columns.push(column);this.headersElement.appendChild(column.getElement());}}return column;};ColumnManager.prototype.registerColumnField=function(col){if(col.definition.field){this.columnsByField[col.definition.field]=col;}};ColumnManager.prototype.registerColumnPosition=function(col){this.columnsByIndex.push(col);};ColumnManager.prototype._reIndexColumns=function(){this.columnsByIndex=[];this.columns.forEach(function(column){column.reRegisterPosition();});};//ensure column headers take up the correct amount of space in column groups
ColumnManager.prototype._verticalAlignHeaders=function(){var self=this,minHeight=0;self.columns.forEach(function(column){var height;column.clearVerticalAlign();height=column.getHeight();if(height>minHeight){minHeight=height;}});self.columns.forEach(function(column){column.verticalAlign(self.table.options.columnVertAlign,minHeight);});self.rowManager.adjustTableSize();};//////////////// Column Details /////////////////
ColumnManager.prototype.findColumn=function(subject){var self=this;if((typeof subject==='undefined'?'undefined':_typeof(subject))=="object"){if(subject instanceof Column){//subject is column element
return subject;}else if(subject instanceof ColumnComponent){//subject is public column component
return subject._getSelf()||false;}else if(subject instanceof HTMLElement){//subject is a HTML element of the column header
var match=self.columns.find(function(column){return column.element===subject;});return match||false;}}else{//subject should be treated as the field name of the column
return this.columnsByField[subject]||false;}//catch all for any other type of input
return false;};ColumnManager.prototype.getColumnByField=function(field){return this.columnsByField[field];};ColumnManager.prototype.getColumnByIndex=function(index){return this.columnsByIndex[index];};ColumnManager.prototype.getColumns=function(){return this.columns;};ColumnManager.prototype.findColumnIndex=function(column){return this.columnsByIndex.findIndex(function(col){return column===col;});};//return all columns that are not groups
ColumnManager.prototype.getRealColumns=function(){return this.columnsByIndex;};//travers across columns and call action
ColumnManager.prototype.traverse=function(callback){var self=this;self.columnsByIndex.forEach(function(column,i){callback(column,i);});};//get defintions of actual columns
ColumnManager.prototype.getDefinitions=function(active){var self=this,output=[];self.columnsByIndex.forEach(function(column){if(!active||active&&column.visible){output.push(column.getDefinition());}});return output;};//get full nested definition tree
ColumnManager.prototype.getDefinitionTree=function(){var self=this,output=[];self.columns.forEach(function(column){output.push(column.getDefinition(true));});return output;};ColumnManager.prototype.getComponents=function(structured){var self=this,output=[],columns=structured?self.columns:self.columnsByIndex;columns.forEach(function(column){output.push(column.getComponent());});return output;};ColumnManager.prototype.getWidth=function(){var width=0;this.columnsByIndex.forEach(function(column){if(column.visible){width+=column.getWidth();}});return width;};ColumnManager.prototype.moveColumn=function(from,to,after){this._moveColumnInArray(this.columns,from,to,after);this._moveColumnInArray(this.columnsByIndex,from,to,after,true);if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.initialize();}if(this.table.options.columnMoved){this.table.options.columnMoved.call(this.table,from.getComponent(),this.table.columnManager.getComponents());}if(this.table.options.persistentLayout&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("columns");}};ColumnManager.prototype._moveColumnInArray=function(columns,from,to,after,updateRows){var fromIndex=columns.indexOf(from),toIndex;if(fromIndex>-1){columns.splice(fromIndex,1);toIndex=columns.indexOf(to);if(toIndex>-1){if(after){toIndex=toIndex+1;}}else{toIndex=fromIndex;}columns.splice(toIndex,0,from);if(updateRows){this.table.rowManager.rows.forEach(function(row){if(row.cells.length){var cell=row.cells.splice(fromIndex,1)[0];row.cells.splice(toIndex,0,cell);}});}}};ColumnManager.prototype.scrollToColumn=function(column,position,ifVisible){var _this=this;var left=0,offset=0,adjust=0,colEl=column.getElement();return new Promise(function(resolve,reject){if(typeof position==="undefined"){position=_this.table.options.scrollToColumnPosition;}if(typeof ifVisible==="undefined"){ifVisible=_this.table.options.scrollToColumnIfVisible;}if(column.visible){//align to correct position
switch(position){case"middle":case"center":adjust=-_this.element.clientWidth/2;break;case"right":adjust=colEl.clientWidth-_this.headersElement.clientWidth;break;}//check column visibility
if(!ifVisible){offset=colEl.offsetLeft;if(offset>0&&offset+colEl.offsetWidth<_this.element.clientWidth){return false;}}//calculate scroll position
left=colEl.offsetLeft+_this.element.scrollLeft+adjust;left=Math.max(Math.min(left,_this.table.rowManager.element.scrollWidth-_this.table.rowManager.element.clientWidth),0);_this.table.rowManager.scrollHorizontal(left);_this.scrollHorizontal(left);resolve();}else{console.warn("Scroll Error - Column not visible");reject("Scroll Error - Column not visible");}});};//////////////// Cell Management /////////////////
ColumnManager.prototype.generateCells=function(row){var self=this;var cells=[];self.columnsByIndex.forEach(function(column){cells.push(column.generateCell(row));});return cells;};//////////////// Column Management /////////////////
ColumnManager.prototype.getFlexBaseWidth=function(){var self=this,totalWidth=self.table.element.clientWidth,//table element width
fixedWidth=0;//adjust for vertical scrollbar if present
if(self.rowManager.element.scrollHeight>self.rowManager.element.clientHeight){totalWidth-=self.rowManager.element.offsetWidth-self.rowManager.element.clientWidth;}this.columnsByIndex.forEach(function(column){var width,minWidth,colWidth;if(column.visible){width=column.definition.width||0;minWidth=typeof column.minWidth=="undefined"?self.table.options.columnMinWidth:parseInt(column.minWidth);if(typeof width=="string"){if(width.indexOf("%")>-1){colWidth=totalWidth/100*parseInt(width);}else{colWidth=parseInt(width);}}else{colWidth=width;}fixedWidth+=colWidth>minWidth?colWidth:minWidth;}});return fixedWidth;};ColumnManager.prototype.addColumn=function(definition,before,nextToColumn){var column=this._addColumn(definition,before,nextToColumn);this._reIndexColumns();if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.initialize();}if(this.table.modExists("columnCalcs")){this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);}this.redraw();if(this.table.modules.layout.getMode()!="fitColumns"){column.reinitializeWidth();}this._verticalAlignHeaders();this.table.rowManager.reinitialize();};//remove column from system
ColumnManager.prototype.deregisterColumn=function(column){var field=column.getField(),index;//remove from field list
if(field){delete this.columnsByField[field];}//remove from index list
index=this.columnsByIndex.indexOf(column);if(index>-1){this.columnsByIndex.splice(index,1);}//remove from column list
index=this.columns.indexOf(column);if(index>-1){this.columns.splice(index,1);}if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.initialize();}this.redraw();};//redraw columns
ColumnManager.prototype.redraw=function(force){if(force){if(Tabulator.prototype.helpers.elVisible(this.element)){this._verticalAlignHeaders();}this.table.rowManager.resetScroll();this.table.rowManager.reinitialize();}if(this.table.modules.layout.getMode()=="fitColumns"){this.table.modules.layout.layout();}else{if(force){this.table.modules.layout.layout();}else{if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.update();}}}if(this.table.modExists("frozenColumns")){this.table.modules.frozenColumns.layout();}if(this.table.modExists("columnCalcs")){this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);}if(force){if(this.table.options.persistentLayout&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("columns");}if(this.table.modExists("columnCalcs")){this.table.modules.columnCalcs.redraw();}}this.table.footerManager.redraw();};//public column object
var ColumnComponent=function ColumnComponent(column){this._column=column;this.type="ColumnComponent";};ColumnComponent.prototype.getElement=function(){return this._column.getElement();};ColumnComponent.prototype.getDefinition=function(){return this._column.getDefinition();};ColumnComponent.prototype.getField=function(){return this._column.getField();};ColumnComponent.prototype.getCells=function(){var cells=[];this._column.cells.forEach(function(cell){cells.push(cell.getComponent());});return cells;};ColumnComponent.prototype.getVisibility=function(){return this._column.visible;};ColumnComponent.prototype.show=function(){if(this._column.isGroup){this._column.columns.forEach(function(column){column.show();});}else{this._column.show();}};ColumnComponent.prototype.hide=function(){if(this._column.isGroup){this._column.columns.forEach(function(column){column.hide();});}else{this._column.hide();}};ColumnComponent.prototype.toggle=function(){if(this._column.visible){this.hide();}else{this.show();}};ColumnComponent.prototype.delete=function(){this._column.delete();};ColumnComponent.prototype.getSubColumns=function(){var output=[];if(this._column.columns.length){this._column.columns.forEach(function(column){output.push(column.getComponent());});}return output;};ColumnComponent.prototype.getParentColumn=function(){return this._column.parent instanceof Column?this._column.parent.getComponent():false;};ColumnComponent.prototype._getSelf=function(){return this._column;};ColumnComponent.prototype.scrollTo=function(){return this._column.table.columnManager.scrollToColumn(this._column);};ColumnComponent.prototype.getTable=function(){return this._column.table;};ColumnComponent.prototype.headerFilterFocus=function(){if(this._column.table.modExists("filter",true)){this._column.table.modules.filter.setHeaderFilterFocus(this._column);}};ColumnComponent.prototype.reloadHeaderFilter=function(){if(this._column.table.modExists("filter",true)){this._column.table.modules.filter.reloadHeaderFilter(this._column);}};ColumnComponent.prototype.setHeaderFilterValue=function(value){if(this._column.table.modExists("filter",true)){this._column.table.modules.filter.setHeaderFilterValue(this._column,value);}};ColumnComponent.prototype.getNextColumn=function(){return this._column.nextColumn().getComponent();};ColumnComponent.prototype.getPrevColumn=function(){return this._column.prevColumn().getComponent();};var Column=function Column(def,parent){var self=this;this.table=parent.table;this.definition=def;//column definition
this.parent=parent;//hold parent object
this.type="column";//type of element
this.columns=[];//child columns
this.cells=[];//cells bound to this column
this.element=this.createElement();//column header element
this.contentElement=false;this.groupElement=this.createGroupElement();//column group holder element
this.isGroup=false;this.tooltip=false;//hold column tooltip
this.hozAlign="";//horizontal text alignment
//multi dimentional filed handling
this.field="";this.fieldStructure="";this.getFieldValue="";this.setFieldValue="";this.setField(this.definition.field);this.modules={};//hold module variables;
this.cellEvents={cellClick:false,cellDblClick:false,cellContext:false,cellTap:false,cellDblTap:false,cellTapHold:false,cellMouseEnter:false,cellMouseLeave:false,cellMouseOver:false,cellMouseOut:false,cellMouseMove:false};this.width=null;//column width
this.widthStyled="";//column width prestyled to improve render efficiency
this.minWidth=null;//column minimum width
this.minWidthStyled="";//column minimum prestyled to improve render efficiency
this.widthFixed=false;//user has specified a width for this column
this.visible=true;//default visible state
//initialize column
if(def.columns){this.isGroup=true;def.columns.forEach(function(def,i){var newCol=new Column(def,self);self.attachColumn(newCol);});self.checkColumnVisibility();}else{parent.registerColumnField(this);}if(def.rowHandle&&this.table.options.movableRows!==false&&this.table.modExists("moveRow")){this.table.modules.moveRow.setHandle(true);}this._buildHeader();};Column.prototype.createElement=function(){var el=document.createElement("div");el.classList.add("tabulator-col");el.setAttribute("role","columnheader");el.setAttribute("aria-sort","none");return el;};Column.prototype.createGroupElement=function(){var el=document.createElement("div");el.classList.add("tabulator-col-group-cols");return el;};Column.prototype.setField=function(field){this.field=field;this.fieldStructure=field?this.table.options.nestedFieldSeparator?field.split(this.table.options.nestedFieldSeparator):[field]:[];this.getFieldValue=this.fieldStructure.length>1?this._getNestedData:this._getFlatData;this.setFieldValue=this.fieldStructure.length>1?this._setNesteData:this._setFlatData;};//register column position with column manager
Column.prototype.registerColumnPosition=function(column){this.parent.registerColumnPosition(column);};//register column position with column manager
Column.prototype.registerColumnField=function(column){this.parent.registerColumnField(column);};//trigger position registration
Column.prototype.reRegisterPosition=function(){if(this.isGroup){this.columns.forEach(function(column){column.reRegisterPosition();});}else{this.registerColumnPosition(this);}};Column.prototype.setTooltip=function(){var self=this,def=self.definition;//set header tooltips
var tooltip=def.headerTooltip||def.tooltip===false?def.headerTooltip:self.table.options.tooltipsHeader;if(tooltip){if(tooltip===true){if(def.field){self.table.modules.localize.bind("columns|"+def.field,function(value){self.element.setAttribute("title",value||def.title);});}else{self.element.setAttribute("title",def.title);}}else{if(typeof tooltip=="function"){tooltip=tooltip(self.getComponent());if(tooltip===false){tooltip="";}}self.element.setAttribute("title",tooltip);}}else{self.element.setAttribute("title","");}};//build header element
Column.prototype._buildHeader=function(){var self=this,def=self.definition;while(self.element.firstChild){self.element.removeChild(self.element.firstChild);}if(def.headerVertical){self.element.classList.add("tabulator-col-vertical");if(def.headerVertical==="flip"){self.element.classList.add("tabulator-col-vertical-flip");}}self.contentElement=self._bindEvents();self.contentElement=self._buildColumnHeaderContent();self.element.appendChild(self.contentElement);if(self.isGroup){self._buildGroupHeader();}else{self._buildColumnHeader();}self.setTooltip();//set resizable handles
if(self.table.options.resizableColumns&&self.table.modExists("resizeColumns")){self.table.modules.resizeColumns.initializeColumn("header",self,self.element);}//set resizable handles
if(def.headerFilter&&self.table.modExists("filter")&&self.table.modExists("edit")){if(typeof def.headerFilterPlaceholder!=="undefined"&&def.field){self.table.modules.localize.setHeaderFilterColumnPlaceholder(def.field,def.headerFilterPlaceholder);}self.table.modules.filter.initializeColumn(self);}//set resizable handles
if(self.table.modExists("frozenColumns")){self.table.modules.frozenColumns.initializeColumn(self);}//set movable column
if(self.table.options.movableColumns&&!self.isGroup&&self.table.modExists("moveColumn")){self.table.modules.moveColumn.initializeColumn(self);}//set calcs column
if((def.topCalc||def.bottomCalc)&&self.table.modExists("columnCalcs")){self.table.modules.columnCalcs.initializeColumn(self);}//update header tooltip on mouse enter
self.element.addEventListener("mouseenter",function(e){self.setTooltip();});};Column.prototype._bindEvents=function(){var self=this,def=self.definition,dblTap,tapHold,tap;//setup header click event bindings
if(typeof def.headerClick=="function"){self.element.addEventListener("click",function(e){def.headerClick(e,self.getComponent());});}if(typeof def.headerDblClick=="function"){self.element.addEventListener("dblclick",function(e){def.headerDblClick(e,self.getComponent());});}if(typeof def.headerContext=="function"){self.element.addEventListener("contextmenu",function(e){def.headerContext(e,self.getComponent());});}//setup header tap event bindings
if(typeof def.headerTap=="function"){tap=false;self.element.addEventListener("touchstart",function(e){tap=true;});self.element.addEventListener("touchend",function(e){if(tap){def.headerTap(e,self.getComponent());}tap=false;});}if(typeof def.headerDblTap=="function"){dblTap=null;self.element.addEventListener("touchend",function(e){if(dblTap){clearTimeout(dblTap);dblTap=null;def.headerDblTap(e,self.getComponent());}else{dblTap=setTimeout(function(){clearTimeout(dblTap);dblTap=null;},300);}});}if(typeof def.headerTapHold=="function"){tapHold=null;self.element.addEventListener("touchstart",function(e){clearTimeout(tapHold);tapHold=setTimeout(function(){clearTimeout(tapHold);tapHold=null;tap=false;def.headerTapHold(e,self.getComponent());},1000);});self.element.addEventListener("touchend",function(e){clearTimeout(tapHold);tapHold=null;});}//store column cell click event bindings
if(typeof def.cellClick=="function"){self.cellEvents.cellClick=def.cellClick;}if(typeof def.cellDblClick=="function"){self.cellEvents.cellDblClick=def.cellDblClick;}if(typeof def.cellContext=="function"){self.cellEvents.cellContext=def.cellContext;}//store column mouse event bindings
if(typeof def.cellMouseEnter=="function"){self.cellEvents.cellMouseEnter=def.cellMouseEnter;}if(typeof def.cellMouseLeave=="function"){self.cellEvents.cellMouseLeave=def.cellMouseLeave;}if(typeof def.cellMouseOver=="function"){self.cellEvents.cellMouseOver=def.cellMouseOver;}if(typeof def.cellMouseOut=="function"){self.cellEvents.cellMouseOut=def.cellMouseOut;}if(typeof def.cellMouseMove=="function"){self.cellEvents.cellMouseMove=def.cellMouseMove;}//setup column cell tap event bindings
if(typeof def.cellTap=="function"){self.cellEvents.cellTap=def.cellTap;}if(typeof def.cellDblTap=="function"){self.cellEvents.cellDblTap=def.cellDblTap;}if(typeof def.cellTapHold=="function"){self.cellEvents.cellTapHold=def.cellTapHold;}//setup column cell edit callbacks
if(typeof def.cellEdited=="function"){self.cellEvents.cellEdited=def.cellEdited;}if(typeof def.cellEditing=="function"){self.cellEvents.cellEditing=def.cellEditing;}if(typeof def.cellEditCancelled=="function"){self.cellEvents.cellEditCancelled=def.cellEditCancelled;}};//build header element for header
Column.prototype._buildColumnHeader=function(){var self=this,def=self.definition,table=self.table,sortable;//set column sorter
if(table.modExists("sort")){table.modules.sort.initializeColumn(self,self.contentElement);}//set column formatter
if(table.modExists("format")){table.modules.format.initializeColumn(self);}//set column editor
if(typeof def.editor!="undefined"&&table.modExists("edit")){table.modules.edit.initializeColumn(self);}//set colum validator
if(typeof def.validator!="undefined"&&table.modExists("validate")){table.modules.validate.initializeColumn(self);}//set column mutator
if(table.modExists("mutator")){table.modules.mutator.initializeColumn(self);}//set column accessor
if(table.modExists("accessor")){table.modules.accessor.initializeColumn(self);}//set respoviveLayout
if(_typeof(table.options.responsiveLayout)&&table.modExists("responsiveLayout")){table.modules.responsiveLayout.initializeColumn(self);}//set column visibility
if(typeof def.visible!="undefined"){if(def.visible){self.show(true);}else{self.hide(true);}}//asign additional css classes to column header
if(def.cssClass){var classeNames=def.cssClass.split(" ");classeNames.forEach(function(className){self.element.classList.add(className);});}if(def.field){this.element.setAttribute("tabulator-field",def.field);}//set min width if present
self.setMinWidth(typeof def.minWidth=="undefined"?self.table.options.columnMinWidth:parseInt(def.minWidth));self.reinitializeWidth();//set tooltip if present
self.tooltip=self.definition.tooltip||self.definition.tooltip===false?self.definition.tooltip:self.table.options.tooltips;//set orizontal text alignment
self.hozAlign=typeof self.definition.align=="undefined"?"":self.definition.align;};Column.prototype._buildColumnHeaderContent=function(){var self=this,def=self.definition,table=self.table;var contentElement=document.createElement("div");contentElement.classList.add("tabulator-col-content");contentElement.appendChild(self._buildColumnHeaderTitle());return contentElement;};//build title element of column
Column.prototype._buildColumnHeaderTitle=function(){var self=this,def=self.definition,table=self.table,title;var titleHolderElement=document.createElement("div");titleHolderElement.classList.add("tabulator-col-title");if(def.editableTitle){var titleElement=document.createElement("input");titleElement.classList.add("tabulator-title-editor");titleElement.addEventListener("click",function(e){e.stopPropagation();titleElement.focus();});titleElement.addEventListener("change",function(){def.title=titleElement.value;table.options.columnTitleChanged.call(self.table,self.getComponent());});titleHolderElement.appendChild(titleElement);if(def.field){table.modules.localize.bind("columns|"+def.field,function(text){titleElement.value=text||def.title||"&nbsp";});}else{titleElement.value=def.title||"&nbsp";}}else{if(def.field){table.modules.localize.bind("columns|"+def.field,function(text){self._formatColumnHeaderTitle(titleHolderElement,text||def.title||"&nbsp");});}else{self._formatColumnHeaderTitle(titleHolderElement,def.title||"&nbsp");}}return titleHolderElement;};Column.prototype._formatColumnHeaderTitle=function(el,title){var formatter,contents,params,mockCell;if(this.definition.titleFormatter&&this.table.modExists("format")){formatter=this.table.modules.format.getFormatter(this.definition.titleFormatter);mockCell={getValue:function getValue(){return title;},getElement:function getElement(){return el;}};params=this.definition.titleFormatterParams||{};params=typeof params==="function"?params():params;contents=formatter.call(this.table.modules.format,mockCell,params);switch(typeof contents==='undefined'?'undefined':_typeof(contents)){case"object":if(contents instanceof Node){this.element.appendChild(contents);}else{this.element.innerHTML="";console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:",contents);}break;case"undefined":case"null":this.element.innerHTML="";break;default:this.element.innerHTML=contents;}}else{el.innerHTML=title;}};//build header element for column group
Column.prototype._buildGroupHeader=function(){this.element.classList.add("tabulator-col-group");this.element.setAttribute("role","columngroup");this.element.setAttribute("aria-title",this.definition.title);this.element.appendChild(this.groupElement);};//flat field lookup
Column.prototype._getFlatData=function(data){return data[this.field];};//nested field lookup
Column.prototype._getNestedData=function(data){var dataObj=data,structure=this.fieldStructure,length=structure.length,output;for(var i=0;i<length;i++){dataObj=dataObj[structure[i]];output=dataObj;if(!dataObj){break;}}return output;};//flat field set
Column.prototype._setFlatData=function(data,value){if(this.field){data[this.field]=value;}};//nested field set
Column.prototype._setNesteData=function(data,value){var dataObj=data,structure=this.fieldStructure,length=structure.length;for(var i=0;i<length;i++){if(i==length-1){dataObj[structure[i]]=value;}else{if(!dataObj[structure[i]]){dataObj[structure[i]]={};}dataObj=dataObj[structure[i]];}}};//attach column to this group
Column.prototype.attachColumn=function(column){var self=this;if(self.groupElement){self.columns.push(column);self.groupElement.appendChild(column.getElement());}else{console.warn("Column Warning - Column being attached to another column instead of column group");}};//vertically align header in column
Column.prototype.verticalAlign=function(alignment,height){//calculate height of column header and group holder element
var parentHeight=this.parent.isGroup?this.parent.getGroupElement().clientHeight:height||this.parent.getHeadersElement().clientHeight;// var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : this.parent.getHeadersElement().clientHeight;
this.element.style.height=parentHeight+"px";if(this.isGroup){this.groupElement.style.minHeight=parentHeight-this.contentElement.offsetHeight+"px";}//vertically align cell contents
if(!this.isGroup&&alignment!=="top"){if(alignment==="bottom"){this.element.style.paddingTop=this.element.clientHeight-this.contentElement.offsetHeight+"px";}else{this.element.style.paddingTop=(this.element.clientHeight-this.contentElement.offsetHeight)/2+"px";}}this.columns.forEach(function(column){column.verticalAlign(alignment);});};//clear vertical alignmenet
Column.prototype.clearVerticalAlign=function(){this.element.style.paddingTop="";this.element.style.height="";this.element.style.minHeight="";this.groupElement.style.minHeight="";this.columns.forEach(function(column){column.clearVerticalAlign();});};//// Retreive Column Information ////
//return column header element
Column.prototype.getElement=function(){return this.element;};//return colunm group element
Column.prototype.getGroupElement=function(){return this.groupElement;};//return field name
Column.prototype.getField=function(){return this.field;};//return the first column in a group
Column.prototype.getFirstColumn=function(){if(!this.isGroup){return this;}else{if(this.columns.length){return this.columns[0].getFirstColumn();}else{return false;}}};//return the last column in a group
Column.prototype.getLastColumn=function(){if(!this.isGroup){return this;}else{if(this.columns.length){return this.columns[this.columns.length-1].getLastColumn();}else{return false;}}};//return all columns in a group
Column.prototype.getColumns=function(){return this.columns;};//return all columns in a group
Column.prototype.getCells=function(){return this.cells;};//retreive the top column in a group of columns
Column.prototype.getTopColumn=function(){if(this.parent.isGroup){return this.parent.getTopColumn();}else{return this;}};//return column definition object
Column.prototype.getDefinition=function(updateBranches){var colDefs=[];if(this.isGroup&&updateBranches){this.columns.forEach(function(column){colDefs.push(column.getDefinition(true));});this.definition.columns=colDefs;}return this.definition;};//////////////////// Actions ////////////////////
Column.prototype.checkColumnVisibility=function(){var visible=false;this.columns.forEach(function(column){if(column.visible){visible=true;}});if(visible){this.show();this.parent.table.options.columnVisibilityChanged.call(this.table,this.getComponent(),false);}else{this.hide();}};//show column
Column.prototype.show=function(silent,responsiveToggle){if(!this.visible){this.visible=true;this.element.style.display="";if(this.parent.isGroup){this.parent.checkColumnVisibility();}this.cells.forEach(function(cell){cell.show();});if(!this.isGroup&&this.width===null){this.reinitializeWidth();}this.table.columnManager._verticalAlignHeaders();if(this.table.options.persistentLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.persistence.save("columns");}if(!responsiveToggle&&this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.updateColumnVisibility(this,this.visible);}if(!silent){this.table.options.columnVisibilityChanged.call(this.table,this.getComponent(),true);}}};//hide column
Column.prototype.hide=function(silent,responsiveToggle){if(this.visible){this.visible=false;this.element.style.display="none";this.table.columnManager._verticalAlignHeaders();if(this.parent.isGroup){this.parent.checkColumnVisibility();}this.cells.forEach(function(cell){cell.hide();});if(this.table.options.persistentLayout&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("columns");}if(!responsiveToggle&&this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.updateColumnVisibility(this,this.visible);}if(!silent){this.table.options.columnVisibilityChanged.call(this.table,this.getComponent(),false);}}};Column.prototype.matchChildWidths=function(){var childWidth=0;if(this.contentElement&&this.columns.length){this.columns.forEach(function(column){childWidth+=column.getWidth();});this.contentElement.style.maxWidth=childWidth-1+"px";}};Column.prototype.setWidth=function(width){this.widthFixed=true;this.setWidthActual(width);};Column.prototype.setWidthActual=function(width){if(isNaN(width)){width=Math.floor(this.table.element.clientWidth/100*parseInt(width));}width=Math.max(this.minWidth,width);this.width=width;this.widthStyled=width?width+"px":"";this.element.style.width=this.widthStyled;if(!this.isGroup){this.cells.forEach(function(cell){cell.setWidth();});}if(this.parent.isGroup){this.parent.matchChildWidths();}//set resizable handles
if(this.table.modExists("frozenColumns")){this.table.modules.frozenColumns.layout();}};Column.prototype.checkCellHeights=function(){var rows=[];this.cells.forEach(function(cell){if(cell.row.heightInitialized){if(cell.row.getElement().offsetParent!==null){rows.push(cell.row);cell.row.clearCellHeight();}else{cell.row.heightInitialized=false;}}});rows.forEach(function(row){row.calcHeight();});rows.forEach(function(row){row.setCellHeight();});};Column.prototype.getWidth=function(){// return this.element.offsetWidth;
return this.width;};Column.prototype.getHeight=function(){return this.element.offsetHeight;};Column.prototype.setMinWidth=function(minWidth){this.minWidth=minWidth;this.minWidthStyled=minWidth?minWidth+"px":"";this.element.style.minWidth=this.minWidthStyled;this.cells.forEach(function(cell){cell.setMinWidth();});};Column.prototype.delete=function(){if(this.isGroup){this.columns.forEach(function(column){column.delete();});}var cellCount=this.cells.length;for(var i=0;i<cellCount;i++){this.cells[0].delete();}this.element.parentNode.removeChild(this.element);this.table.columnManager.deregisterColumn(this);};//////////////// Cell Management /////////////////
//generate cell for this column
Column.prototype.generateCell=function(row){var self=this;var cell=new Cell(self,row);this.cells.push(cell);return cell;};Column.prototype.nextColumn=function(){var index=this.table.columnManager.findColumnIndex(this);return index>-1?this.table.columnManager.getColumnByIndex(index+1):false;};Column.prototype.prevColumn=function(){var index=this.table.columnManager.findColumnIndex(this);return index>-1?this.table.columnManager.getColumnByIndex(index-1):false;};Column.prototype.reinitializeWidth=function(force){this.widthFixed=false;//set width if present
if(typeof this.definition.width!=="undefined"&&!force){this.setWidth(this.definition.width);}//hide header filters to prevent them altering column width
if(this.table.modExists("filter")){this.table.modules.filter.hideHeaderFilterElements();}this.fitToData();//show header filters again after layout is complete
if(this.table.modExists("filter")){this.table.modules.filter.showHeaderFilterElements();}};//set column width to maximum cell width
Column.prototype.fitToData=function(){var self=this;if(!this.widthFixed){this.element.style.width="";self.cells.forEach(function(cell){cell.clearWidth();});}var maxWidth=this.element.offsetWidth;if(!self.width||!this.widthFixed){self.cells.forEach(function(cell){var width=cell.getWidth();if(width>maxWidth){maxWidth=width;}});if(maxWidth){self.setWidthActual(maxWidth+1);}}};Column.prototype.deleteCell=function(cell){var index=this.cells.indexOf(cell);if(index>-1){this.cells.splice(index,1);}};Column.prototype.defaultOptionList=["title","field","visible","align","width","minWidth","widthGrow","widthShrink","resizable","frozen","responsive","tooltip","cssClass","rowHandle","hideInHtml","sorter","sorterParams","formatter","formatterParams","variableHeight","editable","editor","editorParams","validator","mutator","mutatorParams","mutatorData","mutatorDataParams","mutatorEdit","mutatorEditParams","mutatorClipboard","mutatorClipboardParams","accessor","accessorParams","accessorData","accessorDataParams","accessorDownload","accessorDownloadParams","accessorClipboard","accessorClipboardParams","download","downloadTitle","topCalc","topCalcParams","topCalcFormatter","topCalcFormatterParams","bottomCalc","bottomCalcParams","bottomCalcFormatter","bottomCalcFormatterParams","cellClick","cellDblClick","cellContext","cellTap","cellDblTap","cellTapHold","cellMouseEnter","cellMouseLeave","cellMouseOver","cellMouseOut","cellMouseMove","cellEditing","cellEdited","cellEditCancelled","headerSort","headerSortStartingDir","headerSortTristate","headerClick","headerDblClick","headerContext","headerTap","headerDblTap","headerTapHold","headerTooltip","headerVertical","editableTitle","titleFormatter","titleFormatterParams","headerFilter","headerFilterPlaceholder","headerFilterParams","headerFilterEmptyCheck","headerFilterFunc","headerFilterFuncParams","headerFilterLiveFilter"];//////////////// Event Bindings /////////////////
//////////////// Object Generation /////////////////
Column.prototype.getComponent=function(){return new ColumnComponent(this);};var RowManager=function RowManager(table){this.table=table;this.element=this.createHolderElement();//containing element
this.tableElement=this.createTableElement();//table element
this.columnManager=null;//hold column manager object
this.height=0;//hold height of table element
this.firstRender=false;//handle first render
this.renderMode="classic";//current rendering mode
this.rows=[];//hold row data objects
this.activeRows=[];//rows currently available to on display in the table
this.activeRowsCount=0;//count of active rows
this.displayRows=[];//rows currently on display in the table
this.displayRowsCount=0;//count of display rows
this.scrollTop=0;this.scrollLeft=0;this.vDomRowHeight=20;//approximation of row heights for padding
this.vDomTop=0;//hold position for first rendered row in the virtual DOM
this.vDomBottom=0;//hold possition for last rendered row in the virtual DOM
this.vDomScrollPosTop=0;//last scroll position of the vDom top;
this.vDomScrollPosBottom=0;//last scroll position of the vDom bottom;
this.vDomTopPad=0;//hold value of padding for top of virtual DOM
this.vDomBottomPad=0;//hold value of padding for bottom of virtual DOM
this.vDomMaxRenderChain=90;//the maximum number of dom elements that can be rendered in 1 go
this.vDomWindowBuffer=0;//window row buffer before removing elements, to smooth scrolling
this.vDomWindowMinTotalRows=20;//minimum number of rows to be generated in virtual dom (prevent buffering issues on tables with tall rows)
this.vDomWindowMinMarginRows=5;//minimum number of rows to be generated in virtual dom margin
this.vDomTopNewRows=[];//rows to normalize after appending to optimize render speed
this.vDomBottomNewRows=[];//rows to normalize after appending to optimize render speed
};//////////////// Setup Functions /////////////////
RowManager.prototype.createHolderElement=function(){var el=document.createElement("div");el.classList.add("tabulator-tableHolder");el.setAttribute("tabindex",0);return el;};RowManager.prototype.createTableElement=function(){var el=document.createElement("div");el.classList.add("tabulator-table");return el;};//return containing element
RowManager.prototype.getElement=function(){return this.element;};//return table element
RowManager.prototype.getTableElement=function(){return this.tableElement;};//return position of row in table
RowManager.prototype.getRowPosition=function(row,active){if(active){return this.activeRows.indexOf(row);}else{return this.rows.indexOf(row);}};//link to column manager
RowManager.prototype.setColumnManager=function(manager){this.columnManager=manager;};RowManager.prototype.initialize=function(){var self=this;self.setRenderMode();//initialize manager
self.element.appendChild(self.tableElement);self.firstRender=true;//scroll header along with table body
self.element.addEventListener("scroll",function(){var left=self.element.scrollLeft;//handle horizontal scrolling
if(self.scrollLeft!=left){self.columnManager.scrollHorizontal(left);if(self.table.options.groupBy){self.table.modules.groupRows.scrollHeaders(left);}if(self.table.modExists("columnCalcs")){self.table.modules.columnCalcs.scrollHorizontal(left);}}self.scrollLeft=left;});//handle virtual dom scrolling
if(this.renderMode==="virtual"){self.element.addEventListener("scroll",function(){var top=self.element.scrollTop;var dir=self.scrollTop>top;//handle verical scrolling
if(self.scrollTop!=top){self.scrollTop=top;self.scrollVertical(dir);if(self.table.options.ajaxProgressiveLoad=="scroll"){self.table.modules.ajax.nextPage(self.element.scrollHeight-self.element.clientHeight-top);}}else{self.scrollTop=top;}});}};////////////////// Row Manipulation //////////////////
RowManager.prototype.findRow=function(subject){var self=this;if((typeof subject==='undefined'?'undefined':_typeof(subject))=="object"){if(subject instanceof Row){//subject is row element
return subject;}else if(subject instanceof RowComponent){//subject is public row component
return subject._getSelf()||false;}else if(subject instanceof HTMLElement){//subject is a HTML element of the row
var match=self.rows.find(function(row){return row.element===subject;});return match||false;}}else if(typeof subject=="undefined"||subject===null){return false;}else{//subject should be treated as the index of the row
var _match=self.rows.find(function(row){return row.data[self.table.options.index]==subject;});return _match||false;}//catch all for any other type of input
return false;};RowManager.prototype.getRowFromDataObject=function(data){var match=this.rows.find(function(row){return row.data===data;});return match||false;};RowManager.prototype.getRowFromPosition=function(position,active){if(active){return this.activeRows[position];}else{return this.rows[position];}};RowManager.prototype.scrollToRow=function(row,position,ifVisible){var _this2=this;var rowIndex=this.getDisplayRows().indexOf(row),rowEl=row.getElement(),rowTop,offset=0;return new Promise(function(resolve,reject){if(rowIndex>-1){if(typeof position==="undefined"){position=_this2.table.options.scrollToRowPosition;}if(typeof ifVisible==="undefined"){ifVisible=_this2.table.options.scrollToRowIfVisible;}if(position==="nearest"){switch(_this2.renderMode){case"classic":rowTop=Tabulator.prototype.helpers.elOffset(rowEl).top;position=Math.abs(_this2.element.scrollTop-rowTop)>Math.abs(_this2.element.scrollTop+_this2.element.clientHeight-rowTop)?"bottom":"top";break;case"virtual":position=Math.abs(_this2.vDomTop-rowIndex)>Math.abs(_this2.vDomBottom-rowIndex)?"bottom":"top";break;}}//check row visibility
if(!ifVisible){if(Tabulator.prototype.helpers.elVisible(rowEl)){offset=Tabulator.prototype.helpers.elOffset(rowEl).top-Tabulator.prototype.helpers.elOffset(_this2.element).top;if(offset>0&&offset<_this2.element.clientHeight-rowEl.offsetHeight){return false;}}}//scroll to row
switch(_this2.renderMode){case"classic":_this2.element.scrollTop=Tabulator.prototype.helpers.elOffset(rowEl).top-Tabulator.prototype.helpers.elOffset(_this2.element).top+_this2.element.scrollTop;break;case"virtual":_this2._virtualRenderFill(rowIndex,true);break;}//align to correct position
switch(position){case"middle":case"center":_this2.element.scrollTop=_this2.element.scrollTop-_this2.element.clientHeight/2;break;case"bottom":_this2.element.scrollTop=_this2.element.scrollTop-_this2.element.clientHeight+rowEl.offsetHeight;break;}resolve();}else{console.warn("Scroll Error - Row not visible");reject("Scroll Error - Row not visible");}});};////////////////// Data Handling //////////////////
RowManager.prototype.setData=function(data,renderInPosition){var _this3=this;var self=this;return new Promise(function(resolve,reject){if(renderInPosition&&_this3.getDisplayRows().length){if(self.table.options.pagination){self._setDataActual(data,true);}else{_this3.reRenderInPosition(function(){self._setDataActual(data);});}}else{if(_this3.table.options.autoColumns){_this3.table.columnManager.generateColumnsFromRowData(data);}_this3.resetScroll();_this3._setDataActual(data);}resolve();});};RowManager.prototype._setDataActual=function(data,renderInPosition){var self=this;self.table.options.dataLoading.call(this.table,data);self.rows.forEach(function(row){row.wipe();});self.rows=[];if(this.table.options.history&&this.table.modExists("history")){this.table.modules.history.clear();}if(Array.isArray(data)){if(this.table.modExists("selectRow")){this.table.modules.selectRow.clearSelectionData();}if(this.table.options.reactiveData&&this.table.modExists("reactiveData",true)){this.table.modules.reactiveData.watchData(data);}data.forEach(function(def,i){if(def&&(typeof def==='undefined'?'undefined':_typeof(def))==="object"){var row=new Row(def,self);self.rows.push(row);}else{console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:",def);}});self.table.options.dataLoaded.call(this.table,data);self.refreshActiveData(false,false,renderInPosition);}else{console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ",typeof data==='undefined'?'undefined':_typeof(data),"\nData:     ",data);}};RowManager.prototype.deleteRow=function(row,blockRedraw){var allIndex=this.rows.indexOf(row),activeIndex=this.activeRows.indexOf(row);if(activeIndex>-1){this.activeRows.splice(activeIndex,1);}if(allIndex>-1){this.rows.splice(allIndex,1);}this.setActiveRows(this.activeRows);this.displayRowIterator(function(rows){var displayIndex=rows.indexOf(row);if(displayIndex>-1){rows.splice(displayIndex,1);}});if(!blockRedraw){this.reRenderInPosition();}this.table.options.rowDeleted.call(this.table,row.getComponent());this.table.options.dataEdited.call(this.table,this.getData());if(this.table.options.groupBy&&this.table.modExists("groupRows")){this.table.modules.groupRows.updateGroupRows(true);}else if(this.table.options.pagination&&this.table.modExists("page")){this.refreshActiveData(false,false,true);}else{if(this.table.options.pagination&&this.table.modExists("page")){this.refreshActiveData("page");}}};RowManager.prototype.addRow=function(data,pos,index,blockRedraw){var row=this.addRowActual(data,pos,index,blockRedraw);if(this.table.options.history&&this.table.modExists("history")){this.table.modules.history.action("rowAdd",row,{data:data,pos:pos,index:index});}return row;};//add multiple rows
RowManager.prototype.addRows=function(data,pos,index){var _this4=this;var self=this,length=0,rows=[];return new Promise(function(resolve,reject){pos=_this4.findAddRowPos(pos);if(!Array.isArray(data)){data=[data];}length=data.length-1;if(typeof index=="undefined"&&pos||typeof index!=="undefined"&&!pos){data.reverse();}data.forEach(function(item,i){var row=self.addRow(item,pos,index,true);rows.push(row);});if(_this4.table.options.groupBy&&_this4.table.modExists("groupRows")){_this4.table.modules.groupRows.updateGroupRows(true);}else if(_this4.table.options.pagination&&_this4.table.modExists("page")){_this4.refreshActiveData(false,false,true);}else{_this4.reRenderInPosition();}//recalc column calculations if present
if(_this4.table.modExists("columnCalcs")){_this4.table.modules.columnCalcs.recalc(_this4.table.rowManager.activeRows);}resolve(rows);});};RowManager.prototype.findAddRowPos=function(pos){if(typeof pos==="undefined"){pos=this.table.options.addRowPos;}if(pos==="pos"){pos=true;}if(pos==="bottom"){pos=false;}return pos;};RowManager.prototype.addRowActual=function(data,pos,index,blockRedraw){var row=data instanceof Row?data:new Row(data||{},this),top=this.findAddRowPos(pos),dispRows;if(!index&&this.table.options.pagination&&this.table.options.paginationAddRow=="page"){dispRows=this.getDisplayRows();if(top){if(dispRows.length){index=dispRows[0];}else{if(this.activeRows.length){index=this.activeRows[this.activeRows.length-1];top=false;}}}else{if(dispRows.length){index=dispRows[dispRows.length-1];top=dispRows.length<this.table.modules.page.getPageSize()?false:true;}}}if(index){index=this.findRow(index);}if(this.table.options.groupBy&&this.table.modExists("groupRows")){this.table.modules.groupRows.assignRowToGroup(row);var groupRows=row.getGroup().rows;if(groupRows.length>1){if(!index||index&&groupRows.indexOf(index)==-1){if(top){if(groupRows[0]!==row){index=groupRows[0];this._moveRowInArray(row.getGroup().rows,row,index,top);}}else{if(groupRows[groupRows.length-1]!==row){index=groupRows[groupRows.length-1];this._moveRowInArray(row.getGroup().rows,row,index,top);}}}else{this._moveRowInArray(row.getGroup().rows,row,index,top);}}}if(index){var allIndex=this.rows.indexOf(index),activeIndex=this.activeRows.indexOf(index);this.displayRowIterator(function(rows){var displayIndex=rows.indexOf(index);if(displayIndex>-1){rows.splice(top?displayIndex:displayIndex+1,0,row);}});if(activeIndex>-1){this.activeRows.splice(top?activeIndex:activeIndex+1,0,row);}if(allIndex>-1){this.rows.splice(top?allIndex:allIndex+1,0,row);}}else{if(top){this.displayRowIterator(function(rows){rows.unshift(row);});this.activeRows.unshift(row);this.rows.unshift(row);}else{this.displayRowIterator(function(rows){rows.push(row);});this.activeRows.push(row);this.rows.push(row);}}this.setActiveRows(this.activeRows);this.table.options.rowAdded.call(this.table,row.getComponent());this.table.options.dataEdited.call(this.table,this.getData());if(!blockRedraw){this.reRenderInPosition();}return row;};RowManager.prototype.moveRow=function(from,to,after){if(this.table.options.history&&this.table.modExists("history")){this.table.modules.history.action("rowMove",from,{pos:this.getRowPosition(from),to:to,after:after});}this.moveRowActual(from,to,after);this.table.options.rowMoved.call(this.table,from.getComponent());};RowManager.prototype.moveRowActual=function(from,to,after){var self=this;this._moveRowInArray(this.rows,from,to,after);this._moveRowInArray(this.activeRows,from,to,after);this.displayRowIterator(function(rows){self._moveRowInArray(rows,from,to,after);});if(this.table.options.groupBy&&this.table.modExists("groupRows")){var toGroup=to.getGroup();var fromGroup=from.getGroup();if(toGroup===fromGroup){this._moveRowInArray(toGroup.rows,from,to,after);}else{if(fromGroup){fromGroup.removeRow(from);}toGroup.insertRow(from,to,after);}}};RowManager.prototype._moveRowInArray=function(rows,from,to,after){var fromIndex,toIndex,start,end;if(from!==to){fromIndex=rows.indexOf(from);if(fromIndex>-1){rows.splice(fromIndex,1);toIndex=rows.indexOf(to);if(toIndex>-1){if(after){rows.splice(toIndex+1,0,from);}else{rows.splice(toIndex,0,from);}}else{rows.splice(fromIndex,0,from);}}//restyle rows
if(rows===this.getDisplayRows()){start=fromIndex<toIndex?fromIndex:toIndex;end=toIndex>fromIndex?toIndex:fromIndex+1;for(var i=start;i<=end;i++){if(rows[i]){this.styleRow(rows[i],i);}}}}};RowManager.prototype.clearData=function(){this.setData([]);};RowManager.prototype.getRowIndex=function(row){return this.findRowIndex(row,this.rows);};RowManager.prototype.getDisplayRowIndex=function(row){var index=this.getDisplayRows().indexOf(row);return index>-1?index:false;};RowManager.prototype.nextDisplayRow=function(row,rowOnly){var index=this.getDisplayRowIndex(row),nextRow=false;if(index!==false&&index<this.displayRowsCount-1){nextRow=this.getDisplayRows()[index+1];}if(nextRow&&(!(nextRow instanceof Row)||nextRow.type!="row")){return this.nextDisplayRow(nextRow,rowOnly);}return nextRow;};RowManager.prototype.prevDisplayRow=function(row,rowOnly){var index=this.getDisplayRowIndex(row),prevRow=false;if(index){prevRow=this.getDisplayRows()[index-1];}if(prevRow&&(!(prevRow instanceof Row)||prevRow.type!="row")){return this.prevDisplayRow(prevRow,rowOnly);}return prevRow;};RowManager.prototype.findRowIndex=function(row,list){var rowIndex;row=this.findRow(row);if(row){rowIndex=list.indexOf(row);if(rowIndex>-1){return rowIndex;}}return false;};RowManager.prototype.getData=function(active,transform){var self=this,output=[];var rows=active?self.activeRows:self.rows;rows.forEach(function(row){output.push(row.getData(transform||"data"));});return output;};RowManager.prototype.getHtml=function(active){var data=this.getData(active),columns=[],header="",body="",table="";//build header row
this.table.columnManager.getColumns().forEach(function(column){var def=column.getDefinition();if(column.visible&&!def.hideInHtml){header+='<th>'+(def.title||"")+'</th>';columns.push(column);}});//build body rows
data.forEach(function(rowData){var row="";columns.forEach(function(column){var value=column.getFieldValue(rowData);if(typeof value==="undefined"||value===null){value=":";}row+='<td>'+value+'</td>';});body+='<tr>'+row+'</tr>';});//build table
table='<table>\n\n\t\t\t<thead>\n\n\t\t\t<tr>'+header+'</tr>\n\n\t\t\t</thead>\n\n\t\t\t<tbody>'+body+'</tbody>\n\n\t\t\t</table>';return table;};RowManager.prototype.getComponents=function(active){var self=this,output=[];var rows=active?self.activeRows:self.rows;rows.forEach(function(row){output.push(row.getComponent());});return output;};RowManager.prototype.getDataCount=function(active){return active?this.rows.length:this.activeRows.length;};RowManager.prototype._genRemoteRequest=function(){var self=this,table=self.table,options=table.options,params={};if(table.modExists("page")){//set sort data if defined
if(options.ajaxSorting){var sorters=self.table.modules.sort.getSort();sorters.forEach(function(item){delete item.column;});params[self.table.modules.page.paginationDataSentNames.sorters]=sorters;}//set filter data if defined
if(options.ajaxFiltering){var filters=self.table.modules.filter.getFilters(true,true);params[self.table.modules.page.paginationDataSentNames.filters]=filters;}self.table.modules.ajax.setParams(params,true);}table.modules.ajax.sendRequest().then(function(data){self.setData(data);}).catch(function(e){});};//choose the path to refresh data after a filter update
RowManager.prototype.filterRefresh=function(){var table=this.table,options=table.options,left=this.scrollLeft;if(options.ajaxFiltering){if(options.pagination=="remote"&&table.modExists("page")){table.modules.page.reset(true);table.modules.page.setPage(1).then(function(){}).catch(function(){});}else if(options.ajaxProgressiveLoad){table.modules.ajax.loadData().then(function(){}).catch(function(){});}else{//assume data is url, make ajax call to url to get data
this._genRemoteRequest();}}else{this.refreshActiveData("filter");}this.scrollHorizontal(left);};//choose the path to refresh data after a sorter update
RowManager.prototype.sorterRefresh=function(loadOrignalData){var table=this.table,options=this.table.options,left=this.scrollLeft;if(options.ajaxSorting){if((options.pagination=="remote"||options.progressiveLoad)&&table.modExists("page")){table.modules.page.reset(true);table.modules.page.setPage(1).then(function(){}).catch(function(){});}else if(options.ajaxProgressiveLoad){table.modules.ajax.loadData().then(function(){}).catch(function(){});}else{//assume data is url, make ajax call to url to get data
this._genRemoteRequest();}}else{this.refreshActiveData(loadOrignalData?"filter":"sort");}this.scrollHorizontal(left);};RowManager.prototype.scrollHorizontal=function(left){this.scrollLeft=left;this.element.scrollLeft=left;if(this.table.options.groupBy){this.table.modules.groupRows.scrollHeaders(left);}if(this.table.modExists("columnCalcs")){this.table.modules.columnCalcs.scrollHorizontal(left);}};//set active data set
RowManager.prototype.refreshActiveData=function(stage,skipStage,renderInPosition){var self=this,table=this.table,displayIndex;if(self.table.modExists("edit")){self.table.modules.edit.cancelEdit();}if(!stage){stage="all";}if(table.options.selectable&&!table.options.selectablePersistence&&table.modExists("selectRow")){table.modules.selectRow.deselectRows();}//cascade through data refresh stages
switch(stage){case"all":case"filter":if(!skipStage){if(table.modExists("filter")){self.setActiveRows(table.modules.filter.filter(self.rows));}else{self.setActiveRows(self.rows.slice(0));}}else{skipStage=false;}case"sort":if(!skipStage){if(table.modExists("sort")){table.modules.sort.sort(this.activeRows);}}else{skipStage=false;}//generic stage to allow for pipeline trigger after the data manipulation stage
case"display":this.resetDisplayRows();case"freeze":if(!skipStage){if(this.table.modExists("frozenRows")){if(table.modules.frozenRows.isFrozen()){if(!table.modules.frozenRows.getDisplayIndex()){table.modules.frozenRows.setDisplayIndex(this.getNextDisplayIndex());}displayIndex=table.modules.frozenRows.getDisplayIndex();displayIndex=self.setDisplayRows(table.modules.frozenRows.getRows(this.getDisplayRows(displayIndex-1)),displayIndex);if(displayIndex!==true){table.modules.frozenRows.setDisplayIndex(displayIndex);}}}}else{skipStage=false;}case"group":if(!skipStage){if(table.options.groupBy&&table.modExists("groupRows")){if(!table.modules.groupRows.getDisplayIndex()){table.modules.groupRows.setDisplayIndex(this.getNextDisplayIndex());}displayIndex=table.modules.groupRows.getDisplayIndex();displayIndex=self.setDisplayRows(table.modules.groupRows.getRows(this.getDisplayRows(displayIndex-1)),displayIndex);if(displayIndex!==true){table.modules.groupRows.setDisplayIndex(displayIndex);}}}else{skipStage=false;}case"tree":if(!skipStage){if(table.options.dataTree&&table.modExists("dataTree")){if(!table.modules.dataTree.getDisplayIndex()){table.modules.dataTree.setDisplayIndex(this.getNextDisplayIndex());}displayIndex=table.modules.dataTree.getDisplayIndex();displayIndex=self.setDisplayRows(table.modules.dataTree.getRows(this.getDisplayRows(displayIndex-1)),displayIndex);if(displayIndex!==true){table.modules.dataTree.setDisplayIndex(displayIndex);}}}else{skipStage=false;}if(table.options.pagination&&table.modExists("page")&&!renderInPosition){if(table.modules.page.getMode()=="local"){table.modules.page.reset();}}case"page":if(!skipStage){if(table.options.pagination&&table.modExists("page")){if(!table.modules.page.getDisplayIndex()){table.modules.page.setDisplayIndex(this.getNextDisplayIndex());}displayIndex=table.modules.page.getDisplayIndex();if(table.modules.page.getMode()=="local"){table.modules.page.setMaxRows(this.getDisplayRows(displayIndex-1).length);}displayIndex=self.setDisplayRows(table.modules.page.getRows(this.getDisplayRows(displayIndex-1)),displayIndex);if(displayIndex!==true){table.modules.page.setDisplayIndex(displayIndex);}}}else{skipStage=false;}}if(Tabulator.prototype.helpers.elVisible(self.element)){if(renderInPosition){self.reRenderInPosition();}else{self.renderTable();if(table.options.layoutColumnsOnNewData){self.table.columnManager.redraw(true);}}}if(table.modExists("columnCalcs")){table.modules.columnCalcs.recalc(this.activeRows);}};RowManager.prototype.setActiveRows=function(activeRows){this.activeRows=activeRows;this.activeRowsCount=this.activeRows.length;};//reset display rows array
RowManager.prototype.resetDisplayRows=function(){this.displayRows=[];this.displayRows.push(this.activeRows.slice(0));this.displayRowsCount=this.displayRows[0].length;if(this.table.modExists("frozenRows")){this.table.modules.frozenRows.setDisplayIndex(0);}if(this.table.options.groupBy&&this.table.modExists("groupRows")){this.table.modules.groupRows.setDisplayIndex(0);}if(this.table.options.pagination&&this.table.modExists("page")){this.table.modules.page.setDisplayIndex(0);}};RowManager.prototype.getNextDisplayIndex=function(){return this.displayRows.length;};//set display row pipeline data
RowManager.prototype.setDisplayRows=function(displayRows,index){var output=true;if(index&&typeof this.displayRows[index]!="undefined"){this.displayRows[index]=displayRows;output=true;}else{this.displayRows.push(displayRows);output=index=this.displayRows.length-1;}if(index==this.displayRows.length-1){this.displayRowsCount=this.displayRows[this.displayRows.length-1].length;}return output;};RowManager.prototype.getDisplayRows=function(index){if(typeof index=="undefined"){return this.displayRows.length?this.displayRows[this.displayRows.length-1]:[];}else{return this.displayRows[index]||[];}};//repeat action accross display rows
RowManager.prototype.displayRowIterator=function(callback){this.displayRows.forEach(callback);this.displayRowsCount=this.displayRows[this.displayRows.length-1].length;};//return only actual rows (not group headers etc)
RowManager.prototype.getRows=function(){return this.rows;};///////////////// Table Rendering /////////////////
//trigger rerender of table in current position
RowManager.prototype.reRenderInPosition=function(callback){if(this.getRenderMode()=="virtual"){var scrollTop=this.element.scrollTop;var topRow=false;var topOffset=false;var left=this.scrollLeft;var rows=this.getDisplayRows();for(var i=this.vDomTop;i<=this.vDomBottom;i++){if(rows[i]){var diff=scrollTop-rows[i].getElement().offsetTop;if(topOffset===false||Math.abs(diff)<topOffset){topOffset=diff;topRow=i;}else{break;}}}if(callback){callback();}this._virtualRenderFill(topRow===false?this.displayRowsCount-1:topRow,true,topOffset||0);this.scrollHorizontal(left);}else{this.renderTable();}};RowManager.prototype.setRenderMode=function(){if((this.table.element.clientHeight||this.table.options.height)&&this.table.options.virtualDom){this.renderMode="virtual";}else{this.renderMode="classic";}};RowManager.prototype.getRenderMode=function(){return this.renderMode;};RowManager.prototype.renderTable=function(){var self=this;self.table.options.renderStarted.call(this.table);self.element.scrollTop=0;switch(self.renderMode){case"classic":self._simpleRender();break;case"virtual":self._virtualRenderFill();break;}if(self.firstRender){if(self.displayRowsCount){self.firstRender=false;self.table.modules.layout.layout();}else{self.renderEmptyScroll();}}if(self.table.modExists("frozenColumns")){self.table.modules.frozenColumns.layout();}if(!self.displayRowsCount){if(self.table.options.placeholder){if(this.renderMode){self.table.options.placeholder.setAttribute("tabulator-render-mode",this.renderMode);}self.getElement().appendChild(self.table.options.placeholder);}}self.table.options.renderComplete.call(this.table);};//simple render on heightless table
RowManager.prototype._simpleRender=function(){this._clearVirtualDom();if(this.displayRowsCount){this.checkClassicModeGroupHeaderWidth();}else{this.renderEmptyScroll();}};RowManager.prototype.checkClassicModeGroupHeaderWidth=function(){var self=this,element=this.tableElement,onlyGroupHeaders=true;self.getDisplayRows().forEach(function(row,index){self.styleRow(row,index);element.appendChild(row.getElement());row.initialize(true);if(row.type!=="group"){onlyGroupHeaders=false;}});if(onlyGroupHeaders){element.style.minWidth=self.table.columnManager.getWidth()+"px";}else{element.style.minWidth="";}};//show scrollbars on empty table div
RowManager.prototype.renderEmptyScroll=function(){this.tableElement.style.minWidth=this.table.columnManager.getWidth()+"px";this.tableElement.style.minHeight="1px";this.tableElement.style.visibility="hidden";};RowManager.prototype._clearVirtualDom=function(){var element=this.tableElement;if(this.table.options.placeholder&&this.table.options.placeholder.parentNode){this.table.options.placeholder.parentNode.removeChild(this.table.options.placeholder);}// element.children.detach();
while(element.firstChild){element.removeChild(element.firstChild);}element.style.paddingTop="";element.style.paddingBottom="";element.style.minWidth="";element.style.minHeight="";element.style.visibility="";this.scrollTop=0;this.scrollLeft=0;this.vDomTop=0;this.vDomBottom=0;this.vDomTopPad=0;this.vDomBottomPad=0;};RowManager.prototype.styleRow=function(row,index){var rowEl=row.getElement();if(index%2){rowEl.classList.add("tabulator-row-even");rowEl.classList.remove("tabulator-row-odd");}else{rowEl.classList.add("tabulator-row-odd");rowEl.classList.remove("tabulator-row-even");}};//full virtual render
RowManager.prototype._virtualRenderFill=function(position,forceMove,offset){var self=this,element=self.tableElement,holder=self.element,topPad=0,rowsHeight=0,topPadHeight=0,i=0,onlyGroupHeaders=true,rows=self.getDisplayRows();position=position||0;offset=offset||0;if(!position){self._clearVirtualDom();}else{// element.children().detach();
while(element.firstChild){element.removeChild(element.firstChild);}//check if position is too close to bottom of table
var heightOccpied=(self.displayRowsCount-position+1)*self.vDomRowHeight;if(heightOccpied<self.height){position-=Math.ceil((self.height-heightOccpied)/self.vDomRowHeight);if(position<0){position=0;}}//calculate initial pad
topPad=Math.min(Math.max(Math.floor(self.vDomWindowBuffer/self.vDomRowHeight),self.vDomWindowMinMarginRows),position);position-=topPad;}if(self.displayRowsCount&&Tabulator.prototype.helpers.elVisible(self.element)){self.vDomTop=position;self.vDomBottom=position-1;while((rowsHeight<=self.height+self.vDomWindowBuffer||i<self.vDomWindowMinTotalRows)&&self.vDomBottom<self.displayRowsCount-1){var index=self.vDomBottom+1,row=rows[index],rowHeight=0;self.styleRow(row,index);element.appendChild(row.getElement());if(!row.initialized){row.initialize(true);}else{if(!row.heightInitialized){row.normalizeHeight(true);}}rowHeight=row.getHeight();if(i<topPad){topPadHeight+=rowHeight;}else{rowsHeight+=rowHeight;}if(rowHeight>this.vDomWindowBuffer){this.vDomWindowBuffer=rowHeight*2;}if(row.type!=="group"){onlyGroupHeaders=false;}self.vDomBottom++;i++;}if(!position){this.vDomTopPad=0;//adjust rowheight to match average of rendered elements
self.vDomRowHeight=Math.floor((rowsHeight+topPadHeight)/i);self.vDomBottomPad=self.vDomRowHeight*(self.displayRowsCount-self.vDomBottom-1);self.vDomScrollHeight=topPadHeight+rowsHeight+self.vDomBottomPad-self.height;}else{self.vDomTopPad=!forceMove?self.scrollTop-topPadHeight:self.vDomRowHeight*this.vDomTop+offset;self.vDomBottomPad=self.vDomBottom==self.displayRowsCount-1?0:Math.max(self.vDomScrollHeight-self.vDomTopPad-rowsHeight-topPadHeight,0);}element.style.paddingTop=self.vDomTopPad+"px";element.style.paddingBottom=self.vDomBottomPad+"px";if(forceMove){this.scrollTop=self.vDomTopPad+topPadHeight+offset-(this.element.scrollWidth>this.element.clientWidth?this.element.offsetHeight-this.element.clientHeight:0);}this.scrollTop=Math.min(this.scrollTop,this.element.scrollHeight-this.height);//adjust for horizontal scrollbar if present (and not at top of table)
if(this.element.scrollWidth>this.element.offsetWidth&&forceMove){this.scrollTop+=this.element.offsetHeight-this.element.clientHeight;}this.vDomScrollPosTop=this.scrollTop;this.vDomScrollPosBottom=this.scrollTop;holder.scrollTop=this.scrollTop;element.style.minWidth=onlyGroupHeaders?self.table.columnManager.getWidth()+"px":"";if(self.table.options.groupBy){if(self.table.modules.layout.getMode()!="fitDataFill"&&self.displayRowsCount==self.table.modules.groupRows.countGroups()){self.tableElement.style.minWidth=self.table.columnManager.getWidth();}}}else{this.renderEmptyScroll();}};//handle vertical scrolling
RowManager.prototype.scrollVertical=function(dir){var topDiff=this.scrollTop-this.vDomScrollPosTop;var bottomDiff=this.scrollTop-this.vDomScrollPosBottom;var margin=this.vDomWindowBuffer*2;if(-topDiff>margin||bottomDiff>margin){//if big scroll redraw table;
var left=this.scrollLeft;this._virtualRenderFill(Math.floor(this.element.scrollTop/this.element.scrollHeight*this.displayRowsCount));this.scrollHorizontal(left);}else{if(dir){//scrolling up
if(topDiff<0){this._addTopRow(-topDiff);}if(bottomDiff<0){//hide bottom row if needed
if(this.vDomScrollHeight-this.scrollTop>this.vDomWindowBuffer){this._removeBottomRow(-bottomDiff);}}}else{//scrolling down
if(topDiff>=0){//hide top row if needed
if(this.scrollTop>this.vDomWindowBuffer){this._removeTopRow(topDiff);}}if(bottomDiff>=0){this._addBottomRow(bottomDiff);}}}};RowManager.prototype._addTopRow=function(topDiff){var i=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var table=this.tableElement,rows=this.getDisplayRows();if(this.vDomTop){var index=this.vDomTop-1,topRow=rows[index],topRowHeight=topRow.getHeight()||this.vDomRowHeight;//hide top row if needed
if(topDiff>=topRowHeight){this.styleRow(topRow,index);table.insertBefore(topRow.getElement(),table.firstChild);if(!topRow.initialized||!topRow.heightInitialized){this.vDomTopNewRows.push(topRow);if(!topRow.heightInitialized){topRow.clearCellHeight();}}topRow.initialize();this.vDomTopPad-=topRowHeight;if(this.vDomTopPad<0){this.vDomTopPad=index*this.vDomRowHeight;}if(!index){this.vDomTopPad=0;}table.style.paddingTop=this.vDomTopPad+"px";this.vDomScrollPosTop-=topRowHeight;this.vDomTop--;}topDiff=-(this.scrollTop-this.vDomScrollPosTop);if(topRow.getHeight()>this.vDomWindowBuffer){this.vDomWindowBuffer=topRow.getHeight()*2;}if(i<this.vDomMaxRenderChain&&this.vDomTop&&topDiff>=(rows[this.vDomTop-1].getHeight()||this.vDomRowHeight)){this._addTopRow(topDiff,i+1);}else{this._quickNormalizeRowHeight(this.vDomTopNewRows);}}};RowManager.prototype._removeTopRow=function(topDiff){var table=this.tableElement,topRow=this.getDisplayRows()[this.vDomTop],topRowHeight=topRow.getHeight()||this.vDomRowHeight;if(topDiff>=topRowHeight){var rowEl=topRow.getElement();rowEl.parentNode.removeChild(rowEl);this.vDomTopPad+=topRowHeight;table.style.paddingTop=this.vDomTopPad+"px";this.vDomScrollPosTop+=this.vDomTop?topRowHeight:topRowHeight+this.vDomWindowBuffer;this.vDomTop++;topDiff=this.scrollTop-this.vDomScrollPosTop;this._removeTopRow(topDiff);}};RowManager.prototype._addBottomRow=function(bottomDiff){var i=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var table=this.tableElement,rows=this.getDisplayRows();if(this.vDomBottom<this.displayRowsCount-1){var index=this.vDomBottom+1,bottomRow=rows[index],bottomRowHeight=bottomRow.getHeight()||this.vDomRowHeight;//hide bottom row if needed
if(bottomDiff>=bottomRowHeight){this.styleRow(bottomRow,index);table.appendChild(bottomRow.getElement());if(!bottomRow.initialized||!bottomRow.heightInitialized){this.vDomBottomNewRows.push(bottomRow);if(!bottomRow.heightInitialized){bottomRow.clearCellHeight();}}bottomRow.initialize();this.vDomBottomPad-=bottomRowHeight;if(this.vDomBottomPad<0||index==this.displayRowsCount-1){this.vDomBottomPad=0;}table.style.paddingBottom=this.vDomBottomPad+"px";this.vDomScrollPosBottom+=bottomRowHeight;this.vDomBottom++;}bottomDiff=this.scrollTop-this.vDomScrollPosBottom;if(bottomRow.getHeight()>this.vDomWindowBuffer){this.vDomWindowBuffer=bottomRow.getHeight()*2;}if(i<this.vDomMaxRenderChain&&this.vDomBottom<this.displayRowsCount-1&&bottomDiff>=(rows[this.vDomBottom+1].getHeight()||this.vDomRowHeight)){this._addBottomRow(bottomDiff,i+1);}else{this._quickNormalizeRowHeight(this.vDomBottomNewRows);}}};RowManager.prototype._removeBottomRow=function(bottomDiff){var table=this.tableElement,bottomRow=this.getDisplayRows()[this.vDomBottom],bottomRowHeight=bottomRow.getHeight()||this.vDomRowHeight;if(bottomDiff>=bottomRowHeight){var rowEl=bottomRow.getElement();if(rowEl.parentNode){rowEl.parentNode.removeChild(rowEl);}this.vDomBottomPad+=bottomRowHeight;if(this.vDomBottomPad<0){this.vDomBottomPad=0;}table.style.paddingBottom=this.vDomBottomPad+"px";this.vDomScrollPosBottom-=bottomRowHeight;this.vDomBottom--;bottomDiff=-(this.scrollTop-this.vDomScrollPosBottom);this._removeBottomRow(bottomDiff);}};RowManager.prototype._quickNormalizeRowHeight=function(rows){rows.forEach(function(row){row.calcHeight();});rows.forEach(function(row){row.setCellHeight();});rows.length=0;};//normalize height of active rows
RowManager.prototype.normalizeHeight=function(){this.activeRows.forEach(function(row){row.normalizeHeight();});};//adjust the height of the table holder to fit in the Tabulator element
RowManager.prototype.adjustTableSize=function(){if(this.renderMode==="virtual"){this.height=this.element.clientHeight;this.vDomWindowBuffer=this.table.options.virtualDomBuffer||this.height;var otherHeight=this.columnManager.getElement().offsetHeight+(this.table.footerManager&&!this.table.footerManager.external?this.table.footerManager.getElement().offsetHeight:0);this.element.style.minHeight="calc(100% - "+otherHeight+"px)";this.element.style.height="calc(100% - "+otherHeight+"px)";this.element.style.maxHeight="calc(100% - "+otherHeight+"px)";}};//renitialize all rows
RowManager.prototype.reinitialize=function(){this.rows.forEach(function(row){row.reinitialize();});};//redraw table
RowManager.prototype.redraw=function(force){var pos=0,left=this.scrollLeft;this.adjustTableSize();if(!force){if(self.renderMode=="classic"){if(self.table.options.groupBy){self.refreshActiveData("group",false,false);}else{this._simpleRender();}}else{this.reRenderInPosition();this.scrollHorizontal(left);}if(!this.displayRowsCount){if(this.table.options.placeholder){this.getElement().appendChild(this.table.options.placeholder);}}}else{this.renderTable();}};RowManager.prototype.resetScroll=function(){this.element.scrollLeft=0;this.element.scrollTop=0;if(this.table.browser==="ie"){var event=document.createEvent("Event");event.initEvent("scroll",false,true);this.element.dispatchEvent(event);}else{this.element.dispatchEvent(new Event('scroll'));}};//public row object
var RowComponent=function RowComponent(row){this._row=row;};RowComponent.prototype.getData=function(transform){return this._row.getData(transform);};RowComponent.prototype.getElement=function(){return this._row.getElement();};RowComponent.prototype.getCells=function(){var cells=[];this._row.getCells().forEach(function(cell){cells.push(cell.getComponent());});return cells;};RowComponent.prototype.getCell=function(column){var cell=this._row.getCell(column);return cell?cell.getComponent():false;};RowComponent.prototype.getIndex=function(){return this._row.getData("data")[this._row.table.options.index];};RowComponent.prototype.getPosition=function(active){return this._row.table.rowManager.getRowPosition(this._row,active);};RowComponent.prototype.delete=function(){return this._row.delete();};RowComponent.prototype.scrollTo=function(){return this._row.table.rowManager.scrollToRow(this._row);};RowComponent.prototype.pageTo=function(){if(this._row.table.modExists("page",true)){return this._row.table.modules.page.setPageToRow(this._row);}};RowComponent.prototype.move=function(to,after){this._row.moveToRow(to,after);};RowComponent.prototype.update=function(data){return this._row.updateData(data);};RowComponent.prototype.normalizeHeight=function(){this._row.normalizeHeight(true);};RowComponent.prototype.select=function(){this._row.table.modules.selectRow.selectRows(this._row);};RowComponent.prototype.deselect=function(){this._row.table.modules.selectRow.deselectRows(this._row);};RowComponent.prototype.toggleSelect=function(){this._row.table.modules.selectRow.toggleRow(this._row);};RowComponent.prototype.isSelected=function(){return this._row.table.modules.selectRow.isRowSelected(this._row);};RowComponent.prototype._getSelf=function(){return this._row;};RowComponent.prototype.freeze=function(){if(this._row.table.modExists("frozenRows",true)){this._row.table.modules.frozenRows.freezeRow(this._row);}};RowComponent.prototype.unfreeze=function(){if(this._row.table.modExists("frozenRows",true)){this._row.table.modules.frozenRows.unfreezeRow(this._row);}};RowComponent.prototype.treeCollapse=function(){if(this._row.table.modExists("dataTree",true)){this._row.table.modules.dataTree.collapseRow(this._row);}};RowComponent.prototype.treeExpand=function(){if(this._row.table.modExists("dataTree",true)){this._row.table.modules.dataTree.expandRow(this._row);}};RowComponent.prototype.treeToggle=function(){if(this._row.table.modExists("dataTree",true)){this._row.table.modules.dataTree.toggleRow(this._row);}};RowComponent.prototype.getTreeParent=function(){if(this._row.table.modExists("dataTree",true)){return this._row.table.modules.dataTree.getTreeParent(this._row);}return false;};RowComponent.prototype.getTreeChildren=function(){if(this._row.table.modExists("dataTree",true)){return this._row.table.modules.dataTree.getTreeChildren(this._row);}return false;};RowComponent.prototype.reformat=function(){return this._row.reinitialize();};RowComponent.prototype.getGroup=function(){return this._row.getGroup().getComponent();};RowComponent.prototype.getTable=function(){return this._row.table;};RowComponent.prototype.getNextRow=function(){var row=this._row.nextRow();return row?row.getComponent():row;};RowComponent.prototype.getPrevRow=function(){var row=this._row.prevRow();return row?row.getComponent():row;};var Row=function Row(data,parent){this.table=parent.table;this.parent=parent;this.data={};this.type="row";//type of element
this.element=this.createElement();this.modules={};//hold module variables;
this.cells=[];this.height=0;//hold element height
this.heightStyled="";//hold element height prestyled to improve render efficiency
this.outerHeight=0;//holde lements outer height
this.initialized=false;//element has been rendered
this.heightInitialized=false;//element has resized cells to fit
this.setData(data);this.generateElement();};Row.prototype.createElement=function(){var el=document.createElement("div");el.classList.add("tabulator-row");el.setAttribute("role","row");return el;};Row.prototype.getElement=function(){return this.element;};Row.prototype.detachElement=function(){if(this.element&&this.element.parentNode){this.element.parentNode.removeChild(this.element);}};Row.prototype.generateElement=function(){var self=this,dblTap,tapHold,tap;//set row selection characteristics
if(self.table.options.selectable!==false&&self.table.modExists("selectRow")){self.table.modules.selectRow.initializeRow(this);}//setup movable rows
if(self.table.options.movableRows!==false&&self.table.modExists("moveRow")){self.table.modules.moveRow.initializeRow(this);}//setup data tree
if(self.table.options.dataTree!==false&&self.table.modExists("dataTree")){self.table.modules.dataTree.initializeRow(this);}//handle row click events
if(self.table.options.rowClick){self.element.addEventListener("click",function(e){self.table.options.rowClick(e,self.getComponent());});}if(self.table.options.rowDblClick){self.element.addEventListener("dblclick",function(e){self.table.options.rowDblClick(e,self.getComponent());});}if(self.table.options.rowContext){self.element.addEventListener("contextmenu",function(e){self.table.options.rowContext(e,self.getComponent());});}//handle mouse events
if(self.table.options.rowMouseEnter){self.element.addEventListener("mouseenter",function(e){self.table.options.rowMouseEnter(e,self.getComponent());});}if(self.table.options.rowMouseLeave){self.element.addEventListener("mouseleave",function(e){self.table.options.rowMouseLeave(e,self.getComponent());});}if(self.table.options.rowMouseOver){self.element.addEventListener("mouseover",function(e){self.table.options.rowMouseOver(e,self.getComponent());});}if(self.table.options.rowMouseOut){self.element.addEventListener("mouseout",function(e){self.table.options.rowMouseOut(e,self.getComponent());});}if(self.table.options.rowMouseMove){self.element.addEventListener("mousemove",function(e){self.table.options.rowMouseMove(e,self.getComponent());});}if(self.table.options.rowTap){tap=false;self.element.addEventListener("touchstart",function(e){tap=true;});self.element.addEventListener("touchend",function(e){if(tap){self.table.options.rowTap(e,self.getComponent());}tap=false;});}if(self.table.options.rowDblTap){dblTap=null;self.element.addEventListener("touchend",function(e){if(dblTap){clearTimeout(dblTap);dblTap=null;self.table.options.rowDblTap(e,self.getComponent());}else{dblTap=setTimeout(function(){clearTimeout(dblTap);dblTap=null;},300);}});}if(self.table.options.rowTapHold){tapHold=null;self.element.addEventListener("touchstart",function(e){clearTimeout(tapHold);tapHold=setTimeout(function(){clearTimeout(tapHold);tapHold=null;tap=false;self.table.options.rowTapHold(e,self.getComponent());},1000);});self.element.addEventListener("touchend",function(e){clearTimeout(tapHold);tapHold=null;});}};Row.prototype.generateCells=function(){this.cells=this.table.columnManager.generateCells(this);};//functions to setup on first render
Row.prototype.initialize=function(force){var self=this;if(!self.initialized||force){self.deleteCells();while(self.element.firstChild){self.element.removeChild(self.element.firstChild);}//handle frozen cells
if(this.table.modExists("frozenColumns")){this.table.modules.frozenColumns.layoutRow(this);}this.generateCells();self.cells.forEach(function(cell){self.element.appendChild(cell.getElement());cell.cellRendered();});if(force){self.normalizeHeight();}//setup movable rows
if(self.table.options.dataTree&&self.table.modExists("dataTree")){self.table.modules.dataTree.layoutRow(this);}//setup movable rows
if(self.table.options.responsiveLayout==="collapse"&&self.table.modExists("responsiveLayout")){self.table.modules.responsiveLayout.layoutRow(this);}if(self.table.options.rowFormatter){self.table.options.rowFormatter(self.getComponent());}//set resizable handles
if(self.table.options.resizableRows&&self.table.modExists("resizeRows")){self.table.modules.resizeRows.initializeRow(self);}self.initialized=true;}};Row.prototype.reinitializeHeight=function(){this.heightInitialized=false;if(this.element.offsetParent!==null){this.normalizeHeight(true);}};Row.prototype.reinitialize=function(){this.initialized=false;this.heightInitialized=false;this.height=0;this.heightStyled="";if(this.element.offsetParent!==null){this.initialize(true);}};//get heights when doing bulk row style calcs in virtual DOM
Row.prototype.calcHeight=function(){var maxHeight=0,minHeight=this.table.options.resizableRows?this.element.clientHeight:0;this.cells.forEach(function(cell){var height=cell.getHeight();if(height>maxHeight){maxHeight=height;}});this.height=Math.max(maxHeight,minHeight);this.heightStyled=this.height?this.height+"px":"";this.outerHeight=this.element.offsetHeight;};//set of cells
Row.prototype.setCellHeight=function(){this.cells.forEach(function(cell){cell.setHeight();});this.heightInitialized=true;};Row.prototype.clearCellHeight=function(){this.cells.forEach(function(cell){cell.clearHeight();});};//normalize the height of elements in the row
Row.prototype.normalizeHeight=function(force){if(force){this.clearCellHeight();}this.calcHeight();this.setCellHeight();};// Row.prototype.setHeight = function(height){
// 	this.height = height;
// 	this.setCellHeight();
// };
//set height of rows
Row.prototype.setHeight=function(height,force){if(this.height!=height||force){this.height=height;this.heightStyled=height?height+"px":"";this.setCellHeight();// this.outerHeight = this.element.outerHeight();
this.outerHeight=this.element.offsetHeight;}};//return rows outer height
Row.prototype.getHeight=function(){return this.outerHeight;};//return rows outer Width
Row.prototype.getWidth=function(){return this.element.offsetWidth;};//////////////// Cell Management /////////////////
Row.prototype.deleteCell=function(cell){var index=this.cells.indexOf(cell);if(index>-1){this.cells.splice(index,1);}};//////////////// Data Management /////////////////
Row.prototype.setData=function(data){var self=this;if(self.table.modExists("mutator")){data=self.table.modules.mutator.transformRow(data,"data");}self.data=data;if(self.table.options.reactiveData&&this.table.modExists("reactiveData",true)){this.table.modules.reactiveData.watchRow(this);}};//update the rows data
Row.prototype.updateData=function(data){var _this5=this;var self=this,visible=Tabulator.prototype.helpers.elVisible(this.element);return new Promise(function(resolve,reject){if(typeof data==="string"){data=JSON.parse(data);}if(_this5.table.options.reactiveData&&_this5.table.modExists("reactiveData",true)){_this5.table.modules.reactiveData.block();}//mutate incomming data if needed
if(self.table.modExists("mutator")){data=self.table.modules.mutator.transformRow(data,"data",true);}//set data
for(var attrname in data){self.data[attrname]=data[attrname];}if(_this5.table.options.reactiveData&&_this5.table.modExists("reactiveData",true)){_this5.table.modules.reactiveData.unblock();}//update affected cells only
for(var attrname in data){var cell=_this5.getCell(attrname);if(cell){if(cell.getValue()!=data[attrname]){cell.setValueProcessData(data[attrname]);if(visible){cell.cellRendered();}}}}//Partial reinitialization if visible
if(visible){self.normalizeHeight();if(self.table.options.rowFormatter){self.table.options.rowFormatter(self.getComponent());}}else{_this5.initialized=false;_this5.height=0;_this5.heightStyled="";}if(self.table.options.dataTree!==false&&self.table.modExists("dataTree")&&typeof data[_this5.table.modules.dataTree.getChildField()]!=="undefined"){_this5.table.modules.dataTree.initializeRow(_this5);_this5.table.rowManager.refreshActiveData("tree",false,true);}//self.reinitialize();
self.table.options.rowUpdated.call(_this5.table,self.getComponent());resolve();});};Row.prototype.getData=function(transform){var self=this;if(transform){if(self.table.modExists("accessor")){return self.table.modules.accessor.transformRow(self.data,transform);}}else{return this.data;}};Row.prototype.getCell=function(column){var match=false;column=this.table.columnManager.findColumn(column);match=this.cells.find(function(cell){return cell.column===column;});return match;};Row.prototype.getCellIndex=function(findCell){return this.cells.findIndex(function(cell){return cell===findCell;});};Row.prototype.findNextEditableCell=function(index){var nextCell=false;if(index<this.cells.length-1){for(var i=index+1;i<this.cells.length;i++){var cell=this.cells[i];if(cell.column.modules.edit&&Tabulator.prototype.helpers.elVisible(cell.getElement())){var allowEdit=true;if(typeof cell.column.modules.edit.check=="function"){allowEdit=cell.column.modules.edit.check(cell.getComponent());}if(allowEdit){nextCell=cell;break;}}}}return nextCell;};Row.prototype.findPrevEditableCell=function(index){var prevCell=false;if(index>0){for(var i=index-1;i>=0;i--){var cell=this.cells[i],allowEdit=true;if(cell.column.modules.edit&&Tabulator.prototype.helpers.elVisible(cell.getElement())){if(typeof cell.column.modules.edit.check=="function"){allowEdit=cell.column.modules.edit.check(cell.getComponent());}if(allowEdit){prevCell=cell;break;}}}}return prevCell;};Row.prototype.getCells=function(){return this.cells;};Row.prototype.nextRow=function(){var row=this.table.rowManager.nextDisplayRow(this,true);return row||false;};Row.prototype.prevRow=function(){var row=this.table.rowManager.prevDisplayRow(this,true);return row||false;};Row.prototype.moveToRow=function(to,before){var toRow=this.table.rowManager.findRow(to);if(toRow){this.table.rowManager.moveRowActual(this,toRow,!before);this.table.rowManager.refreshActiveData("display",false,true);}else{console.warn("Move Error - No matching row found:",to);}};///////////////////// Actions  /////////////////////
Row.prototype.delete=function(){var _this6=this;return new Promise(function(resolve,reject){var index=_this6.table.rowManager.getRowIndex(_this6);_this6.deleteActual();if(_this6.table.options.history&&_this6.table.modExists("history")){if(index){index=_this6.table.rowManager.rows[index-1];}_this6.table.modules.history.action("rowDelete",_this6,{data:_this6.getData(),pos:!index,index:index});}resolve();});};Row.prototype.deleteActual=function(blockRedraw){var index=this.table.rowManager.getRowIndex(this);//deselect row if it is selected
if(this.table.modExists("selectRow")){this.table.modules.selectRow._deselectRow(this,true);}// if(this.table.options.dataTree && this.table.modExists("dataTree")){
// 	this.table.modules.dataTree.collapseRow(this, true);
// }
//remove any reactive data watchers from row object
if(this.table.options.reactiveData&&this.table.modExists("reactiveData",true)){this.table.modules.reactiveData.unwatchRow(this);}this.table.rowManager.deleteRow(this,blockRedraw);this.deleteCells();this.initialized=false;this.heightInitialized=false;//remove from group
if(this.modules.group){this.modules.group.removeRow(this);}//recalc column calculations if present
if(this.table.modExists("columnCalcs")){if(this.table.options.groupBy&&this.table.modExists("groupRows")){this.table.modules.columnCalcs.recalcRowGroup(this);}else{this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);}}};Row.prototype.deleteCells=function(){var cellCount=this.cells.length;for(var i=0;i<cellCount;i++){this.cells[0].delete();}};Row.prototype.wipe=function(){this.deleteCells();// this.element.children().each(function(){
// 	$(this).remove();
// })
// this.element.empty();
while(this.element.firstChild){this.element.removeChild(this.element.firstChild);}// this.element.remove();
if(this.element.parentNode){this.element.parentNode.removeChild(this.element);}};Row.prototype.getGroup=function(){return this.modules.group||false;};//////////////// Object Generation /////////////////
Row.prototype.getComponent=function(){return new RowComponent(this);};//public row object
var CellComponent=function CellComponent(cell){this._cell=cell;};CellComponent.prototype.getValue=function(){return this._cell.getValue();};CellComponent.prototype.getOldValue=function(){return this._cell.getOldValue();};CellComponent.prototype.getElement=function(){return this._cell.getElement();};CellComponent.prototype.getRow=function(){return this._cell.row.getComponent();};CellComponent.prototype.getData=function(){return this._cell.row.getData();};CellComponent.prototype.getField=function(){return this._cell.column.getField();};CellComponent.prototype.getColumn=function(){return this._cell.column.getComponent();};CellComponent.prototype.setValue=function(value,mutate){if(typeof mutate=="undefined"){mutate=true;}this._cell.setValue(value,mutate);};CellComponent.prototype.restoreOldValue=function(){this._cell.setValueActual(this._cell.getOldValue());};CellComponent.prototype.edit=function(force){return this._cell.edit(force);};CellComponent.prototype.cancelEdit=function(){this._cell.cancelEdit();};CellComponent.prototype.nav=function(){return this._cell.nav();};CellComponent.prototype.checkHeight=function(){this._cell.checkHeight();};CellComponent.prototype.getTable=function(){return this._cell.table;};CellComponent.prototype._getSelf=function(){return this._cell;};var Cell=function Cell(column,row){this.table=column.table;this.column=column;this.row=row;this.element=null;this.value=null;this.oldValue=null;this.height=null;this.width=null;this.minWidth=null;this.build();};//////////////// Setup Functions /////////////////
//generate element
Cell.prototype.build=function(){this.generateElement();this.setWidth();this._configureCell();this.setValueActual(this.column.getFieldValue(this.row.data));};Cell.prototype.generateElement=function(){this.element=document.createElement('div');this.element.className="tabulator-cell";this.element.setAttribute("role","gridcell");this.element=this.element;};Cell.prototype._configureCell=function(){var self=this,cellEvents=self.column.cellEvents,element=self.element,field=this.column.getField();//set text alignment
element.style.textAlign=self.column.hozAlign;if(field){element.setAttribute("tabulator-field",field);}//add class to cell if needed
if(self.column.definition.cssClass){var classNames=self.column.definition.cssClass.split(" ");classNames.forEach(function(className){element.classList.add(className);});}//update tooltip on mouse enter
if(this.table.options.tooltipGenerationMode==="hover"){element.addEventListener("mouseenter",function(e){self._generateTooltip();});}self._bindClickEvents(cellEvents);self._bindTouchEvents(cellEvents);self._bindMouseEvents(cellEvents);if(self.column.modules.edit){self.table.modules.edit.bindEditor(self);}if(self.column.definition.rowHandle&&self.table.options.movableRows!==false&&self.table.modExists("moveRow")){self.table.modules.moveRow.initializeCell(self);}//hide cell if not visible
if(!self.column.visible){self.hide();}};Cell.prototype._bindClickEvents=function(cellEvents){var self=this,element=self.element;//set event bindings
if(cellEvents.cellClick||self.table.options.cellClick){element.addEventListener("click",function(e){var component=self.getComponent();if(cellEvents.cellClick){cellEvents.cellClick.call(self.table,e,component);}if(self.table.options.cellClick){self.table.options.cellClick.call(self.table,e,component);}});}if(cellEvents.cellDblClick||this.table.options.cellDblClick){element.addEventListener("dblclick",function(e){var component=self.getComponent();if(cellEvents.cellDblClick){cellEvents.cellDblClick.call(self.table,e,component);}if(self.table.options.cellDblClick){self.table.options.cellDblClick.call(self.table,e,component);}});}if(cellEvents.cellContext||this.table.options.cellContext){element.addEventListener("contextmenu",function(e){var component=self.getComponent();if(cellEvents.cellContext){cellEvents.cellContext.call(self.table,e,component);}if(self.table.options.cellContext){self.table.options.cellContext.call(self.table,e,component);}});}};Cell.prototype._bindMouseEvents=function(cellEvents){var self=this,element=self.element;if(cellEvents.cellMouseEnter||self.table.options.cellMouseEnter){element.addEventListener("mouseenter",function(e){var component=self.getComponent();if(cellEvents.cellMouseEnter){cellEvents.cellMouseEnter.call(self.table,e,component);}if(self.table.options.cellMouseEnter){self.table.options.cellMouseEnter.call(self.table,e,component);}});}if(cellEvents.cellMouseLeave||self.table.options.cellMouseLeave){element.addEventListener("mouseleave",function(e){var component=self.getComponent();if(cellEvents.cellMouseLeave){cellEvents.cellMouseLeave.call(self.table,e,component);}if(self.table.options.cellMouseLeave){self.table.options.cellMouseLeave.call(self.table,e,component);}});}if(cellEvents.cellMouseOver||self.table.options.cellMouseOver){element.addEventListener("mouseover",function(e){var component=self.getComponent();if(cellEvents.cellMouseOver){cellEvents.cellMouseOver.call(self.table,e,component);}if(self.table.options.cellMouseOver){self.table.options.cellMouseOver.call(self.table,e,component);}});}if(cellEvents.cellMouseOut||self.table.options.cellMouseOut){element.addEventListener("mouseout",function(e){var component=self.getComponent();if(cellEvents.cellMouseOut){cellEvents.cellMouseOut.call(self.table,e,component);}if(self.table.options.cellMouseOut){self.table.options.cellMouseOut.call(self.table,e,component);}});}if(cellEvents.cellMouseMove||self.table.options.cellMouseMove){element.addEventListener("mousemove",function(e){var component=self.getComponent();if(cellEvents.cellMouseMove){cellEvents.cellMouseMove.call(self.table,e,component);}if(self.table.options.cellMouseMove){self.table.options.cellMouseMove.call(self.table,e,component);}});}};Cell.prototype._bindTouchEvents=function(cellEvents){var self=this,element=self.element,dblTap,tapHold,tap;if(cellEvents.cellTap||this.table.options.cellTap){tap=false;element.addEventListener("touchstart",function(e){tap=true;});element.addEventListener("touchend",function(e){if(tap){var component=self.getComponent();if(cellEvents.cellTap){cellEvents.cellTap.call(self.table,e,component);}if(self.table.options.cellTap){self.table.options.cellTap.call(self.table,e,component);}}tap=false;});}if(cellEvents.cellDblTap||this.table.options.cellDblTap){dblTap=null;element.addEventListener("touchend",function(e){if(dblTap){clearTimeout(dblTap);dblTap=null;var component=self.getComponent();if(cellEvents.cellDblTap){cellEvents.cellDblTap.call(self.table,e,component);}if(self.table.options.cellDblTap){self.table.options.cellDblTap.call(self.table,e,component);}}else{dblTap=setTimeout(function(){clearTimeout(dblTap);dblTap=null;},300);}});}if(cellEvents.cellTapHold||this.table.options.cellTapHold){tapHold=null;element.addEventListener("touchstart",function(e){clearTimeout(tapHold);tapHold=setTimeout(function(){clearTimeout(tapHold);tapHold=null;tap=false;var component=self.getComponent();if(cellEvents.cellTapHold){cellEvents.cellTapHold.call(self.table,e,component);}if(self.table.options.cellTapHold){self.table.options.cellTapHold.call(self.table,e,component);}},1000);});element.addEventListener("touchend",function(e){clearTimeout(tapHold);tapHold=null;});}};//generate cell contents
Cell.prototype._generateContents=function(){var val;if(this.table.modExists("format")){val=this.table.modules.format.formatValue(this);}else{val=this.element.innerHTML=this.value;}switch(typeof val==='undefined'?'undefined':_typeof(val)){case"object":if(val instanceof Node){//clear previous cell contents
while(this.element.firstChild){this.element.removeChild(this.element.firstChild);}this.element.appendChild(val);}else{this.element.innerHTML="";if(val!=null){console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:",val);}}break;case"undefined":case"null":this.element.innerHTML="";break;default:this.element.innerHTML=val;}};Cell.prototype.cellRendered=function(){if(this.table.modExists("format")&&this.table.modules.format.cellRendered){this.table.modules.format.cellRendered(this);}};//generate tooltip text
Cell.prototype._generateTooltip=function(){var tooltip=this.column.tooltip;if(tooltip){if(tooltip===true){tooltip=this.value;}else if(typeof tooltip=="function"){tooltip=tooltip(this.getComponent());if(tooltip===false){tooltip="";}}if(typeof tooltip==="undefined"){tooltip="";}this.element.setAttribute("title",tooltip);}else{this.element.setAttribute("title","");}};//////////////////// Getters ////////////////////
Cell.prototype.getElement=function(){return this.element;};Cell.prototype.getValue=function(){return this.value;};Cell.prototype.getOldValue=function(){return this.oldValue;};//////////////////// Actions ////////////////////
Cell.prototype.setValue=function(value,mutate){var changed=this.setValueProcessData(value,mutate),component;if(changed){if(this.table.options.history&&this.table.modExists("history")){this.table.modules.history.action("cellEdit",this,{oldValue:this.oldValue,newValue:this.value});}component=this.getComponent();if(this.column.cellEvents.cellEdited){this.column.cellEvents.cellEdited.call(this.table,component);}this.table.options.cellEdited.call(this.table,component);this.table.options.dataEdited.call(this.table,this.table.rowManager.getData());}};Cell.prototype.setValueProcessData=function(value,mutate){var changed=false;if(this.value!=value){changed=true;if(mutate){if(this.column.modules.mutate){value=this.table.modules.mutator.transformCell(this,value);}}}this.setValueActual(value);if(changed&&this.table.modExists("columnCalcs")){if(this.column.definition.topCalc||this.column.definition.bottomCalc){if(this.table.options.groupBy&&this.table.modExists("groupRows")){this.table.modules.columnCalcs.recalcRowGroup(this.row);}else{this.table.modules.columnCalcs.recalc(this.table.rowManager.activeRows);}}}return changed;};Cell.prototype.setValueActual=function(value){this.oldValue=this.value;this.value=value;if(this.table.options.reactiveData&&this.table.modExists("reactiveData")){this.table.modules.reactiveData.block();}this.column.setFieldValue(this.row.data,value);if(this.table.options.reactiveData&&this.table.modExists("reactiveData")){this.table.modules.reactiveData.unblock();}this._generateContents();this._generateTooltip();//set resizable handles
if(this.table.options.resizableColumns&&this.table.modExists("resizeColumns")){this.table.modules.resizeColumns.initializeColumn("cell",this.column,this.element);}//handle frozen cells
if(this.table.modExists("frozenColumns")){this.table.modules.frozenColumns.layoutElement(this.element,this.column);}};Cell.prototype.setWidth=function(){this.width=this.column.width;this.element.style.width=this.column.widthStyled;};Cell.prototype.clearWidth=function(){this.width="";this.element.style.width="";};Cell.prototype.getWidth=function(){return this.width||this.element.offsetWidth;};Cell.prototype.setMinWidth=function(){this.minWidth=this.column.minWidth;this.element.style.minWidth=this.column.minWidthStyled;};Cell.prototype.checkHeight=function(){// var height = this.element.css("height");
this.row.reinitializeHeight();};Cell.prototype.clearHeight=function(){this.element.style.height="";this.height=null;};Cell.prototype.setHeight=function(){this.height=this.row.height;this.element.style.height=this.row.heightStyled;};Cell.prototype.getHeight=function(){return this.height||this.element.offsetHeight;};Cell.prototype.show=function(){this.element.style.display="";};Cell.prototype.hide=function(){this.element.style.display="none";};Cell.prototype.edit=function(force){if(this.table.modExists("edit",true)){return this.table.modules.edit.editCell(this,force);}};Cell.prototype.cancelEdit=function(){if(this.table.modExists("edit",true)){var editing=this.table.modules.edit.getCurrentCell();if(editing&&editing._getSelf()===this){this.table.modules.edit.cancelEdit();}else{console.warn("Cancel Editor Error - This cell is not currently being edited ");}}};Cell.prototype.delete=function(){this.element.parentNode.removeChild(this.element);this.column.deleteCell(this);this.row.deleteCell(this);};//////////////// Navigation /////////////////
Cell.prototype.nav=function(){var self=this,nextCell=false,index=this.row.getCellIndex(this);return{next:function next(){var nextCell=this.right(),nextRow;if(!nextCell){nextRow=self.table.rowManager.nextDisplayRow(self.row,true);if(nextRow){nextCell=nextRow.findNextEditableCell(-1);if(nextCell){nextCell.edit();return true;}}}else{return true;}return false;},prev:function prev(){var nextCell=this.left(),prevRow;if(!nextCell){prevRow=self.table.rowManager.prevDisplayRow(self.row,true);if(prevRow){nextCell=prevRow.findPrevEditableCell(prevRow.cells.length);if(nextCell){nextCell.edit();return true;}}}else{return true;}return false;},left:function left(){nextCell=self.row.findPrevEditableCell(index);if(nextCell){nextCell.edit();return true;}else{return false;}},right:function right(){nextCell=self.row.findNextEditableCell(index);if(nextCell){nextCell.edit();return true;}else{return false;}},up:function up(){var nextRow=self.table.rowManager.prevDisplayRow(self.row,true);if(nextRow){nextRow.cells[index].edit();}},down:function down(){var nextRow=self.table.rowManager.nextDisplayRow(self.row,true);if(nextRow){nextRow.cells[index].edit();}}};};Cell.prototype.getIndex=function(){this.row.getCellIndex(this);};//////////////// Object Generation /////////////////
Cell.prototype.getComponent=function(){return new CellComponent(this);};var FooterManager=function FooterManager(table){this.table=table;this.active=false;this.element=this.createElement();//containing element
this.external=false;this.links=[];this._initialize();};FooterManager.prototype.createElement=function(){var el=document.createElement("div");el.classList.add("tabulator-footer");return el;};FooterManager.prototype._initialize=function(element){if(this.table.options.footerElement){switch(_typeof(this.table.options.footerElement)){case"string":if(this.table.options.footerElement[0]==="<"){this.element.innerHTML=this.table.options.footerElement;}else{this.external=true;this.element=document.querySelector(this.table.options.footerElement);}break;default:this.element=this.table.options.footerElement;break;}}};FooterManager.prototype.getElement=function(){return this.element;};FooterManager.prototype.append=function(element,parent){this.activate(parent);this.element.appendChild(element);this.table.rowManager.adjustTableSize();};FooterManager.prototype.prepend=function(element,parent){this.activate(parent);this.element.insertBefore(element,this.element.firstChild);this.table.rowManager.adjustTableSize();};FooterManager.prototype.remove=function(element){element.parentNode.removeChild(element);this.deactivate();};FooterManager.prototype.deactivate=function(force){if(!this.element.firstChild||force){if(!this.external){this.element.parentNode.removeChild(this.element);}this.active=false;}// this.table.rowManager.adjustTableSize();
};FooterManager.prototype.activate=function(parent){if(!this.active){this.active=true;if(!this.external){this.table.element.appendChild(this.getElement());this.table.element.style.display='';}}if(parent){this.links.push(parent);}};FooterManager.prototype.redraw=function(){this.links.forEach(function(link){link.footerRedraw();});};var Tabulator=function Tabulator(element,options){this.options={};this.columnManager=null;// hold Column Manager
this.rowManager=null;//hold Row Manager
this.footerManager=null;//holder Footer Manager
this.browser="";//hold current browser type
this.browserSlow=false;//handle reduced functionality for slower browsers
this.modules={};//hold all modules bound to this table
this.initializeElement(element);this.initializeOptions(options||{});this._create();Tabulator.prototype.comms.register(this);//register table for inderdevice communication
};//default setup options
Tabulator.prototype.defaultOptions={height:false,//height of tabulator
layout:"fitData",///layout type "fitColumns" | "fitData"
layoutColumnsOnNewData:false,//update column widths on setData
columnMinWidth:40,//minimum global width for a column
columnVertAlign:"top",//vertical alignment of column headers
resizableColumns:true,//resizable columns
resizableRows:false,//resizable rows
autoResize:true,//auto resize table
columns:[],//store for colum header info
data:[],//default starting data
autoColumns:false,//build columns from data row structure
reactiveData:false,//enable data reactivity
nestedFieldSeparator:".",//seperatpr for nested data
tooltips:false,//Tool tip value
tooltipsHeader:false,//Tool tip for headers
tooltipGenerationMode:"load",//when to generate tooltips
initialSort:false,//initial sorting criteria
initialFilter:false,//initial filtering criteria
initialHeaderFilter:false,//initial header filtering criteria
columnHeaderSortMulti:true,//multiple or single column sorting
sortOrderReverse:false,//reverse internal sort ordering
footerElement:false,//hold footer element
index:"id",//filed for row index
keybindings:[],//array for keybindings
clipboard:false,//enable clipboard
clipboardCopyStyled:true,//formatted table data
clipboardCopySelector:"active",//method of chosing which data is coppied to the clipboard
clipboardCopyFormatter:"table",//convert data to a clipboard string
clipboardPasteParser:"table",//convert pasted clipboard data to rows
clipboardPasteAction:"insert",//how to insert pasted data into the table
clipboardCopyConfig:false,//clipboard config
clipboardCopied:function clipboardCopied(){},//data has been copied to the clipboard
clipboardPasted:function clipboardPasted(){},//data has been pasted into the table
clipboardPasteError:function clipboardPasteError(){},//data has not successfully been pasted into the table
downloadDataFormatter:false,//function to manipulate table data before it is downloaded
downloadReady:function downloadReady(data,blob){return blob;},//function to manipulate download data
downloadComplete:false,//function to manipulate download data
downloadConfig:false,//download config
dataTree:false,//enable data tree
dataTreeElementColumn:false,dataTreeBranchElement:true,//show data tree branch element
dataTreeChildIndent:9,//data tree child indent in px
dataTreeChildField:"_children",//data tre column field to look for child rows
dataTreeCollapseElement:false,//data tree row collapse element
dataTreeExpandElement:false,//data tree row expand element
dataTreeStartExpanded:false,dataTreeRowExpanded:function dataTreeRowExpanded(){},//row has been expanded
dataTreeRowCollapsed:function dataTreeRowCollapsed(){},//row has been collapsed
addRowPos:"bottom",//position to insert blank rows, top|bottom
selectable:"highlight",//highlight rows on hover
selectableRangeMode:"drag",//highlight rows on hover
selectableRollingSelection:true,//roll selection once maximum number of selectable rows is reached
selectablePersistence:true,// maintain selection when table view is updated
selectableCheck:function selectableCheck(data,row){return true;},//check wheather row is selectable
headerFilterPlaceholder:false,//placeholder text to display in header filters
history:false,//enable edit history
locale:false,//current system language
langs:{},virtualDom:true,//enable DOM virtualization
persistentLayout:false,//store column layout in memory
persistentSort:false,//store sorting in memory
persistentFilter:false,//store filters in memory
persistenceID:"",//key for persistent storage
persistenceMode:true,//mode for storing persistence information
responsiveLayout:false,//responsive layout flags
responsiveLayoutCollapseStartOpen:true,//start showing collapsed data
responsiveLayoutCollapseUseFormatters:true,//responsive layout collapse formatter
responsiveLayoutCollapseFormatter:false,//responsive layout collapse formatter
pagination:false,//set pagination type
paginationSize:false,//set number of rows to a page
paginationButtonCount:5,// set count of page button
paginationSizeSelector:false,//add pagination size selector element
paginationElement:false,//element to hold pagination numbers
paginationDataSent:{},//pagination data sent to the server
paginationDataReceived:{},//pagination data received from the server
paginationAddRow:"page",//add rows on table or page
ajaxURL:false,//url for ajax loading
ajaxURLGenerator:false,ajaxParams:{},//params for ajax loading
ajaxConfig:"get",//ajax request type
ajaxContentType:"form",//ajax request type
ajaxRequestFunc:false,//promise function
ajaxLoader:true,//show loader
ajaxLoaderLoading:false,//loader element
ajaxLoaderError:false,//loader element
ajaxFiltering:false,ajaxSorting:false,ajaxProgressiveLoad:false,//progressive loading
ajaxProgressiveLoadDelay:0,//delay between requests
ajaxProgressiveLoadScrollMargin:0,//margin before scroll begins
groupBy:false,//enable table grouping and set field to group by
groupStartOpen:true,//starting state of group
groupValues:false,groupHeader:false,//header generation function
movableColumns:false,//enable movable columns
movableRows:false,//enable movable rows
movableRowsConnectedTables:false,//tables for movable rows to be connected to
movableRowsSender:false,movableRowsReceiver:"insert",movableRowsSendingStart:function movableRowsSendingStart(){},movableRowsSent:function movableRowsSent(){},movableRowsSentFailed:function movableRowsSentFailed(){},movableRowsSendingStop:function movableRowsSendingStop(){},movableRowsReceivingStart:function movableRowsReceivingStart(){},movableRowsReceived:function movableRowsReceived(){},movableRowsReceivedFailed:function movableRowsReceivedFailed(){},movableRowsReceivingStop:function movableRowsReceivingStop(){},scrollToRowPosition:"top",scrollToRowIfVisible:true,scrollToColumnPosition:"left",scrollToColumnIfVisible:true,rowFormatter:false,placeholder:false,//table building callbacks
tableBuilding:function tableBuilding(){},tableBuilt:function tableBuilt(){},//render callbacks
renderStarted:function renderStarted(){},renderComplete:function renderComplete(){},//row callbacks
rowClick:false,rowDblClick:false,rowContext:false,rowTap:false,rowDblTap:false,rowTapHold:false,rowMouseEnter:false,rowMouseLeave:false,rowMouseOver:false,rowMouseOut:false,rowMouseMove:false,rowAdded:function rowAdded(){},rowDeleted:function rowDeleted(){},rowMoved:function rowMoved(){},rowUpdated:function rowUpdated(){},rowSelectionChanged:function rowSelectionChanged(){},rowSelected:function rowSelected(){},rowDeselected:function rowDeselected(){},rowResized:function rowResized(){},//cell callbacks
//row callbacks
cellClick:false,cellDblClick:false,cellContext:false,cellTap:false,cellDblTap:false,cellTapHold:false,cellMouseEnter:false,cellMouseLeave:false,cellMouseOver:false,cellMouseOut:false,cellMouseMove:false,cellEditing:function cellEditing(){},cellEdited:function cellEdited(){},cellEditCancelled:function cellEditCancelled(){},//column callbacks
columnMoved:false,columnResized:function columnResized(){},columnTitleChanged:function columnTitleChanged(){},columnVisibilityChanged:function columnVisibilityChanged(){},//HTML iport callbacks
htmlImporting:function htmlImporting(){},htmlImported:function htmlImported(){},//data callbacks
dataLoading:function dataLoading(){},dataLoaded:function dataLoaded(){},dataEdited:function dataEdited(){},//ajax callbacks
ajaxRequesting:function ajaxRequesting(){},ajaxResponse:false,ajaxError:function ajaxError(){},//filtering callbacks
dataFiltering:false,dataFiltered:false,//sorting callbacks
dataSorting:function dataSorting(){},dataSorted:function dataSorted(){},//grouping callbacks
groupToggleElement:"arrow",groupClosedShowCalcs:false,dataGrouping:function dataGrouping(){},dataGrouped:false,groupVisibilityChanged:function groupVisibilityChanged(){},groupClick:false,groupDblClick:false,groupContext:false,groupTap:false,groupDblTap:false,groupTapHold:false,columnCalcs:true,//pagination callbacks
pageLoaded:function pageLoaded(){},//localization callbacks
localized:function localized(){},//validation has failed
validationFailed:function validationFailed(){},//history callbacks
historyUndo:function historyUndo(){},historyRedo:function historyRedo(){}};Tabulator.prototype.initializeOptions=function(options){for(var key in this.defaultOptions){if(key in options){this.options[key]=options[key];}else{if(Array.isArray(this.defaultOptions[key])){this.options[key]=[];}else if(_typeof(this.defaultOptions[key])==="object"){this.options[key]={};}else{this.options[key]=this.defaultOptions[key];}}}};Tabulator.prototype.initializeElement=function(element){if(element instanceof HTMLElement){this.element=element;return true;}else if(typeof element==="string"){this.element=document.querySelector(element);if(this.element){return true;}else{console.error("Tabulator Creation Error - no element found matching selector: ",element);return false;}}else{console.error("Tabulator Creation Error - Invalid element provided:",element);return false;}};//convert depricated functionality to new functions
Tabulator.prototype._mapDepricatedFunctionality=function(){};//concreate table
Tabulator.prototype._create=function(){this._clearObjectPointers();this._mapDepricatedFunctionality();this.bindModules();if(this.element.tagName==="TABLE"){if(this.modExists("htmlTableImport",true)){this.modules.htmlTableImport.parseTable();}}this.columnManager=new ColumnManager(this);this.rowManager=new RowManager(this);this.footerManager=new FooterManager(this);this.columnManager.setRowManager(this.rowManager);this.rowManager.setColumnManager(this.columnManager);this._buildElement();this._loadInitialData();};//clear pointers to objects in default config object
Tabulator.prototype._clearObjectPointers=function(){this.options.columns=this.options.columns.slice(0);if(!this.options.reactiveData){this.options.data=this.options.data.slice(0);}};//build tabulator element
Tabulator.prototype._buildElement=function(){var _this7=this;var element=this.element,mod=this.modules,options=this.options;options.tableBuilding.call(this);element.classList.add("tabulator");element.setAttribute("role","grid");//empty element
while(element.firstChild){element.removeChild(element.firstChild);}//set table height
if(options.height){options.height=isNaN(options.height)?options.height:options.height+"px";element.style.height=options.height;}this.columnManager.initialize();this.rowManager.initialize();this._detectBrowser();if(this.modExists("layout",true)){mod.layout.initialize(options.layout);}//set localization
if(options.headerFilterPlaceholder!==false){mod.localize.setHeaderFilterPlaceholder(options.headerFilterPlaceholder);}for(var locale in options.langs){mod.localize.installLang(locale,options.langs[locale]);}mod.localize.setLocale(options.locale);//configure placeholder element
if(typeof options.placeholder=="string"){var el=document.createElement("div");el.classList.add("tabulator-placeholder");var span=document.createElement("span");span.innerHTML=options.placeholder;el.appendChild(span);options.placeholder=el;}//build table elements
element.appendChild(this.columnManager.getElement());element.appendChild(this.rowManager.getElement());if(options.footerElement){this.footerManager.activate();}if(options.dataTree&&this.modExists("dataTree",true)){mod.dataTree.initialize();}if((options.persistentLayout||options.persistentSort||options.persistentFilter)&&this.modExists("persistence",true)){mod.persistence.initialize(options.persistenceMode,options.persistenceID);}if(options.persistentLayout&&this.modExists("persistence",true)){options.columns=mod.persistence.load("columns",options.columns);}if(options.movableRows&&this.modExists("moveRow")){mod.moveRow.initialize();}if(this.modExists("columnCalcs")){mod.columnCalcs.initialize();}this.columnManager.setColumns(options.columns);if(this.modExists("frozenRows")){this.modules.frozenRows.initialize();}if((options.persistentSort||options.initialSort)&&this.modExists("sort",true)){var sorters=[];if(options.persistentSort&&this.modExists("persistence",true)){sorters=mod.persistence.load("sort");if(sorters===false&&options.initialSort){sorters=options.initialSort;}}else if(options.initialSort){sorters=options.initialSort;}mod.sort.setSort(sorters);}if((options.persistentFilter||options.initialFilter)&&this.modExists("filter",true)){var filters=[];if(options.persistentFilter&&this.modExists("persistence",true)){filters=mod.persistence.load("filter");if(filters===false&&options.initialFilter){filters=options.initialFilter;}}else if(options.initialFilter){filters=options.initialFilter;}mod.filter.setFilter(filters);}if(options.initialHeaderFilter&&this.modExists("filter",true)){options.initialHeaderFilter.forEach(function(item){var column=_this7.columnManager.findColumn(item.field);if(column){mod.filter.setHeaderFilterValue(column,item.value);}else{console.warn("Column Filter Error - No matching column found:",item.field);return false;}});}if(this.modExists("ajax")){mod.ajax.initialize();}if(options.pagination&&this.modExists("page",true)){mod.page.initialize();}if(options.groupBy&&this.modExists("groupRows",true)){mod.groupRows.initialize();}if(this.modExists("keybindings")){mod.keybindings.initialize();}if(this.modExists("selectRow")){mod.selectRow.clearSelectionData(true);}if(options.autoResize&&this.modExists("resizeTable")){mod.resizeTable.initialize();}if(this.modExists("clipboard")){mod.clipboard.initialize();}options.tableBuilt.call(this);};Tabulator.prototype._loadInitialData=function(){var self=this;if(self.options.pagination&&self.modExists("page")){self.modules.page.reset(true);if(self.options.pagination=="local"){if(self.options.data.length){self.rowManager.setData(self.options.data);}else{if((self.options.ajaxURL||self.options.ajaxURLGenerator)&&self.modExists("ajax")){self.modules.ajax.loadData().then(function(){}).catch(function(){});}else{self.rowManager.setData(self.options.data);}}}else{if(self.options.ajaxURL){self.modules.page.setPage(1).then(function(){}).catch(function(){});}else{self.rowManager.setData([]);}}}else{if(self.options.data.length){self.rowManager.setData(self.options.data);}else{if((self.options.ajaxURL||self.options.ajaxURLGenerator)&&self.modExists("ajax")){self.modules.ajax.loadData().then(function(){}).catch(function(){});}else{self.rowManager.setData(self.options.data);}}}};//deconstructor
Tabulator.prototype.destroy=function(){var element=this.element;Tabulator.prototype.comms.deregister(this);//deregister table from inderdevice communication
if(self.table.options.reactiveData&&this.table.modExists("reactiveData",true)){this.table.modules.reactiveData.unwatchData();}//clear row data
this.rowManager.rows.forEach(function(row){row.wipe();});this.rowManager.rows=[];this.rowManager.activeRows=[];this.rowManager.displayRows=[];//clear event bindings
if(this.options.autoResize&&this.modExists("resizeTable")){this.modules.resizeTable.clearBindings();}if(this.modExists("keybindings")){this.modules.keybindings.clearBindings();}//clear DOM
while(element.firstChild){element.removeChild(element.firstChild);}element.classList.remove("tabulator");};Tabulator.prototype._detectBrowser=function(){var ua=navigator.userAgent;if(ua.indexOf("Trident")>-1){this.browser="ie";this.browserSlow=true;}else if(ua.indexOf("Edge")>-1){this.browser="edge";this.browserSlow=true;}else if(ua.indexOf("Firefox")>-1){this.browser="firefox";this.browserSlow=false;}else{this.browser="other";this.browserSlow=false;}};////////////////// Data Handling //////////////////
//loca data from local file
Tabulator.prototype.setDataFromLocalFile=function(extensions){var _this8=this;return new Promise(function(resolve,reject){var input=document.createElement("input");input.type="file";input.accept=extensions||".json,application/json";input.addEventListener("change",function(e){var file=input.files[0],reader=new FileReader(),data;reader.readAsText(file);reader.onload=function(e){try{data=JSON.parse(reader.result);}catch(e){console.warn("File Load Error - File contents is invalid JSON",e);reject(e);return;}_this8._setData(data).then(function(data){resolve(data);}).catch(function(err){resolve(err);});};reader.onerror=function(e){console.warn("File Load Error - Unable to read file");reject();};});input.click();});};//load data
Tabulator.prototype.setData=function(data,params,config){if(this.modExists("ajax")){this.modules.ajax.blockActiveRequest();}return this._setData(data,params,config);};Tabulator.prototype._setData=function(data,params,config,inPosition){var self=this;if(typeof data==="string"){if(data.indexOf("{")==0||data.indexOf("[")==0){//data is a json encoded string
return self.rowManager.setData(JSON.parse(data),inPosition);}else{if(self.modExists("ajax",true)){if(params){self.modules.ajax.setParams(params);}if(config){self.modules.ajax.setConfig(config);}self.modules.ajax.setUrl(data);if(self.options.pagination=="remote"&&self.modExists("page",true)){self.modules.page.reset(true);return self.modules.page.setPage(1);}else{//assume data is url, make ajax call to url to get data
return self.modules.ajax.loadData(inPosition);}}}}else{if(data){//asume data is already an object
return self.rowManager.setData(data,inPosition);}else{//no data provided, check if ajaxURL is present;
if(self.modExists("ajax")&&(self.modules.ajax.getUrl||self.options.ajaxURLGenerator)){if(self.options.pagination=="remote"&&self.modExists("page",true)){self.modules.page.reset(true);return self.modules.page.setPage(1);}else{return self.modules.ajax.loadData(inPosition);}}else{//empty data
return self.rowManager.setData([],inPosition);}}}};//clear data
Tabulator.prototype.clearData=function(){if(this.modExists("ajax")){this.modules.ajax.blockActiveRequest();}this.rowManager.clearData();};//get table data array
Tabulator.prototype.getData=function(active){return this.rowManager.getData(active);};//get table data array count
Tabulator.prototype.getDataCount=function(active){return this.rowManager.getDataCount(active);};//search for specific row components
Tabulator.prototype.searchRows=function(field,type,value){if(this.modExists("filter",true)){return this.modules.filter.search("rows",field,type,value);}};//search for specific data
Tabulator.prototype.searchData=function(field,type,value){if(this.modExists("filter",true)){return this.modules.filter.search("data",field,type,value);}};//get table html
Tabulator.prototype.getHtml=function(active){return this.rowManager.getHtml(active);};//retrieve Ajax URL
Tabulator.prototype.getAjaxUrl=function(){if(this.modExists("ajax",true)){return this.modules.ajax.getUrl();}};//replace data, keeping table in position with same sort
Tabulator.prototype.replaceData=function(data,params,config){if(this.modExists("ajax")){this.modules.ajax.blockActiveRequest();}return this._setData(data,params,config,true);};//update table data
Tabulator.prototype.updateData=function(data){var _this9=this;var self=this;var responses=0;return new Promise(function(resolve,reject){if(_this9.modExists("ajax")){_this9.modules.ajax.blockActiveRequest();}if(typeof data==="string"){data=JSON.parse(data);}if(data){data.forEach(function(item){var row=self.rowManager.findRow(item[self.options.index]);if(row){responses++;row.updateData(item).then(function(){responses--;if(!responses){resolve();}});}});}else{console.warn("Update Error - No data provided");reject("Update Error - No data provided");}});};Tabulator.prototype.addData=function(data,pos,index){var _this10=this;return new Promise(function(resolve,reject){if(_this10.modExists("ajax")){_this10.modules.ajax.blockActiveRequest();}if(typeof data==="string"){data=JSON.parse(data);}if(data){_this10.rowManager.addRows(data,pos,index).then(function(rows){var output=[];rows.forEach(function(row){output.push(row.getComponent());});resolve(output);});}else{console.warn("Update Error - No data provided");reject("Update Error - No data provided");}});};//update table data
Tabulator.prototype.updateOrAddData=function(data){var _this11=this;var self=this,rows=[],responses=0;return new Promise(function(resolve,reject){if(_this11.modExists("ajax")){_this11.modules.ajax.blockActiveRequest();}if(typeof data==="string"){data=JSON.parse(data);}if(data){data.forEach(function(item){var row=self.rowManager.findRow(item[self.options.index]);responses++;if(row){row.updateData(item).then(function(){responses--;rows.push(row.getComponent());if(!responses){resolve(rows);}});}else{self.rowManager.addRows(item).then(function(newRows){responses--;rows.push(newRows[0].getComponent());if(!responses){resolve(rows);}});}});}else{console.warn("Update Error - No data provided");reject("Update Error - No data provided");}});};//get row object
Tabulator.prototype.getRow=function(index){var row=this.rowManager.findRow(index);if(row){return row.getComponent();}else{console.warn("Find Error - No matching row found:",index);return false;}};//get row object
Tabulator.prototype.getRowFromPosition=function(position,active){var row=this.rowManager.getRowFromPosition(position,active);if(row){return row.getComponent();}else{console.warn("Find Error - No matching row found:",position);return false;}};//delete row from table
Tabulator.prototype.deleteRow=function(index){var _this12=this;return new Promise(function(resolve,reject){var row=_this12.rowManager.findRow(index);if(row){row.delete().then(function(){resolve();}).catch(function(err){reject(err);});}else{console.warn("Delete Error - No matching row found:",index);reject("Delete Error - No matching row found");}});};//add row to table
Tabulator.prototype.addRow=function(data,pos,index){var _this13=this;return new Promise(function(resolve,reject){if(typeof data==="string"){data=JSON.parse(data);}_this13.rowManager.addRows(data,pos,index).then(function(rows){//recalc column calculations if present
if(_this13.modExists("columnCalcs")){_this13.modules.columnCalcs.recalc(_this13.rowManager.activeRows);}resolve(rows[0].getComponent());});});};//update a row if it exitsts otherwise create it
Tabulator.prototype.updateOrAddRow=function(index,data){var _this14=this;return new Promise(function(resolve,reject){var row=_this14.rowManager.findRow(index);if(typeof data==="string"){data=JSON.parse(data);}if(row){row.updateData(data).then(function(){//recalc column calculations if present
if(_this14.modExists("columnCalcs")){_this14.modules.columnCalcs.recalc(_this14.rowManager.activeRows);}resolve(row.getComponent());}).catch(function(err){reject(err);});}else{row=_this14.rowManager.addRows(data).then(function(rows){//recalc column calculations if present
if(_this14.modExists("columnCalcs")){_this14.modules.columnCalcs.recalc(_this14.rowManager.activeRows);}resolve(rows[0].getComponent());}).catch(function(err){reject(err);});}});};//update row data
Tabulator.prototype.updateRow=function(index,data){var _this15=this;return new Promise(function(resolve,reject){var row=_this15.rowManager.findRow(index);if(typeof data==="string"){data=JSON.parse(data);}if(row){row.updateData(data).then(function(){resolve(row.getComponent());}).catch(function(err){reject(err);});}else{console.warn("Update Error - No matching row found:",index);reject("Update Error - No matching row found");}});};//scroll to row in DOM
Tabulator.prototype.scrollToRow=function(index,position,ifVisible){var _this16=this;return new Promise(function(resolve,reject){var row=_this16.rowManager.findRow(index);if(row){_this16.rowManager.scrollToRow(row,position,ifVisible).then(function(){resolve();}).catch(function(err){reject(err);});}else{console.warn("Scroll Error - No matching row found:",index);reject("Scroll Error - No matching row found");}});};Tabulator.prototype.moveRow=function(from,to,after){var fromRow=this.rowManager.findRow(from);if(fromRow){fromRow.moveToRow(to,after);}else{console.warn("Move Error - No matching row found:",from);}};Tabulator.prototype.getRows=function(active){return this.rowManager.getComponents(active);};//get position of row in table
Tabulator.prototype.getRowPosition=function(index,active){var row=this.rowManager.findRow(index);if(row){return this.rowManager.getRowPosition(row,active);}else{console.warn("Position Error - No matching row found:",index);return false;}};//copy table data to clipboard
Tabulator.prototype.copyToClipboard=function(selector,selectorParams,formatter,formatterParams){if(this.modExists("clipboard",true)){this.modules.clipboard.copy(selector,selectorParams,formatter,formatterParams);}};/////////////// Column Functions  ///////////////
Tabulator.prototype.setColumns=function(definition){this.columnManager.setColumns(definition);};Tabulator.prototype.getColumns=function(structured){return this.columnManager.getComponents(structured);};Tabulator.prototype.getColumn=function(field){var col=this.columnManager.findColumn(field);if(col){return col.getComponent();}else{console.warn("Find Error - No matching column found:",field);return false;}};Tabulator.prototype.getColumnDefinitions=function(){return this.columnManager.getDefinitionTree();};Tabulator.prototype.getColumnLayout=function(){if(this.modExists("persistence",true)){return this.modules.persistence.parseColumns(this.columnManager.getColumns());}};Tabulator.prototype.setColumnLayout=function(layout){if(this.modExists("persistence",true)){this.columnManager.setColumns(this.modules.persistence.mergeDefinition(this.options.columns,layout));return true;}return false;};Tabulator.prototype.showColumn=function(field){var column=this.columnManager.findColumn(field);if(column){column.show();if(this.options.responsiveLayout&&this.modExists("responsiveLayout",true)){this.modules.responsiveLayout.update();}}else{console.warn("Column Show Error - No matching column found:",field);return false;}};Tabulator.prototype.hideColumn=function(field){var column=this.columnManager.findColumn(field);if(column){column.hide();if(this.options.responsiveLayout&&this.modExists("responsiveLayout",true)){this.modules.responsiveLayout.update();}}else{console.warn("Column Hide Error - No matching column found:",field);return false;}};Tabulator.prototype.toggleColumn=function(field){var column=this.columnManager.findColumn(field);if(column){if(column.visible){column.hide();}else{column.show();}}else{console.warn("Column Visibility Toggle Error - No matching column found:",field);return false;}};Tabulator.prototype.addColumn=function(definition,before,field){var column=this.columnManager.findColumn(field);this.columnManager.addColumn(definition,before,column);};Tabulator.prototype.deleteColumn=function(field){var column=this.columnManager.findColumn(field);if(column){column.delete();}else{console.warn("Column Delete Error - No matching column found:",field);return false;}};//scroll to column in DOM
Tabulator.prototype.scrollToColumn=function(field,position,ifVisible){var _this17=this;return new Promise(function(resolve,reject){var column=_this17.columnManager.findColumn(field);if(column){_this17.columnManager.scrollToColumn(column,position,ifVisible).then(function(){resolve();}).catch(function(err){reject(err);});}else{console.warn("Scroll Error - No matching column found:",field);reject("Scroll Error - No matching column found");}});};//////////// Localization Functions  ////////////
Tabulator.prototype.setLocale=function(locale){this.modules.localize.setLocale(locale);};Tabulator.prototype.getLocale=function(){return this.modules.localize.getLocale();};Tabulator.prototype.getLang=function(locale){return this.modules.localize.getLang(locale);};//////////// General Public Functions ////////////
//redraw list without updating data
Tabulator.prototype.redraw=function(force){this.columnManager.redraw(force);this.rowManager.redraw(force);};Tabulator.prototype.setHeight=function(height){this.options.height=isNaN(height)?height:height+"px";this.element.style.height=this.options.height;this.rowManager.redraw();};///////////////////// Sorting ////////////////////
//trigger sort
Tabulator.prototype.setSort=function(sortList,dir){if(this.modExists("sort",true)){this.modules.sort.setSort(sortList,dir);this.rowManager.sorterRefresh();}};Tabulator.prototype.getSorters=function(){if(this.modExists("sort",true)){return this.modules.sort.getSort();}};Tabulator.prototype.clearSort=function(){if(this.modExists("sort",true)){this.modules.sort.clear();this.rowManager.sorterRefresh();}};///////////////////// Filtering ////////////////////
//set standard filters
Tabulator.prototype.setFilter=function(field,type,value){if(this.modExists("filter",true)){this.modules.filter.setFilter(field,type,value);this.rowManager.filterRefresh();}};//add filter to array
Tabulator.prototype.addFilter=function(field,type,value){if(this.modExists("filter",true)){this.modules.filter.addFilter(field,type,value);this.rowManager.filterRefresh();}};//get all filters
Tabulator.prototype.getFilters=function(all){if(this.modExists("filter",true)){return this.modules.filter.getFilters(all);}};Tabulator.prototype.setHeaderFilterFocus=function(field){if(this.modExists("filter",true)){var column=this.columnManager.findColumn(field);if(column){this.modules.filter.setHeaderFilterFocus(column);}else{console.warn("Column Filter Focus Error - No matching column found:",field);return false;}}};Tabulator.prototype.setHeaderFilterValue=function(field,value){if(this.modExists("filter",true)){var column=this.columnManager.findColumn(field);if(column){this.modules.filter.setHeaderFilterValue(column,value);}else{console.warn("Column Filter Error - No matching column found:",field);return false;}}};Tabulator.prototype.getHeaderFilters=function(){if(this.modExists("filter",true)){return this.modules.filter.getHeaderFilters();}};//remove filter from array
Tabulator.prototype.removeFilter=function(field,type,value){if(this.modExists("filter",true)){this.modules.filter.removeFilter(field,type,value);this.rowManager.filterRefresh();}};//clear filters
Tabulator.prototype.clearFilter=function(all){if(this.modExists("filter",true)){this.modules.filter.clearFilter(all);this.rowManager.filterRefresh();}};//clear header filters
Tabulator.prototype.clearHeaderFilter=function(){if(this.modExists("filter",true)){this.modules.filter.clearHeaderFilter();this.rowManager.filterRefresh();}};///////////////////// Filtering ////////////////////
Tabulator.prototype.selectRow=function(rows){if(this.modExists("selectRow",true)){this.modules.selectRow.selectRows(rows);}};Tabulator.prototype.deselectRow=function(rows){if(this.modExists("selectRow",true)){this.modules.selectRow.deselectRows(rows);}};Tabulator.prototype.toggleSelectRow=function(row){if(this.modExists("selectRow",true)){this.modules.selectRow.toggleRow(row);}};Tabulator.prototype.getSelectedRows=function(){if(this.modExists("selectRow",true)){return this.modules.selectRow.getSelectedRows();}};Tabulator.prototype.getSelectedData=function(){if(this.modExists("selectRow",true)){return this.modules.selectRow.getSelectedData();}};//////////// Pagination Functions  ////////////
Tabulator.prototype.setMaxPage=function(max){if(this.options.pagination&&this.modExists("page")){this.modules.page.setMaxPage(max);}else{return false;}};Tabulator.prototype.setPage=function(page){if(this.options.pagination&&this.modExists("page")){return this.modules.page.setPage(page);}else{return new Promise(function(resolve,reject){reject();});}};Tabulator.prototype.setPageToRow=function(row){var _this18=this;return new Promise(function(resolve,reject){if(_this18.options.pagination&&_this18.modExists("page")){row=_this18.rowManager.findRow(row);if(row){_this18.modules.page.setPageToRow(row).then(function(){resolve();}).catch(function(){reject();});}else{reject();}}else{reject();}});};Tabulator.prototype.setPageSize=function(size){if(this.options.pagination&&this.modExists("page")){this.modules.page.setPageSize(size);this.modules.page.setPage(1).then(function(){}).catch(function(){});}else{return false;}};Tabulator.prototype.getPageSize=function(){if(this.options.pagination&&this.modExists("page",true)){return this.modules.page.getPageSize();}};Tabulator.prototype.previousPage=function(){if(this.options.pagination&&this.modExists("page")){this.modules.page.previousPage();}else{return false;}};Tabulator.prototype.nextPage=function(){if(this.options.pagination&&this.modExists("page")){this.modules.page.nextPage();}else{return false;}};Tabulator.prototype.getPage=function(){if(this.options.pagination&&this.modExists("page")){return this.modules.page.getPage();}else{return false;}};Tabulator.prototype.getPageMax=function(){if(this.options.pagination&&this.modExists("page")){return this.modules.page.getPageMax();}else{return false;}};///////////////// Grouping Functions ///////////////
Tabulator.prototype.setGroupBy=function(groups){if(this.modExists("groupRows",true)){this.options.groupBy=groups;this.modules.groupRows.initialize();this.rowManager.refreshActiveData("display");}else{return false;}};Tabulator.prototype.setGroupStartOpen=function(values){if(this.modExists("groupRows",true)){this.options.groupStartOpen=values;this.modules.groupRows.initialize();if(this.options.groupBy){this.rowManager.refreshActiveData("group");}else{console.warn("Grouping Update - cant refresh view, no groups have been set");}}else{return false;}};Tabulator.prototype.setGroupHeader=function(values){if(this.modExists("groupRows",true)){this.options.groupHeader=values;this.modules.groupRows.initialize();if(this.options.groupBy){this.rowManager.refreshActiveData("group");}else{console.warn("Grouping Update - cant refresh view, no groups have been set");}}else{return false;}};Tabulator.prototype.getGroups=function(values){if(this.modExists("groupRows",true)){return this.modules.groupRows.getGroups(true);}else{return false;}};// get grouped table data in the same format as getData()
Tabulator.prototype.getGroupedData=function(){if(this.modExists("groupRows",true)){return this.options.groupBy?this.modules.groupRows.getGroupedData():this.getData();}};///////////////// Column Calculation Functions ///////////////
Tabulator.prototype.getCalcResults=function(){if(this.modExists("columnCalcs",true)){return this.modules.columnCalcs.getResults();}else{return false;}};/////////////// Navigation Management //////////////
Tabulator.prototype.navigatePrev=function(){var cell=false;if(this.modExists("edit",true)){cell=this.modules.edit.currentCell;if(cell){return cell.nav().prev();}}return false;};Tabulator.prototype.navigateNext=function(){var cell=false;if(this.modExists("edit",true)){cell=this.modules.edit.currentCell;if(cell){return cell.nav().next();}}return false;};Tabulator.prototype.navigateLeft=function(){var cell=false;if(this.modExists("edit",true)){cell=this.modules.edit.currentCell;if(cell){e.preventDefault();return cell.nav().left();}}return false;};Tabulator.prototype.navigateRight=function(){var cell=false;if(this.modExists("edit",true)){cell=this.modules.edit.currentCell;if(cell){e.preventDefault();return cell.nav().right();}}return false;};Tabulator.prototype.navigateUp=function(){var cell=false;if(this.modExists("edit",true)){cell=this.modules.edit.currentCell;if(cell){e.preventDefault();return cell.nav().up();}}return false;};Tabulator.prototype.navigateDown=function(){var cell=false;if(this.modExists("edit",true)){cell=this.modules.edit.currentCell;if(cell){e.preventDefault();return cell.nav().dpwn();}}return false;};/////////////// History Management //////////////
Tabulator.prototype.undo=function(){if(this.options.history&&this.modExists("history",true)){return this.modules.history.undo();}else{return false;}};Tabulator.prototype.redo=function(){if(this.options.history&&this.modExists("history",true)){return this.modules.history.redo();}else{return false;}};Tabulator.prototype.getHistoryUndoSize=function(){if(this.options.history&&this.modExists("history",true)){return this.modules.history.getHistoryUndoSize();}else{return false;}};Tabulator.prototype.getHistoryRedoSize=function(){if(this.options.history&&this.modExists("history",true)){return this.modules.history.getHistoryRedoSize();}else{return false;}};/////////////// Download Management //////////////
Tabulator.prototype.download=function(type,filename,options){if(this.modExists("download",true)){this.modules.download.download(type,filename,options);}};Tabulator.prototype.downloadToTab=function(type,filename,options){if(this.modExists("download",true)){this.modules.download.download(type,filename,options,true);}};/////////// Inter Table Communications ///////////
Tabulator.prototype.tableComms=function(table,module,action,data){this.modules.comms.receive(table,module,action,data);};////////////// Extension Management //////////////
//object to hold module
Tabulator.prototype.moduleBindings={};//extend module
Tabulator.prototype.extendModule=function(name,property,values){if(Tabulator.prototype.moduleBindings[name]){var source=Tabulator.prototype.moduleBindings[name].prototype[property];if(source){if((typeof values==='undefined'?'undefined':_typeof(values))=="object"){for(var key in values){source[key]=values[key];}}else{console.warn("Module Error - Invalid value type, it must be an object");}}else{console.warn("Module Error - property does not exist:",property);}}else{console.warn("Module Error - module does not exist:",name);}};//add module to tabulator
Tabulator.prototype.registerModule=function(name,module){var self=this;Tabulator.prototype.moduleBindings[name]=module;};//ensure that module are bound to instantiated function
Tabulator.prototype.bindModules=function(){this.modules={};for(var name in Tabulator.prototype.moduleBindings){this.modules[name]=new Tabulator.prototype.moduleBindings[name](this);}};//Check for module
Tabulator.prototype.modExists=function(plugin,required){if(this.modules[plugin]){return true;}else{if(required){console.error("Tabulator Module Not Installed: "+plugin);}return false;}};Tabulator.prototype.helpers={elVisible:function elVisible(el){return!(el.offsetWidth<=0&&el.offsetHeight<=0);},elOffset:function elOffset(el){var box=el.getBoundingClientRect();return{top:box.top+window.pageYOffset-document.documentElement.clientTop,left:box.left+window.pageXOffset-document.documentElement.clientLeft};},deepClone:function deepClone(obj){var clone=Array.isArray(obj)?[]:{};for(var i in obj){if(obj[i]!=null&&_typeof(obj[i])==="object"){if(obj[i]instanceof Date){clone[i]=new Date(obj[i]);}else{clone[i]=this.deepClone(obj[i]);}}else{clone[i]=obj[i];}}return clone;}};Tabulator.prototype.comms={tables:[],register:function register(table){Tabulator.prototype.comms.tables.push(table);},deregister:function deregister(table){var index=Tabulator.prototype.comms.tables.indexOf(table);if(index>-1){Tabulator.prototype.comms.tables.splice(index,1);}},lookupTable:function lookupTable(query){var results=[],matches,match;if(typeof query==="string"){matches=document.querySelectorAll(query);if(matches.length){for(var i=0;i<matches.length;i++){match=Tabulator.prototype.comms.matchElement(matches[i]);if(match){results.push(match);}}}}else if(query instanceof HTMLElement||query instanceof Tabulator){match=Tabulator.prototype.comms.matchElement(query);if(match){results.push(match);}}else if(Array.isArray(query)){query.forEach(function(item){results=results.concat(Tabulator.prototype.comms.lookupTable(item));});}else{console.warn("Table Connection Error - Invalid Selector",query);}return results;},matchElement:function matchElement(element){return Tabulator.prototype.comms.tables.find(function(table){return element instanceof Tabulator?table===element:table.element===element;});}};var Layout=function Layout(table){this.table=table;this.mode=null;};//initialize layout system
Layout.prototype.initialize=function(layout){if(this.modes[layout]){this.mode=layout;}else{console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : "+layout);this.mode='fitData';}this.table.element.setAttribute("tabulator-layout",this.mode);};Layout.prototype.getMode=function(){return this.mode;};//trigger table layout
Layout.prototype.layout=function(){this.modes[this.mode].call(this,this.table.columnManager.columnsByIndex);};//layout render functions
Layout.prototype.modes={//resize columns to fit data the contain
"fitData":function fitData(columns){columns.forEach(function(column){column.reinitializeWidth();});if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.update();}},//resize columns to fit data the contain
"fitDataFill":function fitDataFill(columns){columns.forEach(function(column){column.reinitializeWidth();});if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.update();}},//resize columns to fit
"fitColumns":function fitColumns(columns){var self=this;var totalWidth=self.table.element.clientWidth;//table element width
var fixedWidth=0;//total width of columns with a defined width
var flexWidth=0;//total width available to flexible columns
var flexGrowUnits=0;//total number of widthGrow blocks accross all columns
var flexColWidth=0;//desired width of flexible columns
var flexColumns=[];//array of flexible width columns
var fixedShrinkColumns=[];//array of fixed width columns that can shrink
var flexShrinkUnits=0;//total number of widthShrink blocks accross all columns
var overflowWidth=0;//horizontal overflow width
var gapFill=0;//number of pixels to be added to final column to close and half pixel gaps
function calcWidth(width){var colWidth;if(typeof width=="string"){if(width.indexOf("%")>-1){colWidth=totalWidth/100*parseInt(width);}else{colWidth=parseInt(width);}}else{colWidth=width;}return colWidth;}//ensure columns resize to take up the correct amount of space
function scaleColumns(columns,freeSpace,colWidth,shrinkCols){var oversizeCols=[],oversizeSpace=0,remainingSpace=0,nextColWidth=0,gap=0,changeUnits=0,undersizeCols=[];function calcGrow(col){return colWidth*(col.column.definition.widthGrow||1);}function calcShrink(col){return calcWidth(col.width)-colWidth*(col.column.definition.widthShrink||0);}columns.forEach(function(col,i){var width=shrinkCols?calcShrink(col):calcGrow(col);if(col.column.minWidth>=width){oversizeCols.push(col);}else{undersizeCols.push(col);changeUnits+=shrinkCols?col.column.definition.widthShrink||1:col.column.definition.widthGrow||1;}});if(oversizeCols.length){oversizeCols.forEach(function(col){oversizeSpace+=shrinkCols?col.width-col.column.minWidth:col.column.minWidth;col.width=col.column.minWidth;});remainingSpace=freeSpace-oversizeSpace;nextColWidth=changeUnits?Math.floor(remainingSpace/changeUnits):remainingSpace;gap=remainingSpace-nextColWidth*changeUnits;gap+=scaleColumns(undersizeCols,remainingSpace,nextColWidth,shrinkCols);}else{gap=changeUnits?freeSpace-Math.floor(freeSpace/changeUnits)*changeUnits:freeSpace;undersizeCols.forEach(function(column){column.width=shrinkCols?calcShrink(column):calcGrow(column);});}return gap;}if(this.table.options.responsiveLayout&&this.table.modExists("responsiveLayout",true)){this.table.modules.responsiveLayout.update();}//adjust for vertical scrollbar if present
if(this.table.rowManager.element.scrollHeight>this.table.rowManager.element.clientHeight){totalWidth-=this.table.rowManager.element.offsetWidth-this.table.rowManager.element.clientWidth;}columns.forEach(function(column){var width,minWidth,colWidth;if(column.visible){width=column.definition.width;minWidth=parseInt(column.minWidth);if(width){colWidth=calcWidth(width);fixedWidth+=colWidth>minWidth?colWidth:minWidth;if(column.definition.widthShrink){fixedShrinkColumns.push({column:column,width:colWidth>minWidth?colWidth:minWidth});flexShrinkUnits+=column.definition.widthShrink;}}else{flexColumns.push({column:column,width:0});flexGrowUnits+=column.definition.widthGrow||1;}}});//calculate available space
flexWidth=totalWidth-fixedWidth;//calculate correct column size
flexColWidth=Math.floor(flexWidth/flexGrowUnits);//generate column widths
var gapFill=scaleColumns(flexColumns,flexWidth,flexColWidth,false);//increase width of last column to account for rounding errors
if(flexColumns.length&&gapFill>0){flexColumns[flexColumns.length-1].width+=+gapFill;}//caculate space for columns to be shrunk into
flexColumns.forEach(function(col){flexWidth-=col.width;});overflowWidth=Math.abs(gapFill)+flexWidth;//shrink oversize columns if there is no available space
if(overflowWidth>0&&flexShrinkUnits){gapFill=scaleColumns(fixedShrinkColumns,overflowWidth,Math.floor(overflowWidth/flexShrinkUnits),true);}//decrease width of last column to account for rounding errors
if(fixedShrinkColumns.length){fixedShrinkColumns[fixedShrinkColumns.length-1].width-=gapFill;}flexColumns.forEach(function(col){col.column.setWidth(col.width);});fixedShrinkColumns.forEach(function(col){col.column.setWidth(col.width);});}};Tabulator.prototype.registerModule("layout",Layout);var Localize=function Localize(table){this.table=table;//hold Tabulator object
this.locale="default";//current locale
this.lang=false;//current language
this.bindings={};//update events to call when locale is changed
};//set header placehoder
Localize.prototype.setHeaderFilterPlaceholder=function(placeholder){this.langs.default.headerFilters.default=placeholder;};//set header filter placeholder by column
Localize.prototype.setHeaderFilterColumnPlaceholder=function(column,placeholder){this.langs.default.headerFilters.columns[column]=placeholder;if(this.lang&&!this.lang.headerFilters.columns[column]){this.lang.headerFilters.columns[column]=placeholder;}};//setup a lang description object
Localize.prototype.installLang=function(locale,lang){if(this.langs[locale]){this._setLangProp(this.langs[locale],lang);}else{this.langs[locale]=lang;}};Localize.prototype._setLangProp=function(lang,values){for(var key in values){if(lang[key]&&_typeof(lang[key])=="object"){this._setLangProp(lang[key],values[key]);}else{lang[key]=values[key];}}};//set current locale
Localize.prototype.setLocale=function(desiredLocale){var self=this;desiredLocale=desiredLocale||"default";//fill in any matching languge values
function traverseLang(trans,path){for(var prop in trans){if(_typeof(trans[prop])=="object"){if(!path[prop]){path[prop]={};}traverseLang(trans[prop],path[prop]);}else{path[prop]=trans[prop];}}}//determing correct locale to load
if(desiredLocale===true&&navigator.language){//get local from system
desiredLocale=navigator.language.toLowerCase();}if(desiredLocale){//if locale is not set, check for matching top level locale else use default
if(!self.langs[desiredLocale]){var prefix=desiredLocale.split("-")[0];if(self.langs[prefix]){console.warn("Localization Error - Exact matching locale not found, using closest match: ",desiredLocale,prefix);desiredLocale=prefix;}else{console.warn("Localization Error - Matching locale not found, using default: ",desiredLocale);desiredLocale="default";}}}self.locale=desiredLocale;//load default lang template
self.lang=Tabulator.prototype.helpers.deepClone(self.langs.default||{});if(desiredLocale!="default"){traverseLang(self.langs[desiredLocale],self.lang);}self.table.options.localized.call(self.table,self.locale,self.lang);self._executeBindings();};//get current locale
Localize.prototype.getLocale=function(locale){return self.locale;};//get lang object for given local or current if none provided
Localize.prototype.getLang=function(locale){return locale?this.langs[locale]:this.lang;};//get text for current locale
Localize.prototype.getText=function(path,value){var path=value?path+"|"+value:path,pathArray=path.split("|"),text=this._getLangElement(pathArray,this.locale);// if(text === false){
// 	console.warn("Localization Error - Matching localized text not found for given path: ", path);
// }
return text||"";};//traverse langs object and find localized copy
Localize.prototype._getLangElement=function(path,locale){var self=this;var root=self.lang;path.forEach(function(level){var rootPath;if(root){rootPath=root[level];if(typeof rootPath!="undefined"){root=rootPath;}else{root=false;}}});return root;};//set update binding
Localize.prototype.bind=function(path,callback){if(!this.bindings[path]){this.bindings[path]=[];}this.bindings[path].push(callback);callback(this.getText(path),this.lang);};//itterate through bindings and trigger updates
Localize.prototype._executeBindings=function(){var self=this;var _loop=function _loop(path){self.bindings[path].forEach(function(binding){binding(self.getText(path),self.lang);});};for(var path in self.bindings){_loop(path);}};//Localized text listings
Localize.prototype.langs={"default":{//hold default locale text
"groups":{"item":"item","items":"items"},"columns":{},"ajax":{"loading":"Loading","error":"Error"},"pagination":{"page_size":"Page Size","first":"First","first_title":"First Page","last":"Last","last_title":"Last Page","prev":"Prev","prev_title":"Prev Page","next":"Next","next_title":"Next Page"},"headerFilters":{"default":"filter column...","columns":{}}}};Tabulator.prototype.registerModule("localize",Localize);var Comms=function Comms(table){this.table=table;};Comms.prototype.getConnections=function(selectors){var self=this,connections=[],connection;connection=Tabulator.prototype.comms.lookupTable(selectors);connection.forEach(function(con){if(self.table!==con){connections.push(con);}});return connections;};Comms.prototype.send=function(selectors,module,action,data){var self=this,connections=this.getConnections(selectors);connections.forEach(function(connection){connection.tableComms(self.table.element,module,action,data);});if(!connections.length&&selectors){console.warn("Table Connection Error - No tables matching selector found",selectors);}};Comms.prototype.receive=function(table,module,action,data){if(this.table.modExists(module)){return this.table.modules[module].commsReceived(table,action,data);}else{console.warn("Inter-table Comms Error - no such module:",module);}};Tabulator.prototype.registerModule("comms",Comms);var Accessor=function Accessor(table){this.table=table;//hold Tabulator object
this.allowedTypes=["","data","download","clipboard"];//list of accessor types
};//initialize column accessor
Accessor.prototype.initializeColumn=function(column){var self=this,match=false,config={};this.allowedTypes.forEach(function(type){var key="accessor"+(type.charAt(0).toUpperCase()+type.slice(1)),accessor;if(column.definition[key]){accessor=self.lookupAccessor(column.definition[key]);if(accessor){match=true;config[key]={accessor:accessor,params:column.definition[key+"Params"]||{}};}}});if(match){column.modules.accessor=config;}},Accessor.prototype.lookupAccessor=function(value){var accessor=false;//set column accessor
switch(typeof value==='undefined'?'undefined':_typeof(value)){case"string":if(this.accessors[value]){accessor=this.accessors[value];}else{console.warn("Accessor Error - No such accessor found, ignoring: ",value);}break;case"function":accessor=value;break;}return accessor;};//apply accessor to row
Accessor.prototype.transformRow=function(dataIn,type){var self=this,key="accessor"+(type.charAt(0).toUpperCase()+type.slice(1));//clone data object with deep copy to isolate internal data from returned result
var data=Tabulator.prototype.helpers.deepClone(dataIn||{});self.table.columnManager.traverse(function(column){var value,accessor,params,component;if(column.modules.accessor){accessor=column.modules.accessor[key]||column.modules.accessor.accessor||false;if(accessor){value=column.getFieldValue(data);if(value!="undefined"){component=column.getComponent();params=typeof accessor.params==="function"?accessor.params(value,data,type,component):accessor.params;column.setFieldValue(data,accessor.accessor(value,data,type,params,component));}}}});return data;},//default accessors
Accessor.prototype.accessors={};Tabulator.prototype.registerModule("accessor",Accessor);var Ajax=function Ajax(table){this.table=table;//hold Tabulator object
this.config=false;//hold config object for ajax request
this.url="";//request URL
this.urlGenerator=false;this.params=false;//request parameters
this.loaderElement=this.createLoaderElement();//loader message div
this.msgElement=this.createMsgElement();//message element
this.loadingElement=false;this.errorElement=false;this.loaderPromise=false;this.progressiveLoad=false;this.loading=false;this.requestOrder=0;//prevent requests comming out of sequence if overridden by another load request
};//initialize setup options
Ajax.prototype.initialize=function(){var template;this.loaderElement.appendChild(this.msgElement);if(this.table.options.ajaxLoaderLoading){if(typeof this.table.options.ajaxLoaderLoading=="string"){template=document.createElement('template');template.innerHTML=this.table.options.ajaxLoaderLoading.trim();this.loadingElement=template.content.firstChild;}else{this.loadingElement=this.table.options.ajaxLoaderLoading;}}this.loaderPromise=this.table.options.ajaxRequestFunc||this.defaultLoaderPromise;this.urlGenerator=this.table.options.ajaxURLGenerator||this.defaultURLGenerator;if(this.table.options.ajaxLoaderError){this.errorElement=this.table.options.ajaxLoaderError;}if(this.table.options.ajaxParams){this.setParams(this.table.options.ajaxParams);}if(this.table.options.ajaxConfig){this.setConfig(this.table.options.ajaxConfig);}if(this.table.options.ajaxURL){this.setUrl(this.table.options.ajaxURL);}if(this.table.options.ajaxProgressiveLoad){if(this.table.options.pagination){this.progressiveLoad=false;console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time");}else{if(this.table.modExists("page")){this.progressiveLoad=this.table.options.ajaxProgressiveLoad;this.table.modules.page.initializeProgressive(this.progressiveLoad);}else{console.error("Pagination plugin is required for progressive ajax loading");}}}};Ajax.prototype.createLoaderElement=function(){var el=document.createElement("div");el.classList.add("tabulator-loader");return el;};Ajax.prototype.createMsgElement=function(){var el=document.createElement("div");el.classList.add("tabulator-loader-msg");el.setAttribute("role","alert");return el;};//set ajax params
Ajax.prototype.setParams=function(params,update){if(update){this.params=this.params||{};for(var key in params){this.params[key]=params[key];}}else{this.params=params;}};Ajax.prototype.getParams=function(){return this.params||{};};//load config object
Ajax.prototype.setConfig=function(config){this._loadDefaultConfig();if(typeof config=="string"){this.config.method=config;}else{for(var key in config){this.config[key]=config[key];}}};//create config object from default
Ajax.prototype._loadDefaultConfig=function(force){var self=this;if(!self.config||force){self.config={};//load base config from defaults
for(var key in self.defaultConfig){self.config[key]=self.defaultConfig[key];}}};//set request url
Ajax.prototype.setUrl=function(url){this.url=url;};//get request url
Ajax.prototype.getUrl=function(){return this.url;};//lstandard loading function
Ajax.prototype.loadData=function(inPosition){var self=this;if(this.progressiveLoad){return this._loadDataProgressive();}else{return this._loadDataStandard(inPosition);}};Ajax.prototype.nextPage=function(diff){var margin;if(!this.loading){margin=this.table.options.ajaxProgressiveLoadScrollMargin||this.table.rowManager.getElement().clientHeight*2;if(diff<margin){this.table.modules.page.nextPage().then(function(){}).catch(function(){});}}};Ajax.prototype.blockActiveRequest=function(){this.requestOrder++;};Ajax.prototype._loadDataProgressive=function(){this.table.rowManager.setData([]);return this.table.modules.page.setPage(1);};Ajax.prototype._loadDataStandard=function(inPosition){var _this19=this;return new Promise(function(resolve,reject){_this19.sendRequest(inPosition).then(function(data){_this19.table.rowManager.setData(data,inPosition).then(function(){resolve();}).catch(function(e){reject(e);});}).catch(function(e){reject(e);});});};Ajax.prototype.generateParamsList=function(data,prefix){var self=this,output=[];prefix=prefix||"";if(Array.isArray(data)){data.forEach(function(item,i){output=output.concat(self.generateParamsList(item,prefix?prefix+"["+i+"]":i));});}else if((typeof data==='undefined'?'undefined':_typeof(data))==="object"){for(var key in data){output=output.concat(self.generateParamsList(data[key],prefix?prefix+"["+key+"]":key));}}else{output.push({key:prefix,value:data});}return output;};Ajax.prototype.serializeParams=function(params){var output=this.generateParamsList(params),encoded=[];output.forEach(function(item){encoded.push(encodeURIComponent(item.key)+"="+encodeURIComponent(item.value));});return encoded.join("&");};//send ajax request
Ajax.prototype.sendRequest=function(silent){var _this20=this;var self=this,url=self.url,requestNo,esc,query;self.requestOrder++;requestNo=self.requestOrder;self._loadDefaultConfig();return new Promise(function(resolve,reject){if(self.table.options.ajaxRequesting.call(_this20.table,self.url,self.params)!==false){self.loading=true;if(!silent){self.showLoader();}_this20.loaderPromise(url,self.config,self.params).then(function(data){if(requestNo===self.requestOrder){if(self.table.options.ajaxResponse){data=self.table.options.ajaxResponse.call(self.table,self.url,self.params,data);}resolve(data);}else{console.warn("Ajax Response Blocked - An active ajax request was blocked by an attempt to change table data while the request was being made");}self.hideLoader();self.loading=false;}).catch(function(error){console.error("Ajax Load Error: ",error);self.table.options.ajaxError.call(self.table,error);self.showError();setTimeout(function(){self.hideLoader();},3000);self.loading=false;reject();});}else{reject();}});};Ajax.prototype.showLoader=function(){var shouldLoad=typeof this.table.options.ajaxLoader==="function"?this.table.options.ajaxLoader():this.table.options.ajaxLoader;if(shouldLoad){this.hideLoader();while(this.msgElement.firstChild){this.msgElement.removeChild(this.msgElement.firstChild);}this.msgElement.classList.remove("tabulator-error");this.msgElement.classList.add("tabulator-loading");if(this.loadingElement){this.msgElement.appendChild(this.loadingElement);}else{this.msgElement.innerHTML=this.table.modules.localize.getText("ajax|loading");}this.table.element.appendChild(this.loaderElement);}};Ajax.prototype.showError=function(){this.hideLoader();while(this.msgElement.firstChild){this.msgElement.removeChild(this.msgElement.firstChild);}this.msgElement.classList.remove("tabulator-loading");this.msgElement.classList.add("tabulator-error");if(this.errorElement){this.msgElement.appendChild(this.errorElement);}else{this.msgElement.innerHTML=this.table.modules.localize.getText("ajax|error");}this.table.element.appendChild(this.loaderElement);};Ajax.prototype.hideLoader=function(){if(this.loaderElement.parentNode){this.loaderElement.parentNode.removeChild(this.loaderElement);}};//default ajax config object
Ajax.prototype.defaultConfig={method:"GET"};Ajax.prototype.defaultURLGenerator=function(url,config,params){if(url){if(params&&Object.keys(params).length){if(!config.method||config.method.toLowerCase()=="get"){config.method="get";url+="?"+this.serializeParams(params);}}}return url;};Ajax.prototype.defaultLoaderPromise=function(url,config,params){var self=this,contentType;return new Promise(function(resolve,reject){//set url
url=self.urlGenerator(url,config,params);//set body content if not GET request
if(config.method.toUpperCase()!="GET"){contentType=_typeof(self.table.options.ajaxContentType)==="object"?self.table.options.ajaxContentType:self.contentTypeFormatters[self.table.options.ajaxContentType];if(contentType){for(var key in contentType.headers){if(!config.headers){config.headers={};}if(typeof config.headers[key]==="undefined"){config.headers[key]=contentType.headers[key];}}config.body=contentType.body.call(self,url,config,params);}else{console.warn("Ajax Error - Invalid ajaxContentType value:",self.table.options.ajaxContentType);}}if(url){//configure headers
if(typeof config.headers==="undefined"){config.headers={};}if(typeof config.headers.Accept==="undefined"){config.headers.Accept="application/json";}if(typeof config.headers["X-Requested-With"]==="undefined"){config.headers["X-Requested-With"]="XMLHttpRequest";}if(typeof config.mode==="undefined"){config.mode="cors";}if(config.mode=="cors"){if(typeof config.headers["Access-Control-Allow-Origin"]==="undefined"){config.headers["Access-Control-Allow-Origin"]=window.location.origin;}if(typeof config.credentials==="undefined"){config.credentials='same-origin';}}else{if(typeof config.credentials==="undefined"){config.credentials='include';}}//send request
fetch(url,config).then(function(response){if(response.ok){response.json().then(function(data){resolve(data);}).catch(function(error){reject(error);console.warn("Ajax Load Error - Invalid JSON returned",error);});}else{console.error("Ajax Load Error - Connection Error: "+response.status,response.statusText);reject(response);}}).catch(function(error){console.error("Ajax Load Error - Connection Error: ",error);reject(error);});}else{console.warn("Ajax Load Error - No URL Set");resolve([]);}});};Ajax.prototype.contentTypeFormatters={"json":{headers:{'Content-Type':'application/json'},body:function body(url,config,params){return JSON.stringify(params);}},"form":{headers:{},body:function body(url,config,params){var output=this.generateParamsList(params),form=new FormData();output.forEach(function(item){form.append(item.key,item.value);});return form;}}};Tabulator.prototype.registerModule("ajax",Ajax);var ColumnCalcs=function ColumnCalcs(table){this.table=table;//hold Tabulator object
this.topCalcs=[];this.botCalcs=[];this.genColumn=false;this.topElement=this.createElement();this.botElement=this.createElement();this.topRow=false;this.botRow=false;this.topInitialized=false;this.botInitialized=false;this.initialize();};ColumnCalcs.prototype.createElement=function(){var el=document.createElement("div");el.classList.add("tabulator-calcs-holder");return el;};ColumnCalcs.prototype.initialize=function(){this.genColumn=new Column({field:"value"},this);};//dummy functions to handle being mock column manager
ColumnCalcs.prototype.registerColumnField=function(){};//initialize column calcs
ColumnCalcs.prototype.initializeColumn=function(column){var def=column.definition;var config={topCalcParams:def.topCalcParams||{},botCalcParams:def.bottomCalcParams||{}};if(def.topCalc){switch(_typeof(def.topCalc)){case"string":if(this.calculations[def.topCalc]){config.topCalc=this.calculations[def.topCalc];}else{console.warn("Column Calc Error - No such calculation found, ignoring: ",def.topCalc);}break;case"function":config.topCalc=def.topCalc;break;}if(config.topCalc){column.modules.columnCalcs=config;this.topCalcs.push(column);if(this.table.options.columnCalcs!="group"){this.initializeTopRow();}}}if(def.bottomCalc){switch(_typeof(def.bottomCalc)){case"string":if(this.calculations[def.bottomCalc]){config.botCalc=this.calculations[def.bottomCalc];}else{console.warn("Column Calc Error - No such calculation found, ignoring: ",def.bottomCalc);}break;case"function":config.botCalc=def.bottomCalc;break;}if(config.botCalc){column.modules.columnCalcs=config;this.botCalcs.push(column);if(this.table.options.columnCalcs!="group"){this.initializeBottomRow();}}}};ColumnCalcs.prototype.removeCalcs=function(){var changed=false;if(this.topInitialized){this.topInitialized=false;this.topElement.parentNode.removeChild(this.topElement);changed=true;}if(this.botInitialized){this.botInitialized=false;this.table.footerManager.remove(this.botElement);changed=true;}if(changed){this.table.rowManager.adjustTableSize();}};ColumnCalcs.prototype.initializeTopRow=function(){if(!this.topInitialized){// this.table.columnManager.headersElement.after(this.topElement);
this.table.columnManager.getElement().insertBefore(this.topElement,this.table.columnManager.headersElement.nextSibling);this.topInitialized=true;}};ColumnCalcs.prototype.initializeBottomRow=function(){if(!this.botInitialized){this.table.footerManager.prepend(this.botElement);this.botInitialized=true;}};ColumnCalcs.prototype.scrollHorizontal=function(left){var hozAdjust=0,scrollWidth=this.table.columnManager.getElement().scrollWidth-this.table.element.clientWidth;if(this.botInitialized){this.botRow.getElement().style.marginLeft=-left+"px";}};ColumnCalcs.prototype.recalc=function(rows){var data,row;if(this.topInitialized||this.botInitialized){data=this.rowsToData(rows);if(this.topInitialized){row=this.generateRow("top",this.rowsToData(rows));this.topRow=row;while(this.topElement.firstChild){this.topElement.removeChild(this.topElement.firstChild);}this.topElement.appendChild(row.getElement());row.initialize(true);}if(this.botInitialized){row=this.generateRow("bottom",this.rowsToData(rows));this.botRow=row;while(this.botElement.firstChild){this.botElement.removeChild(this.botElement.firstChild);}this.botElement.appendChild(row.getElement());row.initialize(true);}this.table.rowManager.adjustTableSize();//set resizable handles
if(this.table.modExists("frozenColumns")){this.table.modules.frozenColumns.layout();}}};ColumnCalcs.prototype.recalcRowGroup=function(row){this.recalcGroup(this.table.modules.groupRows.getRowGroup(row));};ColumnCalcs.prototype.recalcGroup=function(group){var data,rowData;if(group){if(group.calcs){if(group.calcs.bottom){data=this.rowsToData(group.rows);rowData=this.generateRowData("bottom",data);group.calcs.bottom.updateData(rowData);group.calcs.bottom.reinitialize();}if(group.calcs.top){data=this.rowsToData(group.rows);rowData=this.generateRowData("top",data);group.calcs.top.updateData(rowData);group.calcs.top.reinitialize();}}}};//generate top stats row
ColumnCalcs.prototype.generateTopRow=function(rows){return this.generateRow("top",this.rowsToData(rows));};//generate bottom stats row
ColumnCalcs.prototype.generateBottomRow=function(rows){return this.generateRow("bottom",this.rowsToData(rows));};ColumnCalcs.prototype.rowsToData=function(rows){var data=[];rows.forEach(function(row){data.push(row.getData());});return data;};//generate stats row
ColumnCalcs.prototype.generateRow=function(pos,data){var self=this,rowData=this.generateRowData(pos,data),row;if(self.table.modExists("mutator")){self.table.modules.mutator.disable();}row=new Row(rowData,this);if(self.table.modExists("mutator")){self.table.modules.mutator.enable();}row.getElement().classList.add("tabulator-calcs","tabulator-calcs-"+pos);row.type="calc";row.generateCells=function(){var cells=[];self.table.columnManager.columnsByIndex.forEach(function(column){if(column.visible){//set field name of mock column
self.genColumn.setField(column.getField());self.genColumn.hozAlign=column.hozAlign;if(column.definition[pos+"CalcFormatter"]&&self.table.modExists("format")){self.genColumn.modules.format={formatter:self.table.modules.format.getFormatter(column.definition[pos+"CalcFormatter"]),params:column.definition[pos+"CalcFormatterParams"]};}else{self.genColumn.modules.format={formatter:self.table.modules.format.getFormatter("plaintext"),params:{}};}//ensure css class defintion is replicated to calculation cell
self.genColumn.definition.cssClass=column.definition.cssClass;//generate cell and assign to correct column
var cell=new Cell(self.genColumn,row);cell.column=column;cell.setWidth();column.cells.push(cell);cells.push(cell);}});this.cells=cells;};return row;};//generate stats row
ColumnCalcs.prototype.generateRowData=function(pos,data){var rowData={},calcs=pos=="top"?this.topCalcs:this.botCalcs,type=pos=="top"?"topCalc":"botCalc",params,paramKey;calcs.forEach(function(column){var values=[];if(column.modules.columnCalcs&&column.modules.columnCalcs[type]){data.forEach(function(item){values.push(column.getFieldValue(item));});paramKey=type+"Params";params=typeof column.modules.columnCalcs[paramKey]==="function"?column.modules.columnCalcs[paramKey](value,data):column.modules.columnCalcs[paramKey];column.setFieldValue(rowData,column.modules.columnCalcs[type](values,data,params));}});return rowData;};ColumnCalcs.prototype.hasTopCalcs=function(){return!!this.topCalcs.length;},ColumnCalcs.prototype.hasBottomCalcs=function(){return!!this.botCalcs.length;},//handle table redraw
ColumnCalcs.prototype.redraw=function(){if(this.topRow){this.topRow.normalizeHeight(true);}if(this.botRow){this.botRow.normalizeHeight(true);}};//return the calculated
ColumnCalcs.prototype.getResults=function(){var self=this,results={},groups;if(this.table.options.groupBy&&this.table.modExists("groupRows")){groups=this.table.modules.groupRows.getGroups(true);groups.forEach(function(group){results[group.getKey()]=self.getGroupResults(group);});}else{results={top:this.topRow?this.topRow.getData():{},bottom:this.botRow?this.botRow.getData():{}};}return results;};//get results from a group
ColumnCalcs.prototype.getGroupResults=function(group){var self=this,groupObj=group._getSelf(),subGroups=group.getSubGroups(),subGroupResults={},results={};subGroups.forEach(function(subgroup){subGroupResults[subgroup.getKey()]=self.getGroupResults(subgroup);});results={top:groupObj.calcs.top?groupObj.calcs.top.getData():{},bottom:groupObj.calcs.bottom?groupObj.calcs.bottom.getData():{},groups:subGroupResults};return results;};//default calculations
ColumnCalcs.prototype.calculations={"avg":function avg(values,data,calcParams){var output=0,precision=typeof calcParams.precision!=="undefined"?calcParams.precision:2;if(values.length){output=values.reduce(function(sum,value){value=Number(value);return sum+value;});output=output/values.length;output=precision!==false?output.toFixed(precision):output;}return parseFloat(output).toString();},"max":function max(values,data,calcParams){var output=null,precision=typeof calcParams.precision!=="undefined"?calcParams.precision:false;values.forEach(function(value){value=Number(value);if(value>output||output===null){output=value;}});return output!==null?precision!==false?output.toFixed(precision):output:"";},"min":function min(values,data,calcParams){var output=null,precision=typeof calcParams.precision!=="undefined"?calcParams.precision:false;values.forEach(function(value){value=Number(value);if(value<output||output===null){output=value;}});return output!==null?precision!==false?output.toFixed(precision):output:"";},"sum":function sum(values,data,calcParams){var output=0,precision=typeof calcParams.precision!=="undefined"?calcParams.precision:false;if(values.length){values.forEach(function(value){value=Number(value);output+=!isNaN(value)?Number(value):0;});}return precision!==false?output.toFixed(precision):output;},"concat":function concat(values,data,calcParams){var output=0;if(values.length){output=values.reduce(function(sum,value){return String(sum)+String(value);});}return output;},"count":function count(values,data,calcParams){var output=0;if(values.length){values.forEach(function(value){if(value){output++;}});}return output;}};Tabulator.prototype.registerModule("columnCalcs",ColumnCalcs);var Clipboard=function Clipboard(table){this.table=table;this.mode=true;this.copySelector=false;this.copySelectorParams={};this.copyFormatter=false;this.copyFormatterParams={};this.pasteParser=function(){};this.pasteAction=function(){};this.htmlElement=false;this.config={};this.blocked=true;//block copy actions not originating from this command
};Clipboard.prototype.initialize=function(){var self=this;this.mode=this.table.options.clipboard;if(this.mode===true||this.mode==="copy"){this.table.element.addEventListener("copy",function(e){var data;self.processConfig();if(!self.blocked){e.preventDefault();data=self.generateContent();if(window.clipboardData&&window.clipboardData.setData){window.clipboardData.setData('Text',data);}else if(e.clipboardData&&e.clipboardData.setData){e.clipboardData.setData('text/plain',data);if(self.htmlElement){e.clipboardData.setData('text/html',self.htmlElement.outerHTML);}}else if(e.originalEvent&&e.originalEvent.clipboardData.setData){e.originalEvent.clipboardData.setData('text/plain',data);if(self.htmlElement){e.originalEvent.clipboardData.setData('text/html',self.htmlElement.outerHTML);}}self.table.options.clipboardCopied.call(this.table,data);self.reset();}});}if(this.mode===true||this.mode==="paste"){this.table.element.addEventListener("paste",function(e){self.paste(e);});}this.setPasteParser(this.table.options.clipboardPasteParser);this.setPasteAction(this.table.options.clipboardPasteAction);};Clipboard.prototype.processConfig=function(){var config={columnHeaders:"groups",rowGroups:true,columnCalcs:true};if(typeof this.table.options.clipboardCopyHeader!=="undefined"){config.columnHeaders=this.table.options.clipboardCopyHeader;console.warn("DEPRECATION WANRING - clipboardCopyHeader option has been depricated, please use the columnHeaders property on the clipboardCopyConfig option");}if(this.table.options.clipboardCopyConfig){for(var key in this.table.options.clipboardCopyConfig){config[key]=this.table.options.clipboardCopyConfig[key];}}if(config.rowGroups&&this.table.options.groupBy&&this.table.modExists("groupRows")){this.config.rowGroups=true;}if(config.columnHeaders){if((config.columnHeaders==="groups"||config===true)&&this.table.columnManager.columns.length!=this.table.columnManager.columnsByIndex.length){this.config.columnHeaders="groups";}else{this.config.columnHeaders="columns";}}else{this.config.columnHeaders=false;}if(config.columnCalcs&&this.table.modExists("columnCalcs")){this.config.columnCalcs=true;}};Clipboard.prototype.reset=function(){this.blocked=false;this.originalSelectionText="";};Clipboard.prototype.setPasteAction=function(action){switch(typeof action==='undefined'?'undefined':_typeof(action)){case"string":this.pasteAction=this.pasteActions[action];if(!this.pasteAction){console.warn("Clipboard Error - No such paste action found:",action);}break;case"function":this.pasteAction=action;break;}};Clipboard.prototype.setPasteParser=function(parser){switch(typeof parser==='undefined'?'undefined':_typeof(parser)){case"string":this.pasteParser=this.pasteParsers[parser];if(!this.pasteParser){console.warn("Clipboard Error - No such paste parser found:",parser);}break;case"function":this.pasteParser=parser;break;}};Clipboard.prototype.paste=function(e){var data,rowData,rows;if(this.checkPaseOrigin(e)){data=this.getPasteData(e);rowData=this.pasteParser.call(this,data);if(rowData){e.preventDefault();if(this.table.modExists("mutator")){rowData=this.mutateData(rowData);}rows=this.pasteAction.call(this,rowData);this.table.options.clipboardPasted.call(this.table,data,rowData,rows);}else{this.table.options.clipboardPasteError.call(this.table,data);}}};Clipboard.prototype.mutateData=function(data){var self=this,output=[];if(Array.isArray(data)){data.forEach(function(row){output.push(self.table.modules.mutator.transformRow(row,"clipboard"));});}else{output=data;}return output;};Clipboard.prototype.checkPaseOrigin=function(e){var valid=true;if(e.target.tagName!="DIV"||this.table.modules.edit.currentCell){valid=false;}return valid;};Clipboard.prototype.getPasteData=function(e){var data;if(window.clipboardData&&window.clipboardData.getData){data=window.clipboardData.getData('Text');}else if(e.clipboardData&&e.clipboardData.getData){data=e.clipboardData.getData('text/plain');}else if(e.originalEvent&&e.originalEvent.clipboardData.getData){data=e.originalEvent.clipboardData.getData('text/plain');}return data;};Clipboard.prototype.copy=function(selector,selectorParams,formatter,formatterParams,internal){var range,sel;this.blocked=false;if(this.mode===true||this.mode==="copy"){if(typeof window.getSelection!="undefined"&&typeof document.createRange!="undefined"){range=document.createRange();range.selectNodeContents(this.table.element);sel=window.getSelection();if(sel.toString()&&internal){selector="userSelection";formatter="raw";selectorParams=sel.toString();}sel.removeAllRanges();sel.addRange(range);}else if(typeof document.selection!="undefined"&&typeof document.body.createTextRange!="undefined"){textRange=document.body.createTextRange();textRange.moveToElementText(this.table.element);textRange.select();}this.setSelector(selector);this.copySelectorParams=typeof selectorParams!="undefined"&&selectorParams!=null?selectorParams:this.config.columnHeaders;this.setFormatter(formatter);this.copyFormatterParams=typeof formatterParams!="undefined"&&formatterParams!=null?formatterParams:{};document.execCommand('copy');if(sel){sel.removeAllRanges();}}};Clipboard.prototype.setSelector=function(selector){selector=selector||this.table.options.clipboardCopySelector;switch(typeof selector==='undefined'?'undefined':_typeof(selector)){case"string":if(this.copySelectors[selector]){this.copySelector=this.copySelectors[selector];}else{console.warn("Clipboard Error - No such selector found:",selector);}break;case"function":this.copySelector=selector;break;}};Clipboard.prototype.setFormatter=function(formatter){formatter=formatter||this.table.options.clipboardCopyFormatter;switch(typeof formatter==='undefined'?'undefined':_typeof(formatter)){case"string":if(this.copyFormatters[formatter]){this.copyFormatter=this.copyFormatters[formatter];}else{console.warn("Clipboard Error - No such formatter found:",formatter);}break;case"function":this.copyFormatter=formatter;break;}};Clipboard.prototype.generateContent=function(){var data;this.htmlElement=false;data=this.copySelector.call(this,this.config,this.copySelectorParams);return this.copyFormatter.call(this,data,this.config,this.copyFormatterParams);};Clipboard.prototype.generateSimpleHeaders=function(columns){var headers=[];columns.forEach(function(column){headers.push(column.definition.title);});return headers;};Clipboard.prototype.generateColumnGroupHeaders=function(columns){var _this21=this;var output=[];this.table.columnManager.columns.forEach(function(column){var colData=_this21.processColumnGroup(column);if(colData){output.push(colData);}});return output;};Clipboard.prototype.processColumnGroup=function(column){var _this22=this;var subGroups=column.columns;var groupData={type:"group",title:column.definition.title,column:column};if(subGroups.length){groupData.subGroups=[];groupData.width=0;subGroups.forEach(function(subGroup){var subGroupData=_this22.processColumnGroup(subGroup);if(subGroupData){groupData.width+=subGroupData.width;groupData.subGroups.push(subGroupData);}});if(!groupData.width){return false;}}else{if(column.field&&column.visible){groupData.width=1;}else{return false;}}return groupData;};Clipboard.prototype.groupHeadersToRows=function(columns){var headers=[];function parseColumnGroup(column,level){if(typeof headers[level]==="undefined"){headers[level]=[];}headers[level].push(column.title);if(column.subGroups){column.subGroups.forEach(function(subGroup){parseColumnGroup(subGroup,level+1);});}else{padColumnheaders();}}function padColumnheaders(){var max=0;headers.forEach(function(title){var len=title.length;if(len>max){max=len;}});headers.forEach(function(title){var len=title.length;if(len<max){for(var i=len;i<max;i++){title.push("");}}});}columns.forEach(function(column){parseColumnGroup(column,0);});return headers;};Clipboard.prototype.rowsToData=function(rows,config,params){var columns=this.table.columnManager.columnsByIndex,data=[];rows.forEach(function(row){var rowArray=[],rowData=row instanceof RowComponent?row.getData("clipboard"):row;columns.forEach(function(column){var value=column.getFieldValue(rowData);switch(typeof value==='undefined'?'undefined':_typeof(value)){case"object":value=JSON.stringify(value);break;case"undefined":case"null":value="";break;default:value=value;}rowArray.push(value);});data.push(rowArray);});return data;};Clipboard.prototype.buildComplexRows=function(config){var _this23=this;var output=[],groups=this.table.modules.groupRows.getGroups();groups.forEach(function(group){output.push(_this23.processGroupData(group));});return output;};Clipboard.prototype.processGroupData=function(group){var _this24=this;var subGroups=group.getSubGroups();var groupData={type:"group",key:group.key};if(subGroups.length){groupData.subGroups=[];subGroups.forEach(function(subGroup){groupData.subGroups.push(_this24.processGroupData(subGroup));});}else{groupData.rows=group.getRows(true);}return groupData;};Clipboard.prototype.getCalcRow=function(calcs,selector,pos){var calcData=calcs[selector];if(calcData){if(pos){calcData=calcData[pos];}if(Object.keys(calcData).length){return this.rowsToData([calcData]);}}return[];};Clipboard.prototype.buildOutput=function(rows,config,params){var _this25=this;var output=[],calcs,columns=this.table.columnManager.columnsByIndex;if(config.columnHeaders){if(config.columnHeaders=="groups"){columns=this.generateColumnGroupHeaders(this.table.columnManager.columns);output=output.concat(this.groupHeadersToRows(columns));}else{output.push(this.generateSimpleHeaders(columns));}}if(this.config.columnCalcs){calcs=this.table.getCalcResults();}//generate styled content
if(this.table.options.clipboardCopyStyled){this.generateHTML(rows,columns,calcs,config,params);}//generate unstyled content
if(config.rowGroups){rows.forEach(function(row){output=output.concat(_this25.parseRowGroupData(row,config,params,calcs||{}));});}else{if(config.columnCalcs){output=output.concat(this.getCalcRow(calcs,"top"));}output=output.concat(this.rowsToData(rows,config,params));if(config.columnCalcs){output=output.concat(this.getCalcRow(calcs,"bottom"));}}return output;};Clipboard.prototype.parseRowGroupData=function(group,config,params,calcObj){var _this26=this;var groupData=[];groupData.push([group.key]);if(group.subGroups){group.subGroups.forEach(function(subGroup){groupData=groupData.concat(_this26.parseRowGroupData(subGroup,config,params,calcObj[group.key]?calcObj[group.key].groups||{}:{}));});}else{if(config.columnCalcs){groupData=groupData.concat(this.getCalcRow(calcObj,group.key,"top"));}groupData=groupData.concat(this.rowsToData(group.rows,config,params));if(config.columnCalcs){groupData=groupData.concat(this.getCalcRow(calcObj,group.key,"bottom"));}}return groupData;};Clipboard.prototype.generateHTML=function(rows,columns,calcs,config,params){var self=this,data=[],headers=[],body,oddRow,evenRow,calcRow,firstRow,firstCell,firstGroup,lastCell,styleCells;//create table element
this.htmlElement=document.createElement("table");self.mapElementStyles(this.table.element,this.htmlElement,["border-top","border-left","border-right","border-bottom"]);function generateSimpleHeaders(){var headerEl=document.createElement("tr");columns.forEach(function(column){var columnEl=document.createElement("th");columnEl.innerHTML=column.definition.title;self.mapElementStyles(column.getElement(),columnEl,["border-top","border-left","border-right","border-bottom","background-color","color","font-weight","font-family","font-size"]);headerEl.appendChild(columnEl);});self.mapElementStyles(self.table.columnManager.getHeadersElement(),headerEl,["border-top","border-left","border-right","border-bottom","background-color","color","font-weight","font-family","font-size"]);self.htmlElement.appendChild(document.createElement("thead").appendChild(headerEl));}function generateHeaders(headers){var headerHolderEl=document.createElement("thead");headers.forEach(function(columns){var headerEl=document.createElement("tr");columns.forEach(function(column){var columnEl=document.createElement("th");if(column.width>1){columnEl.colSpan=column.width;}if(column.height>1){columnEl.rowSpan=column.height;}columnEl.innerHTML=column.title;self.mapElementStyles(column.element,columnEl,["border-top","border-left","border-right","border-bottom","background-color","color","font-weight","font-family","font-size"]);headerEl.appendChild(columnEl);});self.mapElementStyles(self.table.columnManager.getHeadersElement(),headerEl,["border-top","border-left","border-right","border-bottom","background-color","color","font-weight","font-family","font-size"]);headerHolderEl.appendChild(headerEl);});self.htmlElement.appendChild(headerHolderEl);}function parseColumnGroup(column,level){if(typeof headers[level]==="undefined"){headers[level]=[];}headers[level].push({title:column.title,width:column.width,height:1,children:!!column.subGroups,element:column.column.getElement()});if(column.subGroups){column.subGroups.forEach(function(subGroup){parseColumnGroup(subGroup,level+1);});}}function padVerticalColumnheaders(){headers.forEach(function(row,index){row.forEach(function(header){if(!header.children){header.height=headers.length-index;}});});}function addCalcRow(calcs,selector,pos){var calcData=calcs[selector];if(calcData){if(pos){calcData=calcData[pos];}if(Object.keys(calcData).length){// calcRowIndexs.push(body.length);
processRows([calcData]);}}}//create headers if needed
if(config.columnHeaders){if(config.columnHeaders=="groups"){columns.forEach(function(column){parseColumnGroup(column,0);});padVerticalColumnheaders();generateHeaders(headers);}else{generateSimpleHeaders();}}columns=this.table.columnManager.columnsByIndex;//create table body
body=document.createElement("tbody");//lookup row styles
if(window.getComputedStyle){oddRow=this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");evenRow=this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");calcRow=this.table.element.querySelector(".tabulator-row.tabulator-calcs");firstRow=this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");firstGroup=this.table.element.getElementsByClassName("tabulator-group")[0];if(firstRow){styleCells=firstRow.getElementsByClassName("tabulator-cell");firstCell=styleCells[0];lastCell=styleCells[styleCells.length-1];}}function processRows(rowArray){//add rows to table
rowArray.forEach(function(row,i){var rowEl=document.createElement("tr"),styleRow=firstRow,isCalc=false,rowData;if(row instanceof RowComponent){rowData=row.getData("clipboard");}else{rowData=row;isCalc=true;}columns.forEach(function(column,j){var cellEl=document.createElement("td"),value=column.getFieldValue(rowData);switch(typeof value==='undefined'?'undefined':_typeof(value)){case"object":value=JSON.stringify(value);break;case"undefined":case"null":value="";break;default:value=value;}cellEl.innerHTML=value;if(column.definition.align){cellEl.style.textAlign=column.definition.align;}if(j<columns.length-1){if(firstCell){self.mapElementStyles(firstCell,cellEl,["border-top","border-left","border-right","border-bottom","color","font-weight","font-family","font-size"]);}}else{if(firstCell){self.mapElementStyles(firstCell,cellEl,["border-top","border-left","border-right","border-bottom","color","font-weight","font-family","font-size"]);}}rowEl.appendChild(cellEl);});if(isCalc){styleRow=calcRow;}else{if(!(i%2)&&oddRow){styleRow=oddRow;}if(i%2&&evenRow){styleRow=evenRow;}}if(styleRow){self.mapElementStyles(styleRow,rowEl,["border-top","border-left","border-right","border-bottom","color","font-weight","font-family","font-size","background-color"]);}body.appendChild(rowEl);});}function processGroup(group,calcObj){var groupEl=document.createElement("tr"),groupCellEl=document.createElement("td");groupCellEl.colSpan=columns.length;groupCellEl.innerHTML=group.key;groupEl.appendChild(groupCellEl);body.appendChild(groupEl);self.mapElementStyles(firstGroup,groupEl,["border-top","border-left","border-right","border-bottom","color","font-weight","font-family","font-size","background-color"]);if(group.subGroups){group.subGroups.forEach(function(subGroup){processGroup(subGroup,calcObj[group.key]?calcObj[group.key].groups||{}:{});});}else{if(config.columnCalcs){addCalcRow(calcObj,group.key,"top");}processRows(group.rows);if(config.columnCalcs){addCalcRow(calcObj,group.key,"bottom");}}}if(config.rowGroups){rows.forEach(function(group){processGroup(group,calcs||{});});}else{if(config.columnCalcs){addCalcRow(calcs,"top");}processRows(rows);if(config.columnCalcs){addCalcRow(calcs,"bottom");}}this.htmlElement.appendChild(body);};Clipboard.prototype.mapElementStyles=function(from,to,props){var lookup={"background-color":"backgroundColor","color":"fontColor","font-weight":"fontWeight","font-family":"fontFamily","font-size":"fontSize","border-top":"borderTop","border-left":"borderLeft","border-right":"borderRight","border-bottom":"borderBottom"};if(window.getComputedStyle){var fromStyle=window.getComputedStyle(from);props.forEach(function(prop){to.style[lookup[prop]]=fromStyle.getPropertyValue(prop);});}// return window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue(property) : element.style[property.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); })];
};Clipboard.prototype.copySelectors={userSelection:function userSelection(config,params){return params;},selected:function selected(config,params){var rows=[];if(this.table.modExists("selectRow",true)){rows=this.table.modules.selectRow.getSelectedRows();}if(config.rowGroups){console.warn("Clipboard Warning - select coptSelector does not support row groups");}return this.buildOutput(rows,config,params);},table:function table(config,params){if(config.rowGroups){console.warn("Clipboard Warning - table coptSelector does not support row groups");}return this.buildOutput(this.table.rowManager.getComponents(),config,params);},active:function active(config,params){var rows;if(config.rowGroups){rows=this.buildComplexRows(config);}else{rows=this.table.rowManager.getComponents(true);}return this.buildOutput(rows,config,params);}};Clipboard.prototype.copyFormatters={raw:function raw(data,params){return data;},table:function table(data,params){var output=[];data.forEach(function(row){row.forEach(function(value){if(typeof value=="undefined"){value="";}value=typeof value=="undefined"||value===null?"":value.toString();if(value.match(/\r|\n/)){value=value.split('"').join('""');value='"'+value+'"';}});output.push(row.join("\t"));});return output.join("\n");}};Clipboard.prototype.pasteParsers={table:function table(clipboard){var data=[],success=false,headerFindSuccess=true,columns=this.table.columnManager.columns,columnMap=[],rows=[];//get data from clipboard into array of columns and rows.
clipboard=clipboard.split("\n");clipboard.forEach(function(row){data.push(row.split("\t"));});if(data.length&&!(data.length===1&&data[0].length<2)){success=true;//check if headers are present by title
data[0].forEach(function(value){var column=columns.find(function(column){return value&&column.definition.title&&value.trim()&&column.definition.title.trim()===value.trim();});if(column){columnMap.push(column);}else{headerFindSuccess=false;}});//check if column headers are present by field
if(!headerFindSuccess){headerFindSuccess=true;columnMap=[];data[0].forEach(function(value){var column=columns.find(function(column){return value&&column.field&&value.trim()&&column.field.trim()===value.trim();});if(column){columnMap.push(column);}else{headerFindSuccess=false;}});if(!headerFindSuccess){columnMap=this.table.columnManager.columnsByIndex;}}//remove header row if found
if(headerFindSuccess){data.shift();}data.forEach(function(item){var row={};item.forEach(function(value,i){if(columnMap[i]){row[columnMap[i].field]=value;}});rows.push(row);});return rows;}else{return false;}}};Clipboard.prototype.pasteActions={replace:function replace(rows){return this.table.setData(rows);},update:function update(rows){return this.table.updateOrAddData(rows);},insert:function insert(rows){return this.table.addData(rows);}};Tabulator.prototype.registerModule("clipboard",Clipboard);var DataTree=function DataTree(table){this.table=table;this.indent=10;this.field="";this.collapseEl=null;this.expandEl=null;this.branchEl=null;this.elementField=false;this.startOpen=function(){};this.displayIndex=0;};DataTree.prototype.initialize=function(){var dummyEl=null,options=this.table.options;this.field=options.dataTreeChildField;this.indent=options.dataTreeChildIndent;this.elementField=options.dataTreeElementColumn;if(options.dataTreeBranchElement){if(options.dataTreeBranchElement===true){this.branchEl=document.createElement("div");this.branchEl.classList.add("tabulator-data-tree-branch");}else{if(typeof options.dataTreeBranchElement==="string"){dummyEl=document.createElement("div");dummyEl.innerHTML=options.dataTreeBranchElement;this.branchEl=dummyEl.firstChild;}else{this.branchEl=options.dataTreeBranchElement;}}}if(options.dataTreeCollapseElement){if(typeof options.dataTreeCollapseElement==="string"){dummyEl=document.createElement("div");dummyEl.innerHTML=options.dataTreeCollapseElement;this.collapseEl=dummyEl.firstChild;}else{this.collapseEl=options.dataTreeCollapseElement;}}else{this.collapseEl=document.createElement("div");this.collapseEl.classList.add("tabulator-data-tree-control");this.collapseEl.innerHTML="<div class='tabulator-data-tree-control-collapse'></div>";}if(options.dataTreeExpandElement){if(typeof options.dataTreeExpandElement==="string"){dummyEl=document.createElement("div");dummyEl.innerHTML=options.dataTreeExpandElement;this.expandEl=dummyEl.firstChild;}else{this.expandEl=options.dataTreeExpandElement;}}else{this.expandEl=document.createElement("div");this.expandEl.classList.add("tabulator-data-tree-control");this.expandEl.innerHTML="<div class='tabulator-data-tree-control-expand'></div>";}switch(_typeof(options.dataTreeStartExpanded)){case"boolean":this.startOpen=function(row,index){return options.dataTreeStartExpanded;};break;case"function":this.startOpen=options.dataTreeStartExpanded;break;default:this.startOpen=function(row,index){return options.dataTreeStartExpanded[index];};break;}};DataTree.prototype.initializeRow=function(row){var children=typeof row.getData()[this.field]!=="undefined";row.modules.dataTree={index:0,open:children?this.startOpen(row.getComponent(),0):false,controlEl:false,branchEl:false,parent:false,children:children};};DataTree.prototype.layoutRow=function(row){var cell=this.elementField?row.getCell(this.elementField):row.getCells()[0],el=cell.getElement(),config=row.modules.dataTree;el.style.paddingLeft=parseInt(window.getComputedStyle(el,null).getPropertyValue('padding-left'))+config.index*this.indent+"px";if(config.branchEl){config.branchEl.parentNode.removeChild(config.branchEl);}this.generateControlElement(row,el);if(config.index&&this.branchEl){config.branchEl=this.branchEl.cloneNode(true);el.insertBefore(config.branchEl,el.firstChild);el.style.paddingLeft=parseInt(el.style.paddingLeft)+(config.branchEl.offsetWidth+config.branchEl.style.marginRight)*(config.index-1)+"px";}};DataTree.prototype.generateControlElement=function(row,el){var _this27=this;var config=row.modules.dataTree,el=el||row.getCells()[0].getElement(),oldControl=config.controlEl;if(config.children!==false){if(config.open){config.controlEl=this.collapseEl.cloneNode(true);config.controlEl.addEventListener("click",function(e){e.stopPropagation();_this27.collapseRow(row);});}else{config.controlEl=this.expandEl.cloneNode(true);config.controlEl.addEventListener("click",function(e){e.stopPropagation();_this27.expandRow(row);});}config.controlEl.addEventListener("mousedown",function(e){e.stopPropagation();});if(oldControl&&oldControl.parentNode===el){oldControl.parentNode.replaceChild(config.controlEl,oldControl);}else{el.insertBefore(config.controlEl,el.firstChild);}}};DataTree.prototype.setDisplayIndex=function(index){this.displayIndex=index;};DataTree.prototype.getDisplayIndex=function(){return this.displayIndex;};DataTree.prototype.getRows=function(rows){var _this28=this;var output=[];rows.forEach(function(row,i){var config,children;output.push(row);if(row instanceof Row){config=row.modules.dataTree.children;if(!config.index&&config.children!==false){children=_this28.getChildren(row);children.forEach(function(child){output.push(child);});}}});return output;};DataTree.prototype.getChildren=function(row){var _this29=this;var config=row.modules.dataTree,children=[],output=[];if(config.children!==false&&config.open){if(!Array.isArray(config.children)){config.children=this.generateChildren(row);}if(this.table.modExists("filter")){children=this.table.modules.filter.filter(config.children);}else{children=config.children;}if(this.table.modExists("sort")){this.table.modules.sort.sort(children);}children.forEach(function(child){output.push(child);var subChildren=_this29.getChildren(child);subChildren.forEach(function(sub){output.push(sub);});});}return output;};DataTree.prototype.generateChildren=function(row){var _this30=this;var children=[];row.getData()[this.field].forEach(function(childData){var childRow=new Row(childData||{},_this30.table.rowManager);childRow.modules.dataTree.index=row.modules.dataTree.index+1;childRow.modules.dataTree.parent=row;childRow.modules.dataTree.open=_this30.startOpen(row,childRow.modules.dataTree.index);children.push(childRow);});return children;};DataTree.prototype.expandRow=function(row,silent){var config=row.modules.dataTree;if(config.children!==false){config.open=true;row.reinitialize();this.table.rowManager.refreshActiveData("tree",false,true);this.table.options.dataTreeRowExpanded(row.getComponent(),row.modules.dataTree.index);}};DataTree.prototype.collapseRow=function(row){var config=row.modules.dataTree;if(config.children!==false){config.open=false;row.reinitialize();this.table.rowManager.refreshActiveData("tree",false,true);this.table.options.dataTreeRowCollapsed(row.getComponent(),row.modules.dataTree.index);}};DataTree.prototype.toggleRow=function(row){var config=row.modules.dataTree;if(config.children!==false){if(config.open){this.collapseRow(row);}else{this.expandRow(row);}}};DataTree.prototype.getTreeParent=function(row){return row.modules.dataTree.parent?row.modules.dataTree.parent.getComponent():false;};DataTree.prototype.getTreeChildren=function(row){var config=row.modules.dataTree,output=[];if(config.children){if(!Array.isArray(config.children)){config.children=this.generateChildren(row);}config.children.forEach(function(childRow){if(childRow instanceof Row){output.push(childRow.getComponent());}});}return output;};DataTree.prototype.checkForRestyle=function(cell){if(!cell.row.cells.indexOf(cell)){if(cell.row.modules.dataTree.children!==false){cell.row.reinitialize();}}};DataTree.prototype.getChildField=function(){return this.field;};Tabulator.prototype.registerModule("dataTree",DataTree);var Download=function Download(table){this.table=table;//hold Tabulator object
this.fields={};//hold filed multi dimension arrays
this.columnsByIndex=[];//hold columns in their order in the table
this.columnsByField={};//hold columns with lookup by field name
this.config={};};//trigger file download
Download.prototype.download=function(type,filename,options,interceptCallback){var self=this,downloadFunc=false;this.processConfig();function buildLink(data,mime){if(interceptCallback){if(interceptCallback===true){self.triggerDownload(data,mime,type,filename,true);}else{interceptCallback(data);}}else{self.triggerDownload(data,mime,type,filename);}}if(typeof type=="function"){downloadFunc=type;}else{if(self.downloaders[type]){downloadFunc=self.downloaders[type];}else{console.warn("Download Error - No such download type found: ",type);}}this.processColumns();if(downloadFunc){downloadFunc.call(this,self.processDefinitions(),self.processData(),options||{},buildLink,this.config);}};Download.prototype.processConfig=function(){var config={//download config
columnGroups:true,rowGroups:true,columnCalcs:true};if(this.table.options.downloadConfig){for(var key in this.table.options.downloadConfig){config[key]=this.table.options.downloadConfig[key];}}if(config.rowGroups&&this.table.options.groupBy&&this.table.modExists("groupRows")){this.config.rowGroups=true;}if(config.columnGroups&&this.table.columnManager.columns.length!=this.table.columnManager.columnsByIndex.length){this.config.columnGroups=true;}if(config.columnCalcs&&this.table.modExists("columnCalcs")){this.config.columnCalcs=true;}};Download.prototype.processColumns=function(){var self=this;self.columnsByIndex=[];self.columnsByField={};self.table.columnManager.columnsByIndex.forEach(function(column){if(column.field&&column.definition.download!==false&&(column.visible||!column.visible&&column.definition.download)){self.columnsByIndex.push(column);self.columnsByField[column.field]=column;}});};Download.prototype.processDefinitions=function(){var self=this,processedDefinitions=[];if(this.config.columnGroups){self.table.columnManager.columns.forEach(function(column){var colData=self.processColumnGroup(column);if(colData){processedDefinitions.push(colData);}});}else{self.columnsByIndex.forEach(function(column){if(column.download!==false){//isolate definiton from defintion object
processedDefinitions.push(self.processDefinition(column));}});}return processedDefinitions;};Download.prototype.processColumnGroup=function(column){var _this31=this;var subGroups=column.columns,maxDepth=0;var groupData={type:"group",title:column.definition.title,depth:1};if(subGroups.length){groupData.subGroups=[];groupData.width=0;subGroups.forEach(function(subGroup){var subGroupData=_this31.processColumnGroup(subGroup);if(subGroupData.depth>maxDepth){maxDepth=subGroupData.depth;}if(subGroupData){groupData.width+=subGroupData.width;groupData.subGroups.push(subGroupData);}});groupData.depth+=maxDepth;if(!groupData.width){return false;}}else{if(column.field&&column.definition.download!==false&&(column.visible||!column.visible&&column.definition.download)){groupData.width=1;groupData.definition=this.processDefinition(column);}else{return false;}}return groupData;};Download.prototype.processDefinition=function(column){var def={};for(var key in column.definition){def[key]=column.definition[key];}if(typeof column.definition.downloadTitle!="undefined"){def.title=column.definition.downloadTitle;}return def;};Download.prototype.processData=function(){var _this32=this;var self=this,data=[],groups=[],calcs={};if(this.config.rowGroups){groups=this.table.modules.groupRows.getGroups();groups.forEach(function(group){data.push(_this32.processGroupData(group));});}else{data=self.table.rowManager.getData(true,"download");}if(this.config.columnCalcs){calcs=this.table.getCalcResults();data={calcs:calcs,data:data};}//bulk data processing
if(typeof self.table.options.downloadDataFormatter=="function"){data=self.table.options.downloadDataFormatter(data);}return data;};Download.prototype.processGroupData=function(group){var _this33=this;var subGroups=group.getSubGroups();var groupData={type:"group",key:group.key};if(subGroups.length){groupData.subGroups=[];subGroups.forEach(function(subGroup){groupData.subGroups.push(_this33.processGroupData(subGroup));});}else{groupData.rows=group.getData(true,"download");}return groupData;};Download.prototype.triggerDownload=function(data,mime,type,filename,newTab){var element=document.createElement('a'),blob=new Blob([data],{type:mime}),filename=filename||"Tabulator."+(typeof type==="function"?"txt":type);blob=this.table.options.downloadReady.call(this.table,data,blob);if(blob){if(newTab){window.open(window.URL.createObjectURL(blob));}else{if(navigator.msSaveOrOpenBlob){navigator.msSaveOrOpenBlob(blob,filename);}else{element.setAttribute('href',window.URL.createObjectURL(blob));//set file title
element.setAttribute('download',filename);//trigger download
element.style.display='none';document.body.appendChild(element);element.click();//remove temporary link element
document.body.removeChild(element);}}if(this.table.options.downloadComplete){this.table.options.downloadComplete();}}};//nested field lookup
Download.prototype.getFieldValue=function(field,data){var column=this.columnsByField[field];if(column){return column.getFieldValue(data);}return false;};Download.prototype.commsReceived=function(table,action,data){switch(action){case"intercept":this.download(data.type,"",data.options,data.intercept);break;}};//downloaders
Download.prototype.downloaders={csv:function csv(columns,data,options,setFileContents,config){var self=this,titles=[],fields=[],delimiter=options&&options.delimiter?options.delimiter:",",fileContents,output;//build column headers
function parseSimpleTitles(){columns.forEach(function(column){titles.push('"'+String(column.title).split('"').join('""')+'"');fields.push(column.field);});}function parseColumnGroup(column,level){if(column.subGroups){column.subGroups.forEach(function(subGroup){parseColumnGroup(subGroup,level+1);});}else{titles.push('"'+String(column.title).split('"').join('""')+'"');fields.push(column.definition.field);}}if(config.columnGroups){console.warn("Download Warning - CSV downloader cannot process column groups");columns.forEach(function(column){parseColumnGroup(column,0);});}else{parseSimpleTitles();}//generate header row
fileContents=[titles.join(delimiter)];function parseRows(data){//generate each row of the table
data.forEach(function(row){var rowData=[];fields.forEach(function(field){var value=self.getFieldValue(field,row);switch(typeof value==='undefined'?'undefined':_typeof(value)){case"object":value=JSON.stringify(value);break;case"undefined":case"null":value="";break;default:value=value;}//escape quotation marks
rowData.push('"'+String(value).split('"').join('""')+'"');});fileContents.push(rowData.join(delimiter));});}function parseGroup(group){if(group.subGroups){group.subGroups.forEach(function(subGroup){parseGroup(subGroup);});}else{parseRows(group.rows);}}if(config.columnCalcs){console.warn("Download Warning - CSV downloader cannot process column calculations");data=data.data;}if(config.rowGroups){console.warn("Download Warning - CSV downloader cannot process row groups");data.forEach(function(group){parseGroup(group);});}else{parseRows(data);}output=fileContents.join("\n");if(options.bom){output='\uFEFF'+output;}setFileContents(output,"text/csv");},json:function json(columns,data,options,setFileContents,config){var fileContents;if(config.columnCalcs){console.warn("Download Warning - CSV downloader cannot process column calculations");data=data.data;}fileContents=JSON.stringify(data,null,'\t');setFileContents(fileContents,"application/json");},pdf:function pdf(columns,data,options,setFileContents,config){var self=this,fields=[],header=[],body=[],calcs={},headerDepth=1,table="",autoTableParams={},rowGroupStyles=options.rowGroupStyles||{fontStyle:"bold",fontSize:12,cellPadding:6,fillColor:220},rowCalcStyles=options.rowCalcStyles||{fontStyle:"bold",fontSize:10,cellPadding:4,fillColor:232},jsPDFParams=options.jsPDF||{},title=options&&options.title?options.title:"";if(config.columnCalcs){calcs=data.calcs;data=data.data;}if(!jsPDFParams.orientation){jsPDFParams.orientation=options.orientation||"landscape";}if(!jsPDFParams.unit){jsPDFParams.unit="pt";}//build column headers
function parseSimpleTitles(){columns.forEach(function(column){if(column.field){header.push(column.title||"");fields.push(column.field);}});header=[header];}function parseColumnGroup(column,level){var colSpan=column.width,rowSpan=1,col={content:column.title||""};if(column.subGroups){column.subGroups.forEach(function(subGroup){parseColumnGroup(subGroup,level+1);});rowSpan=1;}else{fields.push(column.definition.field);rowSpan=headerDepth-level;}col.rowSpan=rowSpan;// col.colSpan = colSpan;
header[level].push(col);colSpan--;if(rowSpan>1){for(var i=level+1;i<headerDepth;i++){header[i].push("");}}for(var i=0;i<colSpan;i++){header[level].push("");}}if(config.columnGroups){columns.forEach(function(column){if(column.depth>headerDepth){headerDepth=column.depth;}});for(var i=0;i<headerDepth;i++){header.push([]);}columns.forEach(function(column){parseColumnGroup(column,0);});}else{parseSimpleTitles();}function parseValue(value){switch(typeof value==='undefined'?'undefined':_typeof(value)){case"object":value=JSON.stringify(value);break;case"undefined":case"null":value="";break;default:value=value;}return value;}function parseRows(data){//build table rows
data.forEach(function(row){body.push(parseRow(row));});}function parseRow(row,styles){var rowData=[];fields.forEach(function(field){var value=self.getFieldValue(field,row);value=parseValue(value);if(styles){rowData.push({content:value,styles:styles});}else{rowData.push(value);}});return rowData;}function parseGroup(group,calcObj){var groupData=[];groupData.push({content:parseValue(group.key),colSpan:fields.length,styles:rowGroupStyles});body.push(groupData);if(group.subGroups){group.subGroups.forEach(function(subGroup){parseGroup(subGroup,calcObj[group.key]?calcObj[group.key].groups||{}:{});});}else{if(config.columnCalcs){addCalcRow(calcObj,group.key,"top");}parseRows(group.rows);if(config.columnCalcs){addCalcRow(calcObj,group.key,"bottom");}}}function addCalcRow(calcs,selector,pos){var calcData=calcs[selector];if(calcData){if(pos){calcData=calcData[pos];}if(Object.keys(calcData).length){body.push(parseRow(calcData,rowCalcStyles));}}}if(config.rowGroups){data.forEach(function(group){parseGroup(group,calcs);});}else{if(config.columnCalcs){addCalcRow(calcs,"top");}parseRows(data);if(config.columnCalcs){addCalcRow(calcs,"bottom");}}var doc=new jsPDF(jsPDFParams);//set document to landscape, better for most tables
if(options&&options.autoTable){if(typeof options.autoTable==="function"){autoTableParams=options.autoTable(doc)||{};}else{autoTableParams=options.autoTable;}}if(title){autoTableParams.addPageContent=function(data){doc.text(title,40,30);};}autoTableParams.head=header;autoTableParams.body=body;doc.autoTable(autoTableParams);setFileContents(doc.output("arraybuffer"),"application/pdf");},xlsx:function xlsx(columns,data,options,setFileContents,config){var self=this,sheetName=options.sheetName||"Sheet1",workbook={SheetNames:[],Sheets:{}},calcs={},groupRowIndexs=[],groupColumnIndexs=[],calcRowIndexs=[],output;if(config.columnCalcs){calcs=data.calcs;data=data.data;}function generateSheet(){var titles=[],fields=[],rows=[],worksheet;//convert rows to worksheet
function rowsToSheet(){var sheet={};var range={s:{c:0,r:0},e:{c:fields.length,r:rows.length}};XLSX.utils.sheet_add_aoa(sheet,rows);sheet['!ref']=XLSX.utils.encode_range(range);var merges=generateMerges();if(merges.length){sheet["!merges"]=merges;}return sheet;}function parseSimpleTitles(){//get field lists
columns.forEach(function(column){titles.push(column.title);fields.push(column.field);});rows.push(titles);}function parseColumnGroup(column,level){if(typeof titles[level]==="undefined"){titles[level]=[];}if(typeof groupColumnIndexs[level]==="undefined"){groupColumnIndexs[level]=[];}if(column.width>1){groupColumnIndexs[level].push({type:"hoz",start:titles[level].length,end:titles[level].length+column.width-1});}titles[level].push(column.title);if(column.subGroups){column.subGroups.forEach(function(subGroup){parseColumnGroup(subGroup,level+1);});}else{fields.push(column.definition.field);padColumnTitles(fields.length-1,level);groupColumnIndexs[level].push({type:"vert",start:fields.length-1});}}function padColumnTitles(){var max=0;titles.forEach(function(title){var len=title.length;if(len>max){max=len;}});titles.forEach(function(title){var len=title.length;if(len<max){for(var i=len;i<max;i++){title.push("");}}});}if(config.columnGroups){columns.forEach(function(column){parseColumnGroup(column,0);});titles.forEach(function(title){rows.push(title);});}else{parseSimpleTitles();}function generateMerges(){var output=[];groupRowIndexs.forEach(function(index){output.push({s:{r:index,c:0},e:{r:index,c:fields.length-1}});});groupColumnIndexs.forEach(function(merges,level){merges.forEach(function(merge){if(merge.type==="hoz"){output.push({s:{r:level,c:merge.start},e:{r:level,c:merge.end}});}else{if(level!=titles.length-1){output.push({s:{r:level,c:merge.start},e:{r:titles.length-1,c:merge.start}});}}});});return output;}//generate each row of the table
function parseRows(data){data.forEach(function(row){rows.push(parseRow(row));});}function parseRow(row){var rowData=[];fields.forEach(function(field){var value=self.getFieldValue(field,row);rowData.push((typeof value==='undefined'?'undefined':_typeof(value))==="object"?JSON.stringify(value):value);});return rowData;}function addCalcRow(calcs,selector,pos){var calcData=calcs[selector];if(calcData){if(pos){calcData=calcData[pos];}if(Object.keys(calcData).length){calcRowIndexs.push(rows.length);rows.push(parseRow(calcData));}}}function parseGroup(group,calcObj){var groupData=[];groupData.push(group.key);groupRowIndexs.push(rows.length);rows.push(groupData);if(group.subGroups){group.subGroups.forEach(function(subGroup){parseGroup(subGroup,calcObj[group.key]?calcObj[group.key].groups||{}:{});});}else{if(config.columnCalcs){addCalcRow(calcObj,group.key,"top");}parseRows(group.rows);if(config.columnCalcs){addCalcRow(calcObj,group.key,"bottom");}}}if(config.rowGroups){data.forEach(function(group){parseGroup(group,calcs);});}else{if(config.columnCalcs){addCalcRow(calcs,"top");}parseRows(data);if(config.columnCalcs){addCalcRow(calcs,"bottom");}}worksheet=rowsToSheet();return worksheet;}if(options.sheetOnly){setFileContents(generateSheet());return;}if(options.sheets){for(var sheet in options.sheets){if(options.sheets[sheet]===true){workbook.SheetNames.push(sheet);workbook.Sheets[sheet]=generateSheet();}else{workbook.SheetNames.push(sheet);this.table.modules.comms.send(options.sheets[sheet],"download","intercept",{type:"xlsx",options:{sheetOnly:true},intercept:function intercept(data){workbook.Sheets[sheet]=data;}});}}}else{workbook.SheetNames.push(sheetName);workbook.Sheets[sheetName]=generateSheet();}//convert workbook to binary array
function s2ab(s){var buf=new ArrayBuffer(s.length);var view=new Uint8Array(buf);for(var i=0;i!=s.length;++i){view[i]=s.charCodeAt(i)&0xFF;}return buf;}output=XLSX.write(workbook,{bookType:'xlsx',bookSST:true,type:'binary'});setFileContents(s2ab(output),"application/octet-stream");}};Tabulator.prototype.registerModule("download",Download);var Edit=function Edit(table){this.table=table;//hold Tabulator object
this.currentCell=false;//hold currently editing cell
this.mouseClick=false;//hold mousedown state to prevent click binding being overriden by editor opening
this.recursionBlock=false;//prevent focus recursion
this.invalidEdit=false;};//initialize column editor
Edit.prototype.initializeColumn=function(column){var self=this,config={editor:false,blocked:false,check:column.definition.editable,params:column.definition.editorParams||{}};//set column editor
switch(_typeof(column.definition.editor)){case"string":if(column.definition.editor==="tick"){column.definition.editor="tickCross";console.warn("DEPRECATION WANRING - the tick editor has been depricated, please use the tickCross editor");}if(self.editors[column.definition.editor]){config.editor=self.editors[column.definition.editor];}else{console.warn("Editor Error - No such editor found: ",column.definition.editor);}break;case"function":config.editor=column.definition.editor;break;case"boolean":if(column.definition.editor===true){if(typeof column.definition.formatter!=="function"){if(column.definition.formatter==="tick"){column.definition.formatter="tickCross";console.warn("DEPRECATION WANRING - the tick editor has been depricated, please use the tickCross editor");}if(self.editors[column.definition.formatter]){config.editor=self.editors[column.definition.formatter];}else{config.editor=self.editors["input"];}}else{console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ",column.definition.formatter);}}break;}if(config.editor){column.modules.edit=config;}};Edit.prototype.getCurrentCell=function(){return this.currentCell?this.currentCell.getComponent():false;};Edit.prototype.clearEditor=function(){var cell=this.currentCell,cellEl;this.invalidEdit=false;if(cell){this.currentCell=false;cellEl=cell.getElement();cellEl.classList.remove("tabulator-validation-fail");cellEl.classList.remove("tabulator-editing");while(cellEl.firstChild){cellEl.removeChild(cellEl.firstChild);}cell.row.getElement().classList.remove("tabulator-row-editing");}};Edit.prototype.cancelEdit=function(){if(this.currentCell){var cell=this.currentCell;var component=this.currentCell.getComponent();this.clearEditor();cell.setValueActual(cell.getValue());if(cell.column.cellEvents.cellEditCancelled){cell.column.cellEvents.cellEditCancelled.call(this.table,component);}this.table.options.cellEditCancelled.call(this.table,component);}};//return a formatted value for a cell
Edit.prototype.bindEditor=function(cell){var self=this,element=cell.getElement();element.setAttribute("tabindex",0);element.addEventListener("click",function(e){if(!element.classList.contains("tabulator-editing")){element.focus();}});element.addEventListener("mousedown",function(e){self.mouseClick=true;});element.addEventListener("focus",function(e){if(!self.recursionBlock){self.edit(cell,e,false);}});};Edit.prototype.focusCellNoEvent=function(cell){this.recursionBlock=true;if(this.table.browser!=="ie"){cell.getElement().focus();}this.recursionBlock=false;};Edit.prototype.editCell=function(cell,forceEdit){this.focusCellNoEvent(cell);this.edit(cell,false,forceEdit);};Edit.prototype.edit=function(cell,e,forceEdit){var self=this,allowEdit=true,rendered=function rendered(){},element=cell.getElement(),cellEditor,component,params;//prevent editing if another cell is refusing to leave focus (eg. validation fail)
if(this.currentCell){if(!this.invalidEdit){this.cancelEdit();}return;}//handle successfull value change
function success(value){if(self.currentCell===cell){var valid=true;if(cell.column.modules.validate&&self.table.modExists("validate")){valid=self.table.modules.validate.validate(cell.column.modules.validate,cell.getComponent(),value);}if(valid===true){self.clearEditor();cell.setValue(value,true);if(self.table.options.dataTree&&self.table.modExists("dataTree")){self.table.modules.dataTree.checkForRestyle(cell);}}else{self.invalidEdit=true;element.classList.add("tabulator-validation-fail");self.focusCellNoEvent(cell);rendered();self.table.options.validationFailed.call(self.table,cell.getComponent(),value,valid);}}else{// console.warn("Edit Success Error - cannot call success on a cell that is no longer being edited");
}}//handle aborted edit
function cancel(){if(self.currentCell===cell){self.cancelEdit();if(self.table.options.dataTree&&self.table.modExists("dataTree")){self.table.modules.dataTree.checkForRestyle(cell);}}else{// console.warn("Edit Success Error - cannot call cancel on a cell that is no longer being edited");
}}function onRendered(callback){rendered=callback;}if(!cell.column.modules.edit.blocked){if(e){e.stopPropagation();}switch(_typeof(cell.column.modules.edit.check)){case"function":allowEdit=cell.column.modules.edit.check(cell.getComponent());break;case"boolean":allowEdit=cell.column.modules.edit.check;break;}if(allowEdit||forceEdit){self.cancelEdit();self.currentCell=cell;component=cell.getComponent();if(this.mouseClick){this.mouseClick=false;if(cell.column.cellEvents.cellClick){cell.column.cellEvents.cellClick.call(this.table,e,component);}}if(cell.column.cellEvents.cellEditing){cell.column.cellEvents.cellEditing.call(this.table,component);}self.table.options.cellEditing.call(this.table,component);params=typeof cell.column.modules.edit.params==="function"?cell.column.modules.edit.params(component):cell.column.modules.edit.params;cellEditor=cell.column.modules.edit.editor.call(self,component,onRendered,success,cancel,params);//if editor returned, add to DOM, if false, abort edit
if(cellEditor!==false){if(cellEditor instanceof Node){element.classList.add("tabulator-editing");cell.row.getElement().classList.add("tabulator-row-editing");while(element.firstChild){element.removeChild(element.firstChild);}element.appendChild(cellEditor);//trigger onRendered Callback
rendered();//prevent editing from triggering rowClick event
var children=element.children;for(var i=0;i<children.length;i++){children[i].addEventListener("click",function(e){e.stopPropagation();});}}else{console.warn("Edit Error - Editor should return an instance of Node, the editor returned:",cellEditor);element.blur();return false;}}else{element.blur();return false;}return true;}else{this.mouseClick=false;element.blur();return false;}}else{this.mouseClick=false;element.blur();return false;}};//default data editors
Edit.prototype.editors={//input element
input:function input(cell,onRendered,success,cancel,editorParams){//create and style input
var cellValue=cell.getValue(),input=document.createElement("input");input.setAttribute("type","text");input.style.padding="4px";input.style.width="100%";input.style.boxSizing="border-box";input.value=typeof cellValue!=="undefined"?cellValue:"";onRendered(function(){input.focus();input.style.height="100%";});function onChange(e){if((cellValue===null||typeof cellValue==="undefined")&&input.value!==""||input.value!=cellValue){success(input.value);}else{cancel();}}//submit new value on blur or change
input.addEventListener("change",onChange);input.addEventListener("blur",onChange);//submit new value on enter
input.addEventListener("keydown",function(e){switch(e.keyCode){case 13:success(input.value);break;case 27:cancel();break;}});return input;},//resizable text area element
textarea:function textarea(cell,onRendered,success,cancel,editorParams){var self=this,cellValue=cell.getValue(),value=String(cellValue!==null&&cellValue!=="undefined"?cellValue:""),count=(value.match(/(?:\r\n|\r|\n)/g)||[]).length+1,input=document.createElement("textarea"),scrollHeight=0;//create and style input
input.style.display="block";input.style.padding="2px";input.style.height="100%";input.style.width="100%";input.style.boxSizing="border-box";input.style.whiteSpace="pre-wrap";input.style.resize="none";input.value=value;onRendered(function(){input.focus();input.style.height="100%";});function onChange(e){if((cellValue===null||typeof cellValue==="undefined")&&input.value!==""||input.value!=cellValue){success(input.value);setTimeout(function(){cell.getRow().normalizeHeight();},300);}else{cancel();}}//submit new value on blur or change
input.addEventListener("change",onChange);input.addEventListener("blur",onChange);input.addEventListener("keyup",function(){input.style.height="";var heightNow=input.scrollHeight;input.style.height=heightNow+"px";if(heightNow!=scrollHeight){scrollHeight=heightNow;cell.getRow().normalizeHeight();}});input.addEventListener("keydown",function(e){if(e.keyCode==27){cancel();}});return input;},//input element with type of number
number:function number(cell,onRendered,success,cancel,editorParams){var cellValue=cell.getValue(),input=document.createElement("input");input.setAttribute("type","number");if(typeof editorParams.max!="undefined"){input.setAttribute("max",editorParams.max);}if(typeof editorParams.min!="undefined"){input.setAttribute("min",editorParams.min);}if(typeof editorParams.step!="undefined"){input.setAttribute("step",editorParams.step);}//create and style input
input.style.padding="4px";input.style.width="100%";input.style.boxSizing="border-box";input.value=cellValue;onRendered(function(){input.focus();input.style.height="100%";//submit new value on blur
input.addEventListener("blur",function(e){onChange();});});function onChange(){var value=input.value;if(!isNaN(value)&&value!==""){value=Number(value);}if(value!=cellValue){success(value);}else{cancel();}}//submit new value on enter
input.addEventListener("keydown",function(e){switch(e.keyCode){case 13:case 9:onChange();break;case 27:cancel();break;}});return input;},//input element with type of number
range:function range(cell,onRendered,success,cancel,editorParams){var cellValue=cell.getValue(),input=document.createElement("input");input.setAttribute("type","range");if(typeof editorParams.max!="undefined"){input.setAttribute("max",editorParams.max);}if(typeof editorParams.min!="undefined"){input.setAttribute("min",editorParams.min);}if(typeof editorParams.step!="undefined"){input.setAttribute("step",editorParams.step);}//create and style input
input.style.padding="4px";input.style.width="100%";input.style.boxSizing="border-box";input.value=cellValue;onRendered(function(){input.focus();input.style.height="100%";});function onChange(){var value=input.value;if(!isNaN(value)&&value!==""){value=Number(value);}if(value!=cellValue){success(value);}else{cancel();}}//submit new value on blur
input.addEventListener("blur",function(e){onChange();});//submit new value on enter
input.addEventListener("keydown",function(e){switch(e.keyCode){case 13:case 9:onChange();break;case 27:cancel();break;}});return input;},//select
select:function select(cell,onRendered,success,cancel,editorParams){var self=this,cellEl=cell.getElement(),initialValue=cell.getValue(),input=document.createElement("input"),listEl=document.createElement("div"),dataItems=[],displayItems=[],currentItem={},blurable=true;if(Array.isArray(editorParams)||!Array.isArray(editorParams)&&(typeof editorParams==='undefined'?'undefined':_typeof(editorParams))==="object"&&!editorParams.values){console.warn("DEPRECATION WANRING - values for the select editor must now be passed into the values property of the editorParams object, not as the editorParams object");editorParams={values:editorParams};}function getUniqueColumnValues(){var output={},column=cell.getColumn()._getSelf(),data=self.table.getData();data.forEach(function(row){var val=column.getFieldValue(row);if(val!==null&&typeof val!=="undefined"&&val!==""){output[val]=true;}});if(editorParams.sortValuesList){if(editorParams.sortValuesList=="asc"){output=Object.keys(output).sort();}else{output=Object.keys(output).sort().reverse();}}else{output=Object.keys(output);}return output;}function parseItems(inputValues,curentValue){var dataList=[];var displayList=[];function processComplexListItem(item){var item={label:editorParams.listItemFormatter?editorParams.listItemFormatter(item.value,item.label):item.label,value:item.value,element:false};if(item.value===curentValue||!isNaN(parseFloat(item.value))&&!isNaN(parseFloat(item.value))&&parseFloat(item.value)===parseFloat(curentValue)){setCurrentItem(item);}dataList.push(item);displayList.push(item);return item;}if(typeof inputValues=="function"){inputValues=inputValues(cell);}if(Array.isArray(inputValues)){inputValues.forEach(function(value){var item;if((typeof value==='undefined'?'undefined':_typeof(value))==="object"){if(value.options){item={label:value.label,group:true,element:false};displayList.push(item);value.options.forEach(function(item){processComplexListItem(item);});}else{processComplexListItem(value);}}else{item={label:editorParams.listItemFormatter?editorParams.listItemFormatter(value,value):value,value:value,element:false};if(item.value===curentValue||!isNaN(parseFloat(item.value))&&!isNaN(parseFloat(item.value))&&parseFloat(item.value)===parseFloat(curentValue)){setCurrentItem(item);}dataList.push(item);displayList.push(item);}});}else{for(var key in inputValues){var item={label:editorParams.listItemFormatter?editorParams.listItemFormatter(key,inputValues[key]):inputValues[key],value:key,element:false};if(item.value===curentValue||!isNaN(parseFloat(item.value))&&!isNaN(parseFloat(item.value))&&parseFloat(item.value)===parseFloat(curentValue)){setCurrentItem(item);}dataList.push(item);displayList.push(item);}}dataItems=dataList;displayItems=displayList;fillList();}function fillList(){while(listEl.firstChild){listEl.removeChild(listEl.firstChild);}displayItems.forEach(function(item){var el=item.element;if(!el){if(item.group){el=document.createElement("div");el.classList.add("tabulator-edit-select-list-group");el.tabIndex=0;el.innerHTML=item.label===""?"&nbsp;":item.label;}else{el=document.createElement("div");el.classList.add("tabulator-edit-select-list-item");el.tabIndex=0;el.innerHTML=item.label===""?"&nbsp;":item.label;el.addEventListener("click",function(){setCurrentItem(item);chooseItem();});if(item===currentItem){el.classList.add("active");}}el.addEventListener("mousedown",function(){blurable=false;setTimeout(function(){blurable=true;},10);});item.element=el;}listEl.appendChild(el);});}function setCurrentItem(item){if(currentItem&&currentItem.element){currentItem.element.classList.remove("active");}currentItem=item;input.value=item.label==="&nbsp;"?"":item.label;if(item.element){item.element.classList.add("active");}}function chooseItem(){hideList();if(initialValue!==currentItem.value){initialValue=currentItem.value;success(currentItem.value);}else{cancel();}}function cancelItem(){hideList();cancel();}function showList(){if(!listEl.parentNode){if(editorParams.values===true){parseItems(getUniqueColumnValues(),initialValue);}else{parseItems(editorParams.values||[],initialValue);}var offset=Tabulator.prototype.helpers.elOffset(cellEl);listEl.style.minWidth=cellEl.offsetWidth+"px";listEl.style.top=offset.top+cellEl.offsetHeight+"px";listEl.style.left=offset.left+"px";document.body.appendChild(listEl);}}function hideList(){if(listEl.parentNode){listEl.parentNode.removeChild(listEl);}}//style input
input.setAttribute("type","text");input.style.padding="4px";input.style.width="100%";input.style.boxSizing="border-box";input.readOnly=true;input.value=initialValue;if(editorParams.values===true){parseItems(getUniqueColumnValues(),initialValue);}else{parseItems(editorParams.values||[],initialValue);}//allow key based navigation
input.addEventListener("keydown",function(e){var index;switch(e.keyCode){case 38://up arrow
e.stopImmediatePropagation();e.stopPropagation();index=dataItems.indexOf(currentItem);if(index>0){setCurrentItem(dataItems[index-1]);}break;case 40://down arrow
e.stopImmediatePropagation();e.stopPropagation();index=dataItems.indexOf(currentItem);if(index<dataItems.length-1){if(index==-1){setCurrentItem(dataItems[0]);}else{setCurrentItem(dataItems[index+1]);}}break;case 13://enter
chooseItem();break;case 27://escape
cancelItem();break;}});input.addEventListener("blur",function(e){if(blurable){cancelItem();}});input.addEventListener("focus",function(e){showList();});//style list element
listEl=document.createElement("div");listEl.classList.add("tabulator-edit-select-list");onRendered(function(){input.style.height="100%";input.focus();});return input;},//autocomplete
autocomplete:function autocomplete(cell,onRendered,success,cancel,editorParams){var self=this,cellEl=cell.getElement(),initialValue=cell.getValue(),input=document.createElement("input"),listEl=document.createElement("div"),allItems=[],displayItems=[],values=[],currentItem={},blurable=true;function getUniqueColumnValues(){var output={},column=cell.getColumn()._getSelf(),data=self.table.getData();data.forEach(function(row){var val=column.getFieldValue(row);if(val!==null&&typeof val!=="undefined"&&val!==""){output[val]=true;}});if(editorParams.sortValuesList){if(editorParams.sortValuesList=="asc"){output=Object.keys(output).sort();}else{output=Object.keys(output).sort().reverse();}}else{output=Object.keys(output);}return output;}function parseItems(inputValues,curentValue){var itemList=[];if(Array.isArray(inputValues)){inputValues.forEach(function(value){var item={title:editorParams.listItemFormatter?editorParams.listItemFormatter(value,value):value,value:value,element:false};if(item.value===curentValue||!isNaN(parseFloat(item.value))&&!isNaN(parseFloat(item.value))&&parseFloat(item.value)===parseFloat(curentValue)){setCurrentItem(item);}itemList.push(item);});}else{for(var key in inputValues){var item={title:editorParams.listItemFormatter?editorParams.listItemFormatter(key,inputValues[key]):inputValues[key],value:key,element:false};if(item.value===curentValue||!isNaN(parseFloat(item.value))&&!isNaN(parseFloat(item.value))&&parseFloat(item.value)===parseFloat(curentValue)){setCurrentItem(item);}itemList.push(item);}}allItems=itemList;}function filterList(term,intialLoad){var matches=[];if(editorParams.searchFunc){matches=editorParams.searchFunc(term,values);}else{if(term===""){if(editorParams.showListOnEmpty){allItems.forEach(function(item){matches.push(item);});}}else{allItems.forEach(function(item){if(item.value!==null||typeof item.value!=="undefined"){if(String(item.value).toLowerCase().indexOf(String(term).toLowerCase())>-1||String(item.title).toLowerCase().indexOf(String(term).toLowerCase())>-1){matches.push(item);}}});}}displayItems=matches;fillList(intialLoad);}function fillList(intialLoad){var current=false;while(listEl.firstChild){listEl.removeChild(listEl.firstChild);}displayItems.forEach(function(item){var el=item.element;if(!el){el=document.createElement("div");el.classList.add("tabulator-edit-select-list-item");el.tabIndex=0;el.innerHTML=item.title;el.addEventListener("click",function(){setCurrentItem(item);chooseItem();});el.addEventListener("mousedown",function(){blurable=false;setTimeout(function(){blurable=true;},10);});item.element=el;if(intialLoad&&item.value==initialValue){input.value=item.title;item.element.classList.add("active");current=true;}if(item===currentItem){item.element.classList.add("active");current=true;}}listEl.appendChild(el);});if(!current){setCurrentItem(false);}}function setCurrentItem(item,showInputValue){if(currentItem&&currentItem.element){currentItem.element.classList.remove("active");}currentItem=item;if(item&&item.element){item.element.classList.add("active");}}function chooseItem(){hideList();if(currentItem){if(initialValue!==currentItem.value){initialValue=currentItem.value;input.value=currentItem.value;success(input.value);}else{cancel();}}else{if(editorParams.freetext){initialValue=input.value;success(input.value);}else{if(editorParams.allowEmpty&&input.value===""){initialValue=input.value;success(input.value);}else{cancel();}}}}function cancelItem(){hideList();cancel();}function showList(){if(!listEl.parentNode){while(listEl.firstChild){listEl.removeChild(listEl.firstChild);}if(editorParams.values===true){values=getUniqueColumnValues();}else{values=editorParams.values||[];}parseItems(values,initialValue);var offset=Tabulator.prototype.helpers.elOffset(cellEl);listEl.style.minWidth=cellEl.offsetWidth+"px";listEl.style.top=offset.top+cellEl.offsetHeight+"px";listEl.style.left=offset.left+"px";document.body.appendChild(listEl);}}function hideList(){if(listEl.parentNode){listEl.parentNode.removeChild(listEl);}}//style input
input.setAttribute("type","search");input.style.padding="4px";input.style.width="100%";input.style.boxSizing="border-box";//allow key based navigation
input.addEventListener("keydown",function(e){var index;switch(e.keyCode){case 38://up arrow
e.stopImmediatePropagation();e.stopPropagation();index=displayItems.indexOf(currentItem);if(index>0){setCurrentItem(displayItems[index-1]);}else{setCurrentItem(false);}break;case 40://down arrow
e.stopImmediatePropagation();e.stopPropagation();index=displayItems.indexOf(currentItem);if(index<displayItems.length-1){if(index==-1){setCurrentItem(displayItems[0]);}else{setCurrentItem(displayItems[index+1]);}}break;case 13://enter
chooseItem();break;case 27://escape
cancelItem();break;case 36://home
case 35://end
//prevent table navigation while using input element
e.stopImmediatePropagation();break;}});input.addEventListener("keyup",function(e){switch(e.keyCode){case 38://up arrow
case 37://left arrow
case 39://up arrow
case 40://right arrow
case 13://enter
case 27://escape
break;default:filterList(input.value);}});input.addEventListener("search",function(e){filterList(input.value);});input.addEventListener("blur",function(e){if(blurable){chooseItem();}});input.addEventListener("focus",function(e){showList();input.value=initialValue;filterList(initialValue,true);});//style list element
listEl=document.createElement("div");listEl.classList.add("tabulator-edit-select-list");onRendered(function(){input.style.height="100%";input.focus();});return input;},//start rating
star:function star(cell,onRendered,success,cancel,editorParams){var self=this,element=cell.getElement(),value=cell.getValue(),maxStars=element.getElementsByTagName("svg").length||5,size=element.getElementsByTagName("svg")[0]?element.getElementsByTagName("svg")[0].getAttribute("width"):14,stars=[],starsHolder=document.createElement("div"),star=document.createElementNS('http://www.w3.org/2000/svg',"svg");//change star type
function starChange(val){stars.forEach(function(star,i){if(i<val){if(self.table.browser=="ie"){star.setAttribute("class","tabulator-star-active");}else{star.classList.replace("tabulator-star-inactive","tabulator-star-active");}star.innerHTML='<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';}else{if(self.table.browser=="ie"){star.setAttribute("class","tabulator-star-inactive");}else{star.classList.replace("tabulator-star-active","tabulator-star-inactive");}star.innerHTML='<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';}});}//build stars
function buildStar(i){var starHolder=document.createElement("span");var nextStar=star.cloneNode(true);stars.push(nextStar);starHolder.addEventListener("mouseenter",function(e){e.stopPropagation();e.stopImmediatePropagation();starChange(i);});starHolder.addEventListener("mousemove",function(e){e.stopPropagation();e.stopImmediatePropagation();});starHolder.addEventListener("click",function(e){e.stopPropagation();e.stopImmediatePropagation();success(i);});starHolder.appendChild(nextStar);starsHolder.appendChild(starHolder);}//handle keyboard navigation value change
function changeValue(val){value=val;starChange(val);}//style cell
element.style.whiteSpace="nowrap";element.style.overflow="hidden";element.style.textOverflow="ellipsis";//style holding element
starsHolder.style.verticalAlign="middle";starsHolder.style.display="inline-block";starsHolder.style.padding="4px";//style star
star.setAttribute("width",size);star.setAttribute("height",size);star.setAttribute("viewBox","0 0 512 512");star.setAttribute("xml:space","preserve");star.style.padding="0 1px";//create correct number of stars
for(var i=1;i<=maxStars;i++){buildStar(i);}//ensure value does not exceed number of stars
value=Math.min(parseInt(value),maxStars);// set initial styling of stars
starChange(value);starsHolder.addEventListener("mousemove",function(e){starChange(0);});starsHolder.addEventListener("click",function(e){success(0);});element.addEventListener("blur",function(e){cancel();});//allow key based navigation
element.addEventListener("keydown",function(e){switch(e.keyCode){case 39://right arrow
changeValue(value+1);break;case 37://left arrow
changeValue(value-1);break;case 13://enter
success(value);break;case 27://escape
cancel();break;}});return starsHolder;},//draggable progress bar
progress:function progress(cell,onRendered,success,cancel,editorParams){var element=cell.getElement(),max=typeof editorParams.max==="undefined"?element.getElementsByTagName("div")[0].getAttribute("max")||100:editorParams.max,min=typeof editorParams.min==="undefined"?element.getElementsByTagName("div")[0].getAttribute("min")||0:editorParams.min,percent=(max-min)/100,value=cell.getValue()||0,handle=document.createElement("div"),bar=document.createElement("div"),mouseDrag,mouseDragWidth;//set new value
function updateValue(){var calcVal=percent*Math.round(bar.offsetWidth/(element.clientWidth/100))+min;success(calcVal);element.setAttribute("aria-valuenow",calcVal);element.setAttribute("aria-label",value);}//style handle
handle.style.position="absolute";handle.style.right="0";handle.style.top="0";handle.style.bottom="0";handle.style.width="5px";handle.classList.add("tabulator-progress-handle");//style bar
bar.style.display="inline-block";bar.style.position="absolute";bar.style.top="8px";bar.style.bottom="8px";bar.style.left="4px";bar.style.marginRight="4px";bar.style.backgroundColor="#488CE9";bar.style.maxWidth="100%";bar.style.minWidth="0%";//style cell
element.style.padding="0 4px";//make sure value is in range
value=Math.min(parseFloat(value),max);value=Math.max(parseFloat(value),min);//workout percentage
value=100-Math.round((value-min)/percent);bar.style.right=value+"%";element.setAttribute("aria-valuemin",min);element.setAttribute("aria-valuemax",max);bar.appendChild(handle);handle.addEventListener("mousedown",function(e){mouseDrag=e.screenX;mouseDragWidth=bar.offsetWidth;});handle.addEventListener("mouseover",function(){handle.style.cursor="ew-resize";});element.addEventListener("mousemove",function(e){if(mouseDrag){bar.style.width=mouseDragWidth+e.screenX-mouseDrag+"px";}});element.addEventListener("mouseup",function(e){if(mouseDrag){e.stopPropagation();e.stopImmediatePropagation();mouseDrag=false;mouseDragWidth=false;updateValue();}});//allow key based navigation
element.addEventListener("keydown",function(e){switch(e.keyCode){case 39://right arrow
bar.style.width=bar.clientWidth+element.clientWidth/100+"px";break;case 37://left arrow
bar.style.width=bar.clientWidth-element.clientWidth/100+"px";break;case 13://enter
updateValue();break;case 27://escape
cancel();break;}});element.addEventListener("blur",function(){cancel();});return bar;},//checkbox
tickCross:function tickCross(cell,onRendered,success,cancel,editorParams){var value=cell.getValue(),input=document.createElement("input"),tristate=editorParams.tristate,indetermValue=typeof editorParams.indeterminateValue==="undefined"?null:editorParams.indeterminateValue,indetermState=false;input.setAttribute("type","checkbox");input.style.marginTop="5px";input.style.boxSizing="border-box";input.value=value;if(tristate&&(typeof value==="undefined"||value===indetermValue||value==="")){indetermState=true;input.indeterminate=true;}if(this.table.browser!="firefox"){//prevent blur issue on mac firefox
onRendered(function(){input.focus();});}input.checked=value===true||value==="true"||value==="True"||value===1;function setValue(blur){if(tristate){if(!blur){if(input.checked&&!indetermState){input.checked=false;input.indeterminate=true;indetermState=true;return indetermValue;}else{indetermState=false;return input.checked;}}else{if(indetermState){return indetermValue;}else{return input.checked;}}}else{return input.checked;}}//submit new value on blur
input.addEventListener("change",function(e){success(setValue());});input.addEventListener("blur",function(e){success(setValue(true));});//submit new value on enter
input.addEventListener("keydown",function(e){if(e.keyCode==13){success(setValue());}if(e.keyCode==27){cancel();}});return input;}};Tabulator.prototype.registerModule("edit",Edit);var Filter=function Filter(table){this.table=table;//hold Tabulator object
this.filterList=[];//hold filter list
this.headerFilters={};//hold column filters
this.headerFilterElements=[];//hold header filter elements for manipulation
this.headerFilterColumns=[];//hold columns that use header filters
this.changed=false;//has filtering changed since last render
};//initialize column header filter
Filter.prototype.initializeColumn=function(column,value){var self=this,field=column.getField(),prevSuccess,params;//handle successfull value change
function success(value){var filterType=column.modules.filter.tagType=="input"&&column.modules.filter.attrType=="text"||column.modules.filter.tagType=="textarea"?"partial":"match",type="",filterFunc;if(typeof prevSuccess==="undefined"||prevSuccess!==value){prevSuccess=value;if(!column.modules.filter.emptyFunc(value)){column.modules.filter.value=value;switch(_typeof(column.definition.headerFilterFunc)){case"string":if(self.filters[column.definition.headerFilterFunc]){type=column.definition.headerFilterFunc;filterFunc=function filterFunc(data){var params=column.definition.headerFilterFuncParams||{};var fieldVal=column.getFieldValue(data);params=typeof params==="function"?params(value,fieldVal,data):params;return self.filters[column.definition.headerFilterFunc](value,fieldVal,data,params);};}else{console.warn("Header Filter Error - Matching filter function not found: ",column.definition.headerFilterFunc);}break;case"function":filterFunc=function filterFunc(data){var params=column.definition.headerFilterFuncParams||{};var fieldVal=column.getFieldValue(data);params=typeof params==="function"?params(value,fieldVal,data):params;return column.definition.headerFilterFunc(value,fieldVal,data,params);};type=filterFunc;break;}if(!filterFunc){switch(filterType){case"partial":filterFunc=function filterFunc(data){return String(column.getFieldValue(data)).toLowerCase().indexOf(String(value).toLowerCase())>-1;};type="like";break;default:filterFunc=function filterFunc(data){return column.getFieldValue(data)==value;};type="=";}}self.headerFilters[field]={value:value,func:filterFunc,type:type};}else{delete self.headerFilters[field];}self.changed=true;self.table.rowManager.filterRefresh();}}column.modules.filter={success:success,attrType:false,tagType:false,emptyFunc:false};this.generateHeaderFilterElement(column);};Filter.prototype.generateHeaderFilterElement=function(column,initialValue){var self=this,success=column.modules.filter.success,field=column.getField(),filterElement,editor,editorElement,cellWrapper,typingTimer,searchTrigger,params;//handle aborted edit
function cancel(){}if(column.modules.filter.headerElement&&column.modules.filter.headerElement.parentNode){var oldFilterElement=column.modules.filter.headerElement.parentNode;var oldFilterElementIndex=self.headerFilterElements.indexOf(oldFilterElement);if(oldFilterElementIndex>=0){self.headerFilterElements.splice(oldFilterElementIndex,1);}var oldColumnIndex=self.headerFilterColumns.indexOf(oldColumnIndex);if(oldColumnIndex>=0){self.headerFilterColumns.splice(oldColumnIndex,1);}column.contentElement.removeChild(oldFilterElement);}if(field){//set empty value function
column.modules.filter.emptyFunc=column.definition.headerFilterEmptyCheck||function(value){return!value&&value!=="0";};filterElement=document.createElement("div");filterElement.classList.add("tabulator-header-filter");//set column editor
switch(_typeof(column.definition.headerFilter)){case"string":if(self.table.modules.edit.editors[column.definition.headerFilter]){editor=self.table.modules.edit.editors[column.definition.headerFilter];if((column.definition.headerFilter==="tick"||column.definition.headerFilter==="tickCross")&&!column.definition.headerFilterEmptyCheck){column.modules.filter.emptyFunc=function(value){return value!==true&&value!==false;};}}else{console.warn("Filter Error - Cannot build header filter, No such editor found: ",column.definition.editor);}break;case"function":editor=column.definition.headerFilter;break;case"boolean":if(column.modules.edit&&column.modules.edit.editor){editor=column.modules.edit.editor;}else{if(column.definition.formatter&&self.table.modules.edit.editors[column.definition.formatter]){editor=self.table.modules.edit.editors[column.definition.formatter];if((column.definition.formatter==="tick"||column.definition.formatter==="tickCross")&&!column.definition.headerFilterEmptyCheck){column.modules.filter.emptyFunc=function(value){return value!==true&&value!==false;};}}else{editor=self.table.modules.edit.editors["input"];}}break;}if(editor){cellWrapper={getValue:function getValue(){return typeof initialValue!=="undefined"?initialValue:"";},getField:function getField(){return column.definition.field;},getElement:function getElement(){return filterElement;},getColumn:function getColumn(){return column.getComponent();},getRow:function getRow(){return{normalizeHeight:function normalizeHeight(){}};}};params=column.definition.headerFilterParams||{};params=typeof params==="function"?params.call(self.table):params;editorElement=editor.call(this.table.modules.edit,cellWrapper,function(){},success,cancel,params);if(!editorElement){console.warn("Filter Error - Cannot add filter to "+field+" column, editor returned a value of false");return;}if(!(editorElement instanceof Node)){console.warn("Filter Error - Cannot add filter to "+field+" column, editor should return an instance of Node, the editor returned:",editorElement);return;}//set Placeholder Text
if(field){self.table.modules.localize.bind("headerFilters|columns|"+column.definition.field,function(value){editorElement.setAttribute("placeholder",typeof value!=="undefined"&&value?value:self.table.modules.localize.getText("headerFilters|default"));});}else{self.table.modules.localize.bind("headerFilters|default",function(value){editorElement.setAttribute("placeholder",typeof self.column.definition.headerFilterPlaceholder!=="undefined"&&self.column.definition.headerFilterPlaceholder?self.column.definition.headerFilterPlaceholder:value);});}//focus on element on click
editorElement.addEventListener("click",function(e){e.stopPropagation();editorElement.focus();});//live update filters as user types
typingTimer=false;searchTrigger=function searchTrigger(e){if(typingTimer){clearTimeout(typingTimer);}typingTimer=setTimeout(function(){success(editorElement.value);},300);};column.modules.filter.headerElement=editorElement;column.modules.filter.attrType=editorElement.hasAttribute("type")?editorElement.getAttribute("type").toLowerCase():"";column.modules.filter.tagType=editorElement.tagName.toLowerCase();if(column.definition.headerFilterLiveFilter!==false){if(!(column.definition.headerFilter==="autocomplete"||column.definition.editor==="autocomplete"&&column.definition.headerFilter===true)){editorElement.addEventListener("keyup",searchTrigger);editorElement.addEventListener("search",searchTrigger);//update number filtered columns on change
if(column.modules.filter.attrType=="number"){editorElement.addEventListener("change",function(e){success(editorElement.value);});}//change text inputs to search inputs to allow for clearing of field
if(column.modules.filter.attrType=="text"&&this.table.browser!=="ie"){editorElement.setAttribute("type","search");// editorElement.off("change blur"); //prevent blur from triggering filter and preventing selection click
}}//prevent input and select elements from propegating click to column sorters etc
if(column.modules.filter.tagType=="input"||column.modules.filter.tagType=="select"||column.modules.filter.tagType=="textarea"){editorElement.addEventListener("mousedown",function(e){e.stopPropagation();});}}filterElement.appendChild(editorElement);column.contentElement.appendChild(filterElement);self.headerFilterElements.push(editorElement);self.headerFilterColumns.push(column);}}else{console.warn("Filter Error - Cannot add header filter, column has no field set:",column.definition.title);}};//hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
Filter.prototype.hideHeaderFilterElements=function(){this.headerFilterElements.forEach(function(element){element.style.display='none';});};//show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
Filter.prototype.showHeaderFilterElements=function(){this.headerFilterElements.forEach(function(element){element.style.display='';});};//programatically set value of header filter
Filter.prototype.setHeaderFilterFocus=function(column){if(column.modules.filter&&column.modules.filter.headerElement){column.modules.filter.headerElement.focus();}else{console.warn("Column Filter Focus Error - No header filter set on column:",column.getField());}};//programatically set value of header filter
Filter.prototype.setHeaderFilterValue=function(column,value){if(column){if(column.modules.filter&&column.modules.filter.headerElement){this.generateHeaderFilterElement(column,value);column.modules.filter.success(value);}else{console.warn("Column Filter Error - No header filter set on column:",column.getField());}}};Filter.prototype.reloadHeaderFilter=function(column){if(column){if(column.modules.filter&&column.modules.filter.headerElement){this.generateHeaderFilterElement(column,column.modules.filter.value);}else{console.warn("Column Filter Error - No header filter set on column:",column.getField());}}};//check if the filters has changed since last use
Filter.prototype.hasChanged=function(){var changed=this.changed;this.changed=false;return changed;};//set standard filters
Filter.prototype.setFilter=function(field,type,value){var self=this;self.filterList=[];if(!Array.isArray(field)){field=[{field:field,type:type,value:value}];}self.addFilter(field);};//add filter to array
Filter.prototype.addFilter=function(field,type,value){var self=this;if(!Array.isArray(field)){field=[{field:field,type:type,value:value}];}field.forEach(function(filter){filter=self.findFilter(filter);if(filter){self.filterList.push(filter);self.changed=true;}});if(this.table.options.persistentFilter&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("filter");}};Filter.prototype.findFilter=function(filter){var self=this,column;if(Array.isArray(filter)){return this.findSubFilters(filter);}var filterFunc=false;if(typeof filter.field=="function"){filterFunc=function filterFunc(data){return filter.field(data,filter.type||{});// pass params to custom filter function
};}else{if(self.filters[filter.type]){column=self.table.columnManager.getColumnByField(filter.field);if(column){filterFunc=function filterFunc(data){return self.filters[filter.type](filter.value,column.getFieldValue(data));};}else{filterFunc=function filterFunc(data){return self.filters[filter.type](filter.value,data[filter.field]);};}}else{console.warn("Filter Error - No such filter type found, ignoring: ",filter.type);}}filter.func=filterFunc;return filter.func?filter:false;};Filter.prototype.findSubFilters=function(filters){var self=this,output=[];filters.forEach(function(filter){filter=self.findFilter(filter);if(filter){output.push(filter);}});return output.length?output:false;};//get all filters
Filter.prototype.getFilters=function(all,ajax){var self=this,output=[];if(all){output=self.getHeaderFilters();}self.filterList.forEach(function(filter){output.push({field:filter.field,type:filter.type,value:filter.value});});if(ajax){output.forEach(function(item){if(typeof item.type=="function"){item.type="function";}});}return output;};//get all filters
Filter.prototype.getHeaderFilters=function(){var self=this,output=[];for(var key in this.headerFilters){output.push({field:key,type:this.headerFilters[key].type,value:this.headerFilters[key].value});}return output;};//remove filter from array
Filter.prototype.removeFilter=function(field,type,value){var self=this;if(!Array.isArray(field)){field=[{field:field,type:type,value:value}];}field.forEach(function(filter){var index=-1;if(_typeof(filter.field)=="object"){index=self.filterList.findIndex(function(element){return filter===element;});}else{index=self.filterList.findIndex(function(element){return filter.field===element.field&&filter.type===element.type&&filter.value===element.value;});}if(index>-1){self.filterList.splice(index,1);self.changed=true;}else{console.warn("Filter Error - No matching filter type found, ignoring: ",filter.type);}});if(this.table.options.persistentFilter&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("filter");}};//clear filters
Filter.prototype.clearFilter=function(all){this.filterList=[];if(all){this.clearHeaderFilter();}this.changed=true;if(this.table.options.persistentFilter&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("filter");}};//clear header filters
Filter.prototype.clearHeaderFilter=function(){var self=this;this.headerFilters={};this.headerFilterColumns.forEach(function(column){column.modules.filter.value=null;self.reloadHeaderFilter(column);});this.changed=true;};//search data and return matching rows
Filter.prototype.search=function(searchType,field,type,value){var self=this,activeRows=[],filterList=[];if(!Array.isArray(field)){field=[{field:field,type:type,value:value}];}field.forEach(function(filter){filter=self.findFilter(filter);if(filter){filterList.push(filter);}});this.table.rowManager.rows.forEach(function(row){var match=true;filterList.forEach(function(filter){if(!self.filterRecurse(filter,row.getData())){match=false;}});if(match){activeRows.push(searchType==="data"?row.getData("data"):row.getComponent());}});return activeRows;};//filter row array
Filter.prototype.filter=function(rowList,filters){var self=this,activeRows=[],activeRowComponents=[];if(self.table.options.dataFiltering){self.table.options.dataFiltering.call(self.table,self.getFilters());}if(!self.table.options.ajaxFiltering&&(self.filterList.length||Object.keys(self.headerFilters).length)){rowList.forEach(function(row){if(self.filterRow(row)){activeRows.push(row);}});}else{activeRows=rowList.slice(0);}if(self.table.options.dataFiltered){activeRows.forEach(function(row){activeRowComponents.push(row.getComponent());});self.table.options.dataFiltered.call(self.table,self.getFilters(),activeRowComponents);}return activeRows;};//filter individual row
Filter.prototype.filterRow=function(row,filters){var self=this,match=true,data=row.getData();self.filterList.forEach(function(filter){if(!self.filterRecurse(filter,data)){match=false;}});for(var field in self.headerFilters){if(!self.headerFilters[field].func(data)){match=false;}}return match;};Filter.prototype.filterRecurse=function(filter,data){var self=this,match=false;if(Array.isArray(filter)){filter.forEach(function(subFilter){if(self.filterRecurse(subFilter,data)){match=true;}});}else{match=filter.func(data);}return match;};//list of available filters
Filter.prototype.filters={//equal to
"=":function _(filterVal,rowVal,rowData,filterParams){return rowVal==filterVal?true:false;},//less than
"<":function _(filterVal,rowVal,rowData,filterParams){return rowVal<filterVal?true:false;},//less than or equal to
"<=":function _(filterVal,rowVal,rowData,filterParams){return rowVal<=filterVal?true:false;},//greater than
">":function _(filterVal,rowVal,rowData,filterParams){return rowVal>filterVal?true:false;},//greater than or equal to
">=":function _(filterVal,rowVal,rowData,filterParams){return rowVal>=filterVal?true:false;},//not equal to
"!=":function _(filterVal,rowVal,rowData,filterParams){return rowVal!=filterVal?true:false;},"regex":function regex(filterVal,rowVal,rowData,filterParams){if(typeof filterVal=="string"){filterVal=new RegExp(filterVal);}return filterVal.test(rowVal);},//contains the string
"like":function like(filterVal,rowVal,rowData,filterParams){if(filterVal===null||typeof filterVal==="undefined"){return rowVal===filterVal?true:false;}else{if(typeof rowVal!=='undefined'&&rowVal!==null){return String(rowVal).toLowerCase().indexOf(filterVal.toLowerCase())>-1?true:false;}else{return false;}}},//in array
"in":function _in(filterVal,rowVal,rowData,filterParams){if(Array.isArray(filterVal)){return filterVal.indexOf(rowVal)>-1;}else{console.warn("Filter Error - filter value is not an array:",filterVal);return false;}}};Tabulator.prototype.registerModule("filter",Filter);var Format=function Format(table){this.table=table;//hold Tabulator object
};//initialize column formatter
Format.prototype.initializeColumn=function(column){var self=this,config={params:column.definition.formatterParams||{}};//set column formatter
switch(_typeof(column.definition.formatter)){case"string":if(column.definition.formatter==="tick"){column.definition.formatter="tickCross";if(typeof config.params.crossElement=="undefined"){config.params.crossElement=false;}console.warn("DEPRECATION WANRING - the tick formatter has been depricated, please use the tickCross formatter with the crossElement param set to false");}if(self.formatters[column.definition.formatter]){config.formatter=self.formatters[column.definition.formatter];}else{console.warn("Formatter Error - No such formatter found: ",column.definition.formatter);config.formatter=self.formatters.plaintext;}break;case"function":config.formatter=column.definition.formatter;break;default:config.formatter=self.formatters.plaintext;break;}column.modules.format=config;};Format.prototype.cellRendered=function(cell){if(cell.column.modules.format.renderedCallback){cell.column.modules.format.renderedCallback();}};//return a formatted value for a cell
Format.prototype.formatValue=function(cell){var component=cell.getComponent(),params=typeof cell.column.modules.format.params==="function"?cell.column.modules.format.params(component):cell.column.modules.format.params;function onRendered(callback){cell.column.modules.format.renderedCallback=callback;}return cell.column.modules.format.formatter.call(this,component,params,onRendered);};Format.prototype.sanitizeHTML=function(value){if(value){var entityMap={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','`':'&#x60;','=':'&#x3D;'};return String(value).replace(/[&<>"'`=\/]/g,function(s){return entityMap[s];});}else{return value;}};Format.prototype.emptyToSpace=function(value){return value===null||typeof value==="undefined"?"&nbsp":value;};//get formatter for cell
Format.prototype.getFormatter=function(formatter){var formatter;switch(typeof formatter==='undefined'?'undefined':_typeof(formatter)){case"string":if(this.formatters[formatter]){formatter=this.formatters[formatter];}else{console.warn("Formatter Error - No such formatter found: ",formatter);formatter=this.formatters.plaintext;}break;case"function":formatter=formatter;break;default:formatter=this.formatters.plaintext;break;}return formatter;};//default data formatters
Format.prototype.formatters={//plain text value
plaintext:function plaintext(cell,formatterParams,onRendered){return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));},//html text value
html:function html(cell,formatterParams,onRendered){return cell.getValue();},//multiline text area
textarea:function textarea(cell,formatterParams,onRendered){cell.getElement().style.whiteSpace="pre-wrap";return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));},//currency formatting
money:function money(cell,formatterParams,onRendered){var floatVal=parseFloat(cell.getValue()),number,integer,decimal,rgx;var decimalSym=formatterParams.decimal||".";var thousandSym=formatterParams.thousand||",";var symbol=formatterParams.symbol||"";var after=!!formatterParams.symbolAfter;var precision=typeof formatterParams.precision!=="undefined"?formatterParams.precision:2;if(isNaN(floatVal)){return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));}number=precision!==false?floatVal.toFixed(precision):floatVal;number=String(number).split(".");integer=number[0];decimal=number.length>1?decimalSym+number[1]:"";rgx=/(\d+)(\d{3})/;while(rgx.test(integer)){integer=integer.replace(rgx,"$1"+thousandSym+"$2");}return after?integer+decimal+symbol:symbol+integer+decimal;},//clickable anchor tag
link:function link(cell,formatterParams,onRendered){var value=cell.getValue(),urlPrefix=formatterParams.urlPrefix||"",label=this.emptyToSpace(value),el=document.createElement("a"),data;if(formatterParams.labelField){data=cell.getData();label=data[formatterParams.labelField];}if(formatterParams.label){switch(_typeof(formatterParams.label)){case"string":label=formatterParams.label;break;case"function":label=formatterParams.label(cell);break;}}if(formatterParams.urlField){data=cell.getData();value=data[formatterParams.urlField];}if(formatterParams.url){switch(_typeof(formatterParams.url)){case"string":value=formatterParams.url;break;case"function":value=formatterParams.url(cell);break;}}el.setAttribute("href",urlPrefix+value);if(formatterParams.target){el.setAttribute("target",formatterParams.target);}el.innerHTML=this.emptyToSpace(this.sanitizeHTML(label));return el;},//image element
image:function image(cell,formatterParams,onRendered){var el=document.createElement("img");el.setAttribute("src",cell.getValue());switch(_typeof(formatterParams.height)){case"number":el.style.height=formatterParams.height+"px";break;case"string":el.style.height=formatterParams.height;break;}switch(_typeof(formatterParams.width)){case"number":el.style.width=formatterParams.width+"px";break;case"string":el.style.width=formatterParams.width;break;}el.addEventListener("load",function(){cell.getRow().normalizeHeight();});return el;},//tick or cross
tickCross:function tickCross(cell,formatterParams,onRendered){var value=cell.getValue(),element=cell.getElement(),empty=formatterParams.allowEmpty,truthy=formatterParams.allowTruthy,tick=typeof formatterParams.tickElement!=="undefined"?formatterParams.tickElement:'<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>',cross=typeof formatterParams.crossElement!=="undefined"?formatterParams.crossElement:'<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';if(truthy&&value||value===true||value==="true"||value==="True"||value===1||value==="1"){element.setAttribute("aria-checked",true);return tick||"";}else{if(empty&&(value==="null"||value===""||value===null||typeof value==="undefined")){element.setAttribute("aria-checked","mixed");return"";}else{element.setAttribute("aria-checked",false);return cross||"";}}},datetime:function datetime(cell,formatterParams,onRendered){var inputFormat=formatterParams.inputFormat||"YYYY-MM-DD hh:mm:ss";var outputFormat=formatterParams.outputFormat||"DD/MM/YYYY hh:mm:ss";var invalid=typeof formatterParams.invalidPlaceholder!=="undefined"?formatterParams.invalidPlaceholder:"";var value=cell.getValue();var newDatetime=moment(value,inputFormat);if(newDatetime.isValid()){return newDatetime.format(outputFormat);}else{if(invalid===true){return value;}else if(typeof invalid==="function"){return invalid(value);}else{return invalid;}}},datetimediff:function datetime(cell,formatterParams,onRendered){var inputFormat=formatterParams.inputFormat||"YYYY-MM-DD hh:mm:ss";var invalid=typeof formatterParams.invalidPlaceholder!=="undefined"?formatterParams.invalidPlaceholder:"";var suffix=typeof formatterParams.suffix!=="undefined"?formatterParams.suffix:false;var unit=typeof formatterParams.unit!=="undefined"?formatterParams.unit:undefined;var humanize=typeof formatterParams.humanize!=="undefined"?formatterParams.humanize:false;var date=typeof formatterParams.date!=="undefined"?formatterParams.date:moment();var value=cell.getValue();var newDatetime=moment(value,inputFormat);if(newDatetime.isValid()){if(humanize){return moment.duration(newDatetime.diff(date)).humanize(suffix);}else{return newDatetime.diff(date,unit)+(suffix?" "+suffix:"");}}else{if(invalid===true){return value;}else if(typeof invalid==="function"){return invalid(value);}else{return invalid;}}},//select
lookup:function lookup(cell,formatterParams,onRendered){var value=cell.getValue();if(typeof formatterParams[value]==="undefined"){console.warn('Missing display value for '+value);return value;}return formatterParams[value];},//star rating
star:function star(cell,formatterParams,onRendered){var value=cell.getValue(),element=cell.getElement(),maxStars=formatterParams&&formatterParams.stars?formatterParams.stars:5,stars=document.createElement("span"),star=document.createElementNS('http://www.w3.org/2000/svg',"svg"),starActive='<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>',starInactive='<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';//style stars holder
stars.style.verticalAlign="middle";//style star
star.setAttribute("width","14");star.setAttribute("height","14");star.setAttribute("viewBox","0 0 512 512");star.setAttribute("xml:space","preserve");star.style.padding="0 1px";value=parseInt(value)<maxStars?parseInt(value):maxStars;for(var i=1;i<=maxStars;i++){var nextStar=star.cloneNode(true);nextStar.innerHTML=i<=value?starActive:starInactive;stars.appendChild(nextStar);}element.style.whiteSpace="nowrap";element.style.overflow="hidden";element.style.textOverflow="ellipsis";element.setAttribute("aria-label",value);return stars;},traffic:function traffic(cell,formatterParams,onRendered){var value=this.sanitizeHTML(cell.getValue())||0,el=document.createElement("span"),max=formatterParams&&formatterParams.max?formatterParams.max:100,min=formatterParams&&formatterParams.min?formatterParams.min:0,colors=formatterParams&&typeof formatterParams.color!=="undefined"?formatterParams.color:["red","orange","green"],color="#666666",percent,percentValue;if(isNaN(value)||typeof cell.getValue()==="undefined"){return;}el.classList.add("tabulator-traffic-light");//make sure value is in range
percentValue=parseFloat(value)<=max?parseFloat(value):max;percentValue=parseFloat(percentValue)>=min?parseFloat(percentValue):min;//workout percentage
percent=(max-min)/100;percentValue=Math.round((percentValue-min)/percent);//set color
switch(typeof colors==='undefined'?'undefined':_typeof(colors)){case"string":color=colors;break;case"function":color=colors(value);break;case"object":if(Array.isArray(colors)){var unit=100/colors.length;var index=Math.floor(percentValue/unit);index=Math.min(index,colors.length-1);index=Math.max(index,0);color=colors[index];break;}}el.style.backgroundColor=color;return el;},//progress bar
progress:function progress(cell,formatterParams,onRendered){//progress bar
var value=this.sanitizeHTML(cell.getValue())||0,element=cell.getElement(),max=formatterParams&&formatterParams.max?formatterParams.max:100,min=formatterParams&&formatterParams.min?formatterParams.min:0,legendAlign=formatterParams&&formatterParams.legendAlign?formatterParams.legendAlign:"center",percent,percentValue,color,legend,legendColor,top,left,right,bottom;//make sure value is in range
percentValue=parseFloat(value)<=max?parseFloat(value):max;percentValue=parseFloat(percentValue)>=min?parseFloat(percentValue):min;//workout percentage
percent=(max-min)/100;percentValue=Math.round((percentValue-min)/percent);//set bar color
switch(_typeof(formatterParams.color)){case"string":color=formatterParams.color;break;case"function":color=formatterParams.color(value);break;case"object":if(Array.isArray(formatterParams.color)){var unit=100/formatterParams.color.length;var index=Math.floor(percentValue/unit);index=Math.min(index,formatterParams.color.length-1);index=Math.max(index,0);color=formatterParams.color[index];break;}default:color="#2DC214";}//generate legend
switch(_typeof(formatterParams.legend)){case"string":legend=formatterParams.legend;break;case"function":legend=formatterParams.legend(value);break;case"boolean":legend=value;break;default:legend=false;}//set legend color
switch(_typeof(formatterParams.legendColor)){case"string":legendColor=formatterParams.legendColor;break;case"function":legendColor=formatterParams.legendColor(value);break;case"object":if(Array.isArray(formatterParams.legendColor)){var unit=100/formatterParams.legendColor.length;var index=Math.floor(percentValue/unit);index=Math.min(index,formatterParams.legendColor.length-1);index=Math.max(index,0);legendColor=formatterParams.legendColor[index];}break;default:legendColor="#000";}element.style.minWidth="30px";element.style.position="relative";element.setAttribute("aria-label",percentValue);return"<div style='position:absolute; top:8px; bottom:8px; left:4px; right:4px;'  data-max='"+max+"' data-min='"+min+"'><div style='position:relative; height:100%; width:calc("+percentValue+"%); background-color:"+color+"; display:inline-block;'></div></div>"+(legend?"<div style='position:absolute; top:4px; left:0; text-align:"+legendAlign+"; width:100%; color:"+legendColor+";'>"+legend+"</div>":"");},//background color
color:function color(cell,formatterParams,onRendered){cell.getElement().style.backgroundColor=this.sanitizeHTML(cell.getValue());return"";},//tick icon
buttonTick:function buttonTick(cell,formatterParams,onRendered){return'<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';},//cross icon
buttonCross:function buttonCross(cell,formatterParams,onRendered){return'<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';},//current row number
rownum:function rownum(cell,formatterParams,onRendered){return this.table.rowManager.activeRows.indexOf(cell.getRow()._getSelf())+1;},//row handle
handle:function handle(cell,formatterParams,onRendered){cell.getElement().classList.add("tabulator-row-handle");return"<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";},responsiveCollapse:function responsiveCollapse(cell,formatterParams,onRendered){var self=this,open=false,el=document.createElement("div");function toggleList(isOpen){var collapse=cell.getRow().getElement().getElementsByClassName("tabulator-responsive-collapse")[0];open=isOpen;if(open){el.classList.add("open");if(collapse){collapse.style.display='';}}else{el.classList.remove("open");if(collapse){collapse.style.display='none';}}}el.classList.add("tabulator-responsive-collapse-toggle");el.innerHTML="<span class='tabulator-responsive-collapse-toggle-open'>+</span><span class='tabulator-responsive-collapse-toggle-close'>-</span>";cell.getElement().classList.add("tabulator-row-handle");if(self.table.options.responsiveLayoutCollapseStartOpen){open=true;}el.addEventListener("click",function(e){e.stopImmediatePropagation();toggleList(!open);});toggleList(open);return el;}};Tabulator.prototype.registerModule("format",Format);var FrozenColumns=function FrozenColumns(table){this.table=table;//hold Tabulator object
this.leftColumns=[];this.rightColumns=[];this.leftMargin=0;this.rightMargin=0;this.initializationMode="left";this.active=false;};//reset initial state
FrozenColumns.prototype.reset=function(){this.initializationMode="left";this.leftColumns=[];this.rightColumns=[];this.active=false;};//initialize specific column
FrozenColumns.prototype.initializeColumn=function(column){var config={margin:0,edge:false};if(column.definition.frozen){if(!column.parent.isGroup){if(!column.isGroup){config.position=this.initializationMode;if(this.initializationMode=="left"){this.leftColumns.push(column);}else{this.rightColumns.unshift(column);}this.active=true;column.modules.frozen=config;}else{console.warn("Frozen Column Error - Column Groups cannot be frozen");}}else{console.warn("Frozen Column Error - Grouped columns cannot be frozen");}}else{this.initializationMode="right";}};//layout columns appropropriatly
FrozenColumns.prototype.layout=function(){var self=this,tableHolder=this.table.rowManager.element,rightMargin=0;if(self.active){//calculate row padding
self.leftMargin=self._calcSpace(self.leftColumns,self.leftColumns.length);self.table.columnManager.headersElement.style.marginLeft=self.leftMargin+"px";self.rightMargin=self._calcSpace(self.rightColumns,self.rightColumns.length);self.table.columnManager.element.style.paddingRight=self.rightMargin+"px";self.table.rowManager.activeRows.forEach(function(row){self.layoutRow(row);});if(self.table.options.dataTree){self.table.rowManager.getDisplayRows().forEach(function(row){self.layoutRow(row);});}if(self.table.modExists("columnCalcs")){if(self.table.modules.columnCalcs.topInitialized&&self.table.modules.columnCalcs.topRow){self.layoutRow(self.table.modules.columnCalcs.topRow);}if(self.table.modules.columnCalcs.botInitialized&&self.table.modules.columnCalcs.botRow){self.layoutRow(self.table.modules.columnCalcs.botRow);}}//calculate left columns
self.leftColumns.forEach(function(column,i){column.modules.frozen.margin=self._calcSpace(self.leftColumns,i)+self.table.columnManager.scrollLeft;if(i==self.leftColumns.length-1){column.modules.frozen.edge=true;}else{column.modules.frozen.edge=false;}self.layoutColumn(column);});//calculate right frozen columns
rightMargin=self.table.rowManager.element.clientWidth+self.table.columnManager.scrollLeft;// if(tableHolder.scrollHeight > tableHolder.clientHeight){
// 	rightMargin -= tableHolder.offsetWidth - tableHolder.clientWidth;
// }
self.rightColumns.forEach(function(column,i){column.modules.frozen.margin=rightMargin-self._calcSpace(self.rightColumns,i+1);if(i==self.rightColumns.length-1){column.modules.frozen.edge=true;}else{column.modules.frozen.edge=false;}self.layoutColumn(column);});this.table.rowManager.tableElement.style.marginRight=this.rightMargin+"px";}};FrozenColumns.prototype.layoutColumn=function(column){var self=this;self.layoutElement(column.getElement(),column);column.cells.forEach(function(cell){self.layoutElement(cell.getElement(),column);});};FrozenColumns.prototype.layoutRow=function(row){var rowEl=row.getElement();rowEl.style.paddingLeft=this.leftMargin+"px";// rowEl.style.paddingRight = this.rightMargin + "px";
};FrozenColumns.prototype.layoutElement=function(element,column){if(column.modules.frozen){element.style.position="absolute";element.style.left=column.modules.frozen.margin+"px";element.classList.add("tabulator-frozen");if(column.modules.frozen.edge){element.classList.add("tabulator-frozen-"+column.modules.frozen.position);}}};FrozenColumns.prototype._calcSpace=function(columns,index){var width=0;for(var i=0;i<index;i++){if(columns[i].visible){width+=columns[i].getWidth();}}return width;};Tabulator.prototype.registerModule("frozenColumns",FrozenColumns);var FrozenRows=function FrozenRows(table){this.table=table;//hold Tabulator object
this.topElement=document.createElement("div");this.rows=[];this.displayIndex=0;//index in display pipeline
};FrozenRows.prototype.initialize=function(){this.rows=[];this.topElement.classList.add("tabulator-frozen-rows-holder");// this.table.columnManager.element.append(this.topElement);
this.table.columnManager.getElement().insertBefore(this.topElement,this.table.columnManager.headersElement.nextSibling);};FrozenRows.prototype.setDisplayIndex=function(index){this.displayIndex=index;};FrozenRows.prototype.getDisplayIndex=function(){return this.displayIndex;};FrozenRows.prototype.isFrozen=function(){return!!this.rows.length;};//filter frozen rows out of display data
FrozenRows.prototype.getRows=function(rows){var self=this,frozen=[],output=rows.slice(0);this.rows.forEach(function(row){var index=output.indexOf(row);if(index>-1){output.splice(index,1);}});return output;};FrozenRows.prototype.freezeRow=function(row){if(!row.modules.frozen){row.modules.frozen=true;this.topElement.appendChild(row.getElement());row.initialize();row.normalizeHeight();this.table.rowManager.adjustTableSize();this.rows.push(row);this.table.rowManager.refreshActiveData("display");this.styleRows();}else{console.warn("Freeze Error - Row is already frozen");}};FrozenRows.prototype.unfreezeRow=function(row){var index=this.rows.indexOf(row);if(row.modules.frozen){row.modules.frozen=false;var rowEl=row.getElement();rowEl.parentNode.removeChild(rowEl);this.table.rowManager.adjustTableSize();this.rows.splice(index,1);this.table.rowManager.refreshActiveData("display");if(this.rows.length){this.styleRows();}}else{console.warn("Freeze Error - Row is already unfrozen");}};FrozenRows.prototype.styleRows=function(row){var self=this;this.rows.forEach(function(row,i){self.table.rowManager.styleRow(row,i);});};Tabulator.prototype.registerModule("frozenRows",FrozenRows);//public group object
var GroupComponent=function GroupComponent(group){this._group=group;this.type="GroupComponent";};GroupComponent.prototype.getKey=function(){return this._group.key;};GroupComponent.prototype.getElement=function(){return this._group.element;};GroupComponent.prototype.getRows=function(){return this._group.getRows(true);};GroupComponent.prototype.getSubGroups=function(){return this._group.getSubGroups(true);};GroupComponent.prototype.getParentGroup=function(){return this._group.parent?this._group.parent.getComponent():false;};GroupComponent.prototype.getVisibility=function(){return this._group.visible;};GroupComponent.prototype.show=function(){this._group.show();};GroupComponent.prototype.hide=function(){this._group.hide();};GroupComponent.prototype.toggle=function(){this._group.toggleVisibility();};GroupComponent.prototype._getSelf=function(){return this._group;};GroupComponent.prototype.getTable=function(){return this._group.groupManager.table;};//////////////////////////////////////////////////
//////////////// Group Functions /////////////////
//////////////////////////////////////////////////
var Group=function Group(groupManager,parent,level,key,field,generator,oldGroup){this.groupManager=groupManager;this.parent=parent;this.key=key;this.level=level;this.field=field;this.hasSubGroups=level<groupManager.groupIDLookups.length-1;this.addRow=this.hasSubGroups?this._addRowToGroup:this._addRow;this.type="group";//type of element
this.old=oldGroup;this.rows=[];this.groups=[];this.groupList=[];this.generator=generator;this.elementContents=false;this.height=0;this.outerHeight=0;this.initialized=false;this.calcs={};this.initialized=false;this.modules={};this.visible=oldGroup?oldGroup.visible:typeof groupManager.startOpen[level]!=="undefined"?groupManager.startOpen[level]:groupManager.startOpen[0];this.createElements();this.addBindings();this.createValueGroups();};Group.prototype.createElements=function(){this.element=document.createElement("div");this.element.classList.add("tabulator-row");this.element.classList.add("tabulator-group");this.element.classList.add("tabulator-group-level-"+this.level);this.element.setAttribute("role","rowgroup");this.arrowElement=document.createElement("div");this.arrowElement.classList.add("tabulator-arrow");//setup movable rows
if(this.groupManager.table.options.movableRows!==false&&this.groupManager.table.modExists("moveRow")){this.groupManager.table.modules.moveRow.initializeGroupHeader(this);}};Group.prototype.createValueGroups=function(){var _this34=this;var level=this.level+1;if(this.groupManager.allowedValues&&this.groupManager.allowedValues[level]){this.groupManager.allowedValues[level].forEach(function(value){_this34._createGroup(value,level);});}};Group.prototype.addBindings=function(){var self=this,dblTap,tapHold,tap,toggleElement;//handle group click events
if(self.groupManager.table.options.groupClick){self.element.addEventListener("click",function(e){self.groupManager.table.options.groupClick(e,self.getComponent());});}if(self.groupManager.table.options.groupDblClick){self.element.addEventListener("dblclick",function(e){self.groupManager.table.options.groupDblClick(e,self.getComponent());});}if(self.groupManager.table.options.groupContext){self.element.addEventListener("contextmenu",function(e){self.groupManager.table.options.groupContext(e,self.getComponent());});}if(self.groupManager.table.options.groupTap){tap=false;self.element.addEventListener("touchstart",function(e){tap=true;});self.element.addEventListener("touchend",function(e){if(tap){self.groupManager.table.options.groupTap(e,self.getComponent());}tap=false;});}if(self.groupManager.table.options.groupDblTap){dblTap=null;self.element.addEventListener("touchend",function(e){if(dblTap){clearTimeout(dblTap);dblTap=null;self.groupManager.table.options.groupDblTap(e,self.getComponent());}else{dblTap=setTimeout(function(){clearTimeout(dblTap);dblTap=null;},300);}});}if(self.groupManager.table.options.groupTapHold){tapHold=null;self.element.addEventListener("touchstart",function(e){clearTimeout(tapHold);tapHold=setTimeout(function(){clearTimeout(tapHold);tapHold=null;tap=false;self.groupManager.table.options.groupTapHold(e,self.getComponent());},1000);});self.element.addEventListener("touchend",function(e){clearTimeout(tapHold);tapHold=null;});}if(self.groupManager.table.options.groupToggleElement){toggleElement=self.groupManager.table.options.groupToggleElement=="arrow"?self.arrowElement:self.element;toggleElement.addEventListener("click",function(e){e.stopPropagation();e.stopImmediatePropagation();self.toggleVisibility();});}};Group.prototype._createGroup=function(groupID,level){var groupKey=level+"_"+groupID;var group=new Group(this.groupManager,this,level,groupID,this.groupManager.groupIDLookups[level].field,this.groupManager.headerGenerator[level]||this.groupManager.headerGenerator[0],this.old?this.old.groups[groupKey]:false);this.groups[groupKey]=group;this.groupList.push(group);};Group.prototype._addRowToGroup=function(row){var level=this.level+1;if(this.hasSubGroups){var groupID=this.groupManager.groupIDLookups[level].func(row.getData()),groupKey=level+"_"+groupID;if(this.groupManager.allowedValues&&this.groupManager.allowedValues[level]){if(this.groups[groupKey]){this.groups[groupKey].addRow(row);}}else{if(!this.groups[groupKey]){this._createGroup(groupID,level);}this.groups[groupKey].addRow(row);}}};Group.prototype._addRow=function(row){this.rows.push(row);row.modules.group=this;};Group.prototype.insertRow=function(row,to,after){var data=this.conformRowData({});row.updateData(data);var toIndex=this.rows.indexOf(to);if(toIndex>-1){if(after){this.rows.splice(toIndex+1,0,row);}else{this.rows.splice(toIndex,0,row);}}else{if(after){this.rows.push(row);}else{this.rows.unshift(row);}}row.modules.group=this;this.generateGroupHeaderContents();if(this.groupManager.table.modExists("columnCalcs")&&this.groupManager.table.options.columnCalcs!="table"){this.groupManager.table.modules.columnCalcs.recalcGroup(this);}};Group.prototype.getRowIndex=function(row){};//update row data to match grouping contraints
Group.prototype.conformRowData=function(data){if(this.field){data[this.field]=this.key;}else{console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function");}if(this.parent){data=this.parent.conformRowData(data);}return data;};Group.prototype.removeRow=function(row){var index=this.rows.indexOf(row);if(index>-1){this.rows.splice(index,1);}if(!this.groupManager.table.options.groupValues&&!this.rows.length){if(this.parent){this.parent.removeGroup(this);}else{this.groupManager.removeGroup(this);}this.groupManager.updateGroupRows(true);}else{this.generateGroupHeaderContents();if(this.groupManager.table.modExists("columnCalcs")&&this.groupManager.table.options.columnCalcs!="table"){this.groupManager.table.modules.columnCalcs.recalcGroup(this);}}};Group.prototype.removeGroup=function(group){var groupKey=group.level+"_"+group.key,index;if(this.groups[groupKey]){delete this.groups[groupKey];index=this.groupList.indexOf(group);if(index>-1){this.groupList.splice(index,1);}if(!this.groupList.length){if(this.parent){this.parent.removeGroup(this);}else{this.groupManager.removeGroup(this);}}}};Group.prototype.getHeadersAndRows=function(noCalc){var output=[];output.push(this);this._visSet();if(this.visible){if(this.groupList.length){this.groupList.forEach(function(group){output=output.concat(group.getHeadersAndRows(noCalc));});}else{if(!noCalc&&this.groupManager.table.options.columnCalcs!="table"&&this.groupManager.table.modExists("columnCalcs")&&this.groupManager.table.modules.columnCalcs.hasTopCalcs()){if(this.calcs.top){this.calcs.top.detachElement();}this.calcs.top=this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);output.push(this.calcs.top);}output=output.concat(this.rows);if(!noCalc&&this.groupManager.table.options.columnCalcs!="table"&&this.groupManager.table.modExists("columnCalcs")&&this.groupManager.table.modules.columnCalcs.hasBottomCalcs()){if(this.calcs.bottom){this.calcs.bottom.detachElement();}this.calcs.bottom=this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);output.push(this.calcs.bottom);}}}else{if(!this.groupList.length&&this.groupManager.table.options.columnCalcs!="table"&&this.groupManager.table.options.groupClosedShowCalcs){if(this.groupManager.table.modExists("columnCalcs")){if(!noCalc&&this.groupManager.table.modules.columnCalcs.hasTopCalcs()){if(this.calcs.top){this.calcs.top.detachElement();}this.calcs.top=this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);output.push(this.calcs.top);}if(!noCalc&&this.groupManager.table.modules.columnCalcs.hasBottomCalcs()){if(this.calcs.bottom){this.calcs.bottom.detachElement();}this.calcs.bottom=this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);output.push(this.calcs.bottom);}}}}return output;};Group.prototype.getData=function(visible,transform){var self=this,output=[];this._visSet();if(!visible||visible&&this.visible){this.rows.forEach(function(row){output.push(row.getData(transform||"data"));});}return output;};// Group.prototype.getRows = function(){
// 	this._visSet();
// 	return this.visible ? this.rows : [];
// };
Group.prototype.getRowCount=function(){var count=0;if(this.groupList.length){this.groupList.forEach(function(group){count+=group.getRowCount();});}else{count=this.rows.length;}return count;};Group.prototype.toggleVisibility=function(){if(this.visible){this.hide();}else{this.show();}};Group.prototype.hide=function(){this.visible=false;if(this.groupManager.table.rowManager.getRenderMode()=="classic"&&!this.groupManager.table.options.pagination){this.element.classList.remove("tabulator-group-visible");if(this.groupList.length){this.groupList.forEach(function(group){var rows=group.getHeadersAndRows();rows.forEach(function(row){row.detachElement();});});}else{this.rows.forEach(function(row){var rowEl=row.getElement();rowEl.parentNode.removeChild(rowEl);});}this.groupManager.table.rowManager.setDisplayRows(this.groupManager.updateGroupRows(),this.groupManager.getDisplayIndex());this.groupManager.table.rowManager.checkClassicModeGroupHeaderWidth();}else{this.groupManager.updateGroupRows(true);}this.groupManager.table.options.groupVisibilityChanged.call(this.table,this.getComponent(),false);};Group.prototype.show=function(){var self=this;self.visible=true;if(this.groupManager.table.rowManager.getRenderMode()=="classic"&&!this.groupManager.table.options.pagination){this.element.classList.add("tabulator-group-visible");var prev=self.getElement();if(this.groupList.length){this.groupList.forEach(function(group){var rows=group.getHeadersAndRows();rows.forEach(function(row){var rowEl=row.getElement();prev.parentNode.insertBefore(rowEl,prev.nextSibling);row.initialize();prev=rowEl;});});}else{self.rows.forEach(function(row){var rowEl=row.getElement();prev.parentNode.insertBefore(rowEl,prev.nextSibling);row.initialize();prev=rowEl;});}this.groupManager.table.rowManager.setDisplayRows(this.groupManager.updateGroupRows(),this.groupManager.getDisplayIndex());this.groupManager.table.rowManager.checkClassicModeGroupHeaderWidth();}else{this.groupManager.updateGroupRows(true);}this.groupManager.table.options.groupVisibilityChanged.call(this.table,this.getComponent(),true);};Group.prototype._visSet=function(){var data=[];if(typeof this.visible=="function"){this.rows.forEach(function(row){data.push(row.getData());});this.visible=this.visible(this.key,this.getRowCount(),data,this.getComponent());}};Group.prototype.getRowGroup=function(row){var match=false;if(this.groupList.length){this.groupList.forEach(function(group){var result=group.getRowGroup(row);if(result){match=result;}});}else{if(this.rows.find(function(item){return item===row;})){match=this;}}return match;};Group.prototype.getSubGroups=function(component){var output=[];this.groupList.forEach(function(child){output.push(component?child.getComponent():child);});return output;};Group.prototype.getRows=function(compoment){var output=[];this.rows.forEach(function(row){output.push(compoment?row.getComponent():row);});return output;};Group.prototype.generateGroupHeaderContents=function(){var data=[];this.rows.forEach(function(row){data.push(row.getData());});this.elementContents=this.generator(this.key,this.getRowCount(),data,this.getComponent());while(this.element.firstChild){this.element.removeChild(this.element.firstChild);}if(typeof this.elementContents==="string"){this.element.innerHTML=this.elementContents;}else{this.element.appendChild(this.elementContents);}this.element.insertBefore(this.arrowElement,this.element.firstChild);};////////////// Standard Row Functions //////////////
Group.prototype.getElement=function(){this.addBindingsd=false;this._visSet();if(this.visible){this.element.classList.add("tabulator-group-visible");}else{this.element.classList.remove("tabulator-group-visible");}for(var i=0;i<this.element.childNodes.length;++i){this.element.childNodes[i].parentNode.removeChild(this.element.childNodes[i]);}this.generateGroupHeaderContents();// this.addBindings();
return this.element;};Group.prototype.detachElement=function(){if(this.element&&this.element.parentNode){this.element.parentNode.removeChild(this.element);}};//normalize the height of elements in the row
Group.prototype.normalizeHeight=function(){this.setHeight(this.element.clientHeight);};Group.prototype.initialize=function(force){if(!this.initialized||force){this.normalizeHeight();this.initialized=true;}};Group.prototype.reinitialize=function(){this.initialized=false;this.height=0;if(Tabulator.prototype.helpers.elVisible(this.element)){this.initialize(true);}};Group.prototype.setHeight=function(height){if(this.height!=height){this.height=height;this.outerHeight=this.element.offsetHeight;}};//return rows outer height
Group.prototype.getHeight=function(){return this.outerHeight;};Group.prototype.getGroup=function(){return this;};Group.prototype.reinitializeHeight=function(){};Group.prototype.calcHeight=function(){};Group.prototype.setCellHeight=function(){};Group.prototype.clearCellHeight=function(){};//////////////// Object Generation /////////////////
Group.prototype.getComponent=function(){return new GroupComponent(this);};//////////////////////////////////////////////////
////////////// Group Row Extension ///////////////
//////////////////////////////////////////////////
var GroupRows=function GroupRows(table){this.table=table;//hold Tabulator object
this.groupIDLookups=false;//enable table grouping and set field to group by
this.startOpen=[function(){return false;}];//starting state of group
this.headerGenerator=[function(){return"";}];this.groupList=[];//ordered list of groups
this.allowedValues=false;this.groups={};//hold row groups
this.displayIndex=0;//index in display pipeline
};//initialize group configuration
GroupRows.prototype.initialize=function(){var self=this,groupBy=self.table.options.groupBy,startOpen=self.table.options.groupStartOpen,groupHeader=self.table.options.groupHeader;this.allowedValues=self.table.options.groupValues;self.headerGenerator=[function(){return"";}];this.startOpen=[function(){return false;}];//starting state of group
self.table.modules.localize.bind("groups|item",function(langValue,lang){self.headerGenerator[0]=function(value,count,data){//header layout function
return(typeof value==="undefined"?"":value)+"<span>("+count+" "+(count===1?langValue:lang.groups.items)+")</span>";};});this.groupIDLookups=[];if(Array.isArray(groupBy)||groupBy){if(this.table.modExists("columnCalcs")&&this.table.options.columnCalcs!="table"&&this.table.options.columnCalcs!="both"){this.table.modules.columnCalcs.removeCalcs();}}else{if(this.table.modExists("columnCalcs")&&this.table.options.columnCalcs!="group"){var cols=this.table.columnManager.getRealColumns();cols.forEach(function(col){if(col.definition.topCalc){self.table.modules.columnCalcs.initializeTopRow();}if(col.definition.bottomCalc){self.table.modules.columnCalcs.initializeBottomRow();}});}}if(!Array.isArray(groupBy)){groupBy=[groupBy];}groupBy.forEach(function(group,i){var lookupFunc,column;if(typeof group=="function"){lookupFunc=group;}else{column=self.table.columnManager.getColumnByField(group);if(column){lookupFunc=function lookupFunc(data){return column.getFieldValue(data);};}else{lookupFunc=function lookupFunc(data){return data[group];};}}self.groupIDLookups.push({field:typeof group==="function"?false:group,func:lookupFunc,values:self.allowedValues?self.allowedValues[i]:false});});if(startOpen){if(!Array.isArray(startOpen)){startOpen=[startOpen];}startOpen.forEach(function(level){level=typeof level=="function"?level:function(){return true;};});self.startOpen=startOpen;}if(groupHeader){self.headerGenerator=Array.isArray(groupHeader)?groupHeader:[groupHeader];}this.initialized=true;};GroupRows.prototype.setDisplayIndex=function(index){this.displayIndex=index;};GroupRows.prototype.getDisplayIndex=function(){return this.displayIndex;};//return appropriate rows with group headers
GroupRows.prototype.getRows=function(rows){if(this.groupIDLookups.length){this.table.options.dataGrouping.call(this.table);this.generateGroups(rows);if(this.table.options.dataGrouped){this.table.options.dataGrouped.call(this.table,this.getGroups(true));}return this.updateGroupRows();}else{return rows.slice(0);}};GroupRows.prototype.getGroups=function(compoment){var groupComponents=[];this.groupList.forEach(function(group){groupComponents.push(compoment?group.getComponent():group);});return groupComponents;};GroupRows.prototype.pullGroupListData=function(groupList){var self=this;var groupListData=[];groupList.forEach(function(group){var groupHeader={};groupHeader.level=0;groupHeader.rowCount=0;groupHeader.headerContent="";var childData=[];if(group.hasSubGroups){childData=self.pullGroupListData(group.groupList);groupHeader.level=group.level;groupHeader.rowCount=childData.length-group.groupList.length;// data length minus number of sub-headers
groupHeader.headerContent=group.generator(group.key,groupHeader.rowCount,group.rows,group);groupListData.push(groupHeader);groupListData=groupListData.concat(childData);}else{groupHeader.level=group.level;groupHeader.headerContent=group.generator(group.key,group.rows.length,group.rows,group);groupHeader.rowCount=group.getRows().length;groupListData.push(groupHeader);group.getRows().forEach(function(row){groupListData.push(row.getData("data"));});}});return groupListData;};GroupRows.prototype.getGroupedData=function(){return this.pullGroupListData(this.groupList);};GroupRows.prototype.getRowGroup=function(row){var match=false;this.groupList.forEach(function(group){var result=group.getRowGroup(row);if(result){match=result;}});return match;};GroupRows.prototype.countGroups=function(){return this.groupList.length;};GroupRows.prototype.generateGroups=function(rows){var self=this,oldGroups=self.groups;self.groups={};self.groupList=[];if(this.allowedValues&&this.allowedValues[0]){this.allowedValues[0].forEach(function(value){self.createGroup(value,0,oldGroups);});rows.forEach(function(row){self.assignRowToExistingGroup(row,oldGroups);});}else{rows.forEach(function(row){self.assignRowToGroup(row,oldGroups);});}};GroupRows.prototype.createGroup=function(groupID,level,oldGroups){var groupKey=level+"_"+groupID,group;oldGroups=oldGroups||[];group=new Group(this,false,level,groupID,this.groupIDLookups[0].field,this.headerGenerator[0],oldGroups[groupKey]);this.groups[groupKey]=group;this.groupList.push(group);};GroupRows.prototype.assignRowToGroup=function(row,oldGroups){var groupID=this.groupIDLookups[0].func(row.getData()),groupKey="0_"+groupID;if(!this.groups[groupKey]){this.createGroup(groupID,0,oldGroups);}this.groups[groupKey].addRow(row);};GroupRows.prototype.assignRowToExistingGroup=function(row,oldGroups){var groupID=this.groupIDLookups[0].func(row.getData()),groupKey="0_"+groupID;if(this.groups[groupKey]){this.groups[groupKey].addRow(row);}};GroupRows.prototype.assignRowToGroup=function(row,oldGroups){var groupID=this.groupIDLookups[0].func(row.getData()),newGroupNeeded=!this.groups["0_"+groupID];if(newGroupNeeded){this.createGroup(groupID,0,oldGroups);}this.groups["0_"+groupID].addRow(row);return!newGroupNeeded;};GroupRows.prototype.updateGroupRows=function(force){var self=this,output=[],oldRowCount;self.groupList.forEach(function(group){output=output.concat(group.getHeadersAndRows());});//force update of table display
if(force){var displayIndex=self.table.rowManager.setDisplayRows(output,this.getDisplayIndex());if(displayIndex!==true){this.setDisplayIndex(displayIndex);}self.table.rowManager.refreshActiveData("group",true,true);}return output;};GroupRows.prototype.scrollHeaders=function(left){this.groupList.forEach(function(group){group.arrowElement.style.marginLeft=left+"px";});};GroupRows.prototype.removeGroup=function(group){var groupKey=group.level+"_"+group.key,index;if(this.groups[groupKey]){delete this.groups[groupKey];index=this.groupList.indexOf(group);if(index>-1){this.groupList.splice(index,1);}}};Tabulator.prototype.registerModule("groupRows",GroupRows);var History=function History(table){this.table=table;//hold Tabulator object
this.history=[];this.index=-1;};History.prototype.clear=function(){this.history=[];this.index=-1;};History.prototype.action=function(type,component,data){this.history=this.history.slice(0,this.index+1);this.history.push({type:type,component:component,data:data});this.index++;};History.prototype.getHistoryUndoSize=function(){return this.index+1;};History.prototype.getHistoryRedoSize=function(){return this.history.length-(this.index+1);};History.prototype.undo=function(){if(this.index>-1){var action=this.history[this.index];this.undoers[action.type].call(this,action);this.index--;this.table.options.historyUndo.call(this.table,action.type,action.component.getComponent(),action.data);return true;}else{console.warn("History Undo Error - No more history to undo");return false;}};History.prototype.redo=function(){if(this.history.length-1>this.index){this.index++;var action=this.history[this.index];this.redoers[action.type].call(this,action);this.table.options.historyRedo.call(this.table,action.type,action.component.getComponent(),action.data);return true;}else{console.warn("History Redo Error - No more history to redo");return false;}};History.prototype.undoers={cellEdit:function cellEdit(action){action.component.setValueProcessData(action.data.oldValue);},rowAdd:function rowAdd(action){action.component.deleteActual();},rowDelete:function rowDelete(action){var newRow=this.table.rowManager.addRowActual(action.data.data,action.data.pos,action.data.index);this._rebindRow(action.component,newRow);},rowMove:function rowMove(action){this.table.rowManager.moveRowActual(action.component,this.table.rowManager.rows[action.data.pos],false);this.table.rowManager.redraw();}};History.prototype.redoers={cellEdit:function cellEdit(action){action.component.setValueProcessData(action.data.newValue);},rowAdd:function rowAdd(action){var newRow=this.table.rowManager.addRowActual(action.data.data,action.data.pos,action.data.index);this._rebindRow(action.component,newRow);},rowDelete:function rowDelete(action){action.component.deleteActual();},rowMove:function rowMove(action){this.table.rowManager.moveRowActual(action.component,this.table.rowManager.rows[action.data.pos],false);this.table.rowManager.redraw();}};//rebind rows to new element after deletion
History.prototype._rebindRow=function(oldRow,newRow){this.history.forEach(function(action){if(action.component instanceof Row){if(action.component===oldRow){action.component=newRow;}}else if(action.component instanceof Cell){if(action.component.row===oldRow){var field=action.component.column.getField();if(field){action.component=newRow.getCell(field);}}}});};Tabulator.prototype.registerModule("history",History);var HtmlTableImport=function HtmlTableImport(table){this.table=table;//hold Tabulator object
this.fieldIndex=[];this.hasIndex=false;};HtmlTableImport.prototype.parseTable=function(){var self=this,element=self.table.element,options=self.table.options,columns=options.columns,headers=element.getElementsByTagName("th"),rows=element.getElementsByTagName("tbody")[0],data=[],newTable;self.hasIndex=false;self.table.options.htmlImporting.call(this.table);rows=rows?rows.getElementsByTagName("tr"):[];//check for tablator inline options
self._extractOptions(element,options);if(headers.length){self._extractHeaders(headers,rows);}else{self._generateBlankHeaders(headers,rows);}//iterate through table rows and build data set
for(var index=0;index<rows.length;index++){var row=rows[index],cells=row.getElementsByTagName("td"),item={};//create index if the dont exist in table
if(!self.hasIndex){item[options.index]=index;}for(var i=0;i<cells.length;i++){var cell=cells[i];if(typeof this.fieldIndex[i]!=="undefined"){item[this.fieldIndex[i]]=cell.innerHTML;}}//add row data to item
data.push(item);}//create new element
var newElement=document.createElement("div");//transfer attributes to new element
var attributes=element.attributes;// loop through attributes and apply them on div
for(var i in attributes){if(_typeof(attributes[i])=="object"){newElement.setAttribute(attributes[i].name,attributes[i].value);}}// replace table with div element
element.parentNode.replaceChild(newElement,element);options.data=data;self.table.options.htmlImported.call(this.table);// // newElement.tabulator(options);
this.table.element=newElement;};//extract tabulator attribute options
HtmlTableImport.prototype._extractOptions=function(element,options,defaultOptions){var attributes=element.attributes;var optionsArr=defaultOptions?Object.assign([],defaultOptions):Object.keys(options);var optionsList={};optionsArr.forEach(function(item){optionsList[item.toLowerCase()]=item;});for(var index in attributes){var attrib=attributes[index];var name;if(attrib&&(typeof attrib==='undefined'?'undefined':_typeof(attrib))=="object"&&attrib.name&&attrib.name.indexOf("tabulator-")===0){name=attrib.name.replace("tabulator-","");if(typeof optionsList[name]!=="undefined"){options[optionsList[name]]=this._attribValue(attrib.value);}}}};//get value of attribute
HtmlTableImport.prototype._attribValue=function(value){if(value==="true"){return true;}if(value==="false"){return false;}return value;};//find column if it has already been defined
HtmlTableImport.prototype._findCol=function(title){var match=this.table.options.columns.find(function(column){return column.title===title;});return match||false;};//extract column from headers
HtmlTableImport.prototype._extractHeaders=function(headers,rows){for(var index=0;index<headers.length;index++){var header=headers[index],exists=false,col=this._findCol(header.textContent),width,attributes;if(col){exists=true;}else{col={title:header.textContent.trim()};}if(!col.field){col.field=header.textContent.trim().toLowerCase().replace(" ","_");}width=header.getAttribute("width");if(width&&!col.width){col.width=width;}//check for tablator inline options
attributes=header.attributes;// //check for tablator inline options
this._extractOptions(header,col,Column.prototype.defaultOptionList);for(var i in attributes){var attrib=attributes[i],name;if(attrib&&(typeof attrib==='undefined'?'undefined':_typeof(attrib))=="object"&&attrib.name&&attrib.name.indexOf("tabulator-")===0){name=attrib.name.replace("tabulator-","");col[name]=this._attribValue(attrib.value);}}this.fieldIndex[index]=col.field;if(col.field==this.table.options.index){this.hasIndex=true;}if(!exists){this.table.options.columns.push(col);}}};//generate blank headers
HtmlTableImport.prototype._generateBlankHeaders=function(headers,rows){for(var index=0;index<headers.length;index++){var header=headers[index],col={title:"",field:"col"+index};this.fieldIndex[index]=col.field;var width=header.getAttribute("width");if(width){col.width=width;}this.table.options.columns.push(col);}};Tabulator.prototype.registerModule("htmlTableImport",HtmlTableImport);var Keybindings=function Keybindings(table){this.table=table;//hold Tabulator object
this.watchKeys=null;this.pressedKeys=null;this.keyupBinding=false;this.keydownBinding=false;};Keybindings.prototype.initialize=function(){var bindings=this.table.options.keybindings,mergedBindings={};this.watchKeys={};this.pressedKeys=[];if(bindings!==false){for(var key in this.bindings){mergedBindings[key]=this.bindings[key];}if(Object.keys(bindings).length){for(var _key in bindings){mergedBindings[_key]=bindings[_key];}}this.mapBindings(mergedBindings);this.bindEvents();}};Keybindings.prototype.mapBindings=function(bindings){var _this35=this;var self=this;var _loop2=function _loop2(key){if(_this35.actions[key]){if(bindings[key]){if(_typeof(bindings[key])!=="object"){bindings[key]=[bindings[key]];}bindings[key].forEach(function(binding){self.mapBinding(key,binding);});}}else{console.warn("Key Binding Error - no such action:",key);}};for(var key in bindings){_loop2(key);}};Keybindings.prototype.mapBinding=function(action,symbolsList){var self=this;var binding={action:this.actions[action],keys:[],ctrl:false,shift:false};var symbols=symbolsList.toString().toLowerCase().split(" ").join("").split("+");symbols.forEach(function(symbol){switch(symbol){case"ctrl":binding.ctrl=true;break;case"shift":binding.shift=true;break;default:symbol=parseInt(symbol);binding.keys.push(symbol);if(!self.watchKeys[symbol]){self.watchKeys[symbol]=[];}self.watchKeys[symbol].push(binding);}});};Keybindings.prototype.bindEvents=function(){var self=this;this.keyupBinding=function(e){var code=e.keyCode;var bindings=self.watchKeys[code];if(bindings){self.pressedKeys.push(code);bindings.forEach(function(binding){self.checkBinding(e,binding);});}};this.keydownBinding=function(e){var code=e.keyCode;var bindings=self.watchKeys[code];if(bindings){var index=self.pressedKeys.indexOf(code);if(index>-1){self.pressedKeys.splice(index,1);}}};this.table.element.addEventListener("keydown",this.keyupBinding);this.table.element.addEventListener("keyup",this.keydownBinding);};Keybindings.prototype.clearBindings=function(){if(this.keyupBinding){this.table.element.removeEventListener("keydown",this.keyupBinding);}if(this.keydownBinding){this.table.element.removeEventListener("keyup",this.keydownBinding);}};Keybindings.prototype.checkBinding=function(e,binding){var self=this,match=true;if(e.ctrlKey==binding.ctrl&&e.shiftKey==binding.shift){binding.keys.forEach(function(key){var index=self.pressedKeys.indexOf(key);if(index==-1){match=false;}});if(match){binding.action.call(self,e);}return true;}return false;};//default bindings
Keybindings.prototype.bindings={navPrev:"shift + 9",navNext:9,navUp:38,navDown:40,scrollPageUp:33,scrollPageDown:34,scrollToStart:36,scrollToEnd:35,undo:"ctrl + 90",redo:"ctrl + 89",copyToClipboard:"ctrl + 67"};//default actions
Keybindings.prototype.actions={keyBlock:function keyBlock(e){e.stopPropagation();e.preventDefault();},scrollPageUp:function scrollPageUp(e){var rowManager=this.table.rowManager,newPos=rowManager.scrollTop-rowManager.height,scrollMax=rowManager.element.scrollHeight;e.preventDefault();if(rowManager.displayRowsCount){if(newPos>=0){rowManager.element.scrollTop=newPos;}else{rowManager.scrollToRow(rowManager.getDisplayRows()[0]);}}this.table.element.focus();},scrollPageDown:function scrollPageDown(e){var rowManager=this.table.rowManager,newPos=rowManager.scrollTop+rowManager.height,scrollMax=rowManager.element.scrollHeight;e.preventDefault();if(rowManager.displayRowsCount){if(newPos<=scrollMax){rowManager.element.scrollTop=newPos;}else{rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount-1]);}}this.table.element.focus();},scrollToStart:function scrollToStart(e){var rowManager=this.table.rowManager;e.preventDefault();if(rowManager.displayRowsCount){rowManager.scrollToRow(rowManager.getDisplayRows()[0]);}this.table.element.focus();},scrollToEnd:function scrollToEnd(e){var rowManager=this.table.rowManager;e.preventDefault();if(rowManager.displayRowsCount){rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount-1]);}this.table.element.focus();},navPrev:function navPrev(e){var cell=false;if(this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(cell){e.preventDefault();cell.nav().prev();}}},navNext:function navNext(e){var cell=false;if(this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(cell){e.preventDefault();cell.nav().next();}}},navLeft:function navLeft(e){var cell=false;if(this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(cell){e.preventDefault();cell.nav().left();}}},navRight:function navRight(e){var cell=false;if(this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(cell){e.preventDefault();cell.nav().right();}}},navUp:function navUp(e){var cell=false;if(this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(cell){e.preventDefault();cell.nav().up();}}},navDown:function navDown(e){var cell=false;if(this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(cell){e.preventDefault();cell.nav().down();}}},undo:function undo(e){var cell=false;if(this.table.options.history&&this.table.modExists("history")&&this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(!cell){e.preventDefault();this.table.modules.history.undo();}}},redo:function redo(e){var cell=false;if(this.table.options.history&&this.table.modExists("history")&&this.table.modExists("edit")){cell=this.table.modules.edit.currentCell;if(!cell){e.preventDefault();this.table.modules.history.redo();}}},copyToClipboard:function copyToClipboard(e){if(!this.table.modules.edit.currentCell){if(this.table.modExists("clipboard",true)){this.table.modules.clipboard.copy(!this.table.options.selectable||this.table.options.selectable=="highlight"?"active":"selected",null,null,null,true);}}}};Tabulator.prototype.registerModule("keybindings",Keybindings);var MoveColumns=function MoveColumns(table){this.table=table;//hold Tabulator object
this.placeholderElement=this.createPlaceholderElement();this.hoverElement=false;//floating column header element
this.checkTimeout=false;//click check timeout holder
this.checkPeriod=250;//period to wait on mousedown to consider this a move and not a click
this.moving=false;//currently moving column
this.toCol=false;//destination column
this.toColAfter=false;//position of moving column relative to the desitnation column
this.startX=0;//starting position within header element
this.autoScrollMargin=40;//auto scroll on edge when within margin
this.autoScrollStep=5;//auto scroll distance in pixels
this.autoScrollTimeout=false;//auto scroll timeout
this.touchMove=false;this.moveHover=this.moveHover.bind(this);this.endMove=this.endMove.bind(this);};MoveColumns.prototype.createPlaceholderElement=function(){var el=document.createElement("div");el.classList.add("tabulator-col");el.classList.add("tabulator-col-placeholder");return el;};MoveColumns.prototype.initializeColumn=function(column){var self=this,config={},colEl;if(!column.modules.frozen){colEl=column.getElement();config.mousemove=function(e){if(column.parent===self.moving.parent){if((self.touchMove?e.touches[0].pageX:e.pageX)-Tabulator.prototype.helpers.elOffset(colEl).left+self.table.columnManager.element.scrollLeft>column.getWidth()/2){if(self.toCol!==column||!self.toColAfter){colEl.parentNode.insertBefore(self.placeholderElement,colEl.nextSibling);self.moveColumn(column,true);}}else{if(self.toCol!==column||self.toColAfter){colEl.parentNode.insertBefore(self.placeholderElement,colEl);self.moveColumn(column,false);}}}}.bind(self);colEl.addEventListener("mousedown",function(e){self.touchMove=false;if(e.which===1){self.checkTimeout=setTimeout(function(){self.startMove(e,column);},self.checkPeriod);}});colEl.addEventListener("mouseup",function(e){if(e.which===1){if(self.checkTimeout){clearTimeout(self.checkTimeout);}}});self.bindTouchEvents(column);}column.modules.moveColumn=config;};MoveColumns.prototype.bindTouchEvents=function(column){var self=this,colEl=column.getElement(),startXMove=false,//shifting center position of the cell
dir=false,currentCol,nextCol,prevCol,nextColWidth,prevColWidth,nextColWidthLast,prevColWidthLast;colEl.addEventListener("touchstart",function(e){self.checkTimeout=setTimeout(function(){self.touchMove=true;currentCol=column;nextCol=column.nextColumn();nextColWidth=nextCol?nextCol.getWidth()/2:0;prevCol=column.prevColumn();prevColWidth=prevCol?prevCol.getWidth()/2:0;nextColWidthLast=0;prevColWidthLast=0;startXMove=false;self.startMove(e,column);},self.checkPeriod);});colEl.addEventListener("touchmove",function(e){var halfCol,diff,moveToCol;if(self.moving){self.moveHover(e);if(!startXMove){startXMove=e.touches[0].pageX;}diff=e.touches[0].pageX-startXMove;if(diff>0){if(nextCol&&diff-nextColWidthLast>nextColWidth){moveToCol=nextCol;if(moveToCol!==column){startXMove=e.touches[0].pageX;moveToCol.getElement().parentNode.insertBefore(self.placeholderElement,moveToCol.getElement().nextSibling);self.moveColumn(moveToCol,true);}}}else{if(prevCol&&-diff-prevColWidthLast>prevColWidth){moveToCol=prevCol;if(moveToCol!==column){startXMove=e.touches[0].pageX;moveToCol.getElement().parentNode.insertBefore(self.placeholderElement,moveToCol.getElement());self.moveColumn(moveToCol,false);}}}if(moveToCol){currentCol=moveToCol;nextCol=moveToCol.nextColumn();nextColWidthLast=nextColWidth;nextColWidth=nextCol?nextCol.getWidth()/2:0;prevCol=moveToCol.prevColumn();prevColWidthLast=prevColWidth;prevColWidth=prevCol?prevCol.getWidth()/2:0;}}});colEl.addEventListener("touchend",function(e){if(self.checkTimeout){clearTimeout(self.checkTimeout);}if(self.moving){self.endMove(e);}});};MoveColumns.prototype.startMove=function(e,column){var element=column.getElement();this.moving=column;this.startX=(this.touchMove?e.touches[0].pageX:e.pageX)-Tabulator.prototype.helpers.elOffset(element).left;this.table.element.classList.add("tabulator-block-select");//create placeholder
this.placeholderElement.style.width=column.getWidth()+"px";this.placeholderElement.style.height=column.getHeight()+"px";element.parentNode.insertBefore(this.placeholderElement,element);element.parentNode.removeChild(element);//create hover element
this.hoverElement=element.cloneNode(true);this.hoverElement.classList.add("tabulator-moving");this.table.columnManager.getElement().appendChild(this.hoverElement);this.hoverElement.style.left="0";this.hoverElement.style.bottom="0";if(!this.touchMove){this._bindMouseMove();document.body.addEventListener("mousemove",this.moveHover);document.body.addEventListener("mouseup",this.endMove);}this.moveHover(e);};MoveColumns.prototype._bindMouseMove=function(){this.table.columnManager.columnsByIndex.forEach(function(column){if(column.modules.moveColumn.mousemove){column.getElement().addEventListener("mousemove",column.modules.moveColumn.mousemove);}});};MoveColumns.prototype._unbindMouseMove=function(){this.table.columnManager.columnsByIndex.forEach(function(column){if(column.modules.moveColumn.mousemove){column.getElement().removeEventListener("mousemove",column.modules.moveColumn.mousemove);}});};MoveColumns.prototype.moveColumn=function(column,after){var movingCells=this.moving.getCells();this.toCol=column;this.toColAfter=after;if(after){column.getCells().forEach(function(cell,i){var cellEl=cell.getElement();cellEl.parentNode.insertBefore(movingCells[i].getElement(),cellEl.nextSibling);});}else{column.getCells().forEach(function(cell,i){var cellEl=cell.getElement();cellEl.parentNode.insertBefore(movingCells[i].getElement(),cellEl);});}};MoveColumns.prototype.endMove=function(e){if(e.which===1||this.touchMove){this._unbindMouseMove();this.placeholderElement.parentNode.insertBefore(this.moving.getElement(),this.placeholderElement.nextSibling);this.placeholderElement.parentNode.removeChild(this.placeholderElement);this.hoverElement.parentNode.removeChild(this.hoverElement);this.table.element.classList.remove("tabulator-block-select");if(this.toCol){this.table.columnManager.moveColumn(this.moving,this.toCol,this.toColAfter);}this.moving=false;this.toCol=false;this.toColAfter=false;if(!this.touchMove){document.body.removeEventListener("mousemove",this.moveHover);document.body.removeEventListener("mouseup",this.endMove);}}};MoveColumns.prototype.moveHover=function(e){var self=this,columnHolder=self.table.columnManager.getElement(),scrollLeft=columnHolder.scrollLeft,xPos=(self.touchMove?e.touches[0].pageX:e.pageX)-Tabulator.prototype.helpers.elOffset(columnHolder).left+scrollLeft,scrollPos;self.hoverElement.style.left=xPos-self.startX+"px";if(xPos-scrollLeft<self.autoScrollMargin){if(!self.autoScrollTimeout){self.autoScrollTimeout=setTimeout(function(){scrollPos=Math.max(0,scrollLeft-5);self.table.rowManager.getElement().scrollLeft=scrollPos;self.autoScrollTimeout=false;},1);}}if(scrollLeft+columnHolder.clientWidth-xPos<self.autoScrollMargin){if(!self.autoScrollTimeout){self.autoScrollTimeout=setTimeout(function(){scrollPos=Math.min(columnHolder.clientWidth,scrollLeft+5);self.table.rowManager.getElement().scrollLeft=scrollPos;self.autoScrollTimeout=false;},1);}}};Tabulator.prototype.registerModule("moveColumn",MoveColumns);var MoveRows=function MoveRows(table){this.table=table;//hold Tabulator object
this.placeholderElement=this.createPlaceholderElement();this.hoverElement=false;//floating row header element
this.checkTimeout=false;//click check timeout holder
this.checkPeriod=150;//period to wait on mousedown to consider this a move and not a click
this.moving=false;//currently moving row
this.toRow=false;//destination row
this.toRowAfter=false;//position of moving row relative to the desitnation row
this.hasHandle=false;//row has handle instead of fully movable row
this.startY=0;//starting Y position within header element
this.startX=0;//starting X position within header element
this.moveHover=this.moveHover.bind(this);this.endMove=this.endMove.bind(this);this.tableRowDropEvent=false;this.touchMove=false;this.connection=false;this.connections=[];this.connectedTable=false;this.connectedRow=false;};MoveRows.prototype.createPlaceholderElement=function(){var el=document.createElement("div");el.classList.add("tabulator-row");el.classList.add("tabulator-row-placeholder");return el;};MoveRows.prototype.initialize=function(handle){this.connection=this.table.options.movableRowsConnectedTables;};MoveRows.prototype.setHandle=function(handle){this.hasHandle=handle;};MoveRows.prototype.initializeGroupHeader=function(group){var self=this,config={},rowEl;//inter table drag drop
config.mouseup=function(e){self.tableRowDrop(e,row);}.bind(self);//same table drag drop
config.mousemove=function(e){if(e.pageY-Tabulator.prototype.helpers.elOffset(group.element).top+self.table.rowManager.element.scrollTop>group.getHeight()/2){if(self.toRow!==group||!self.toRowAfter){var rowEl=group.getElement();rowEl.parentNode.insertBefore(self.placeholderElement,rowEl.nextSibling);self.moveRow(group,true);}}else{if(self.toRow!==group||self.toRowAfter){var rowEl=group.getElement();if(rowEl.previousSibling){rowEl.parentNode.insertBefore(self.placeholderElement,rowEl);self.moveRow(group,false);}}}}.bind(self);group.modules.moveRow=config;};MoveRows.prototype.initializeRow=function(row){var self=this,config={},rowEl;//inter table drag drop
config.mouseup=function(e){self.tableRowDrop(e,row);}.bind(self);//same table drag drop
config.mousemove=function(e){if(e.pageY-Tabulator.prototype.helpers.elOffset(row.element).top+self.table.rowManager.element.scrollTop>row.getHeight()/2){if(self.toRow!==row||!self.toRowAfter){var rowEl=row.getElement();rowEl.parentNode.insertBefore(self.placeholderElement,rowEl.nextSibling);self.moveRow(row,true);}}else{if(self.toRow!==row||self.toRowAfter){var rowEl=row.getElement();rowEl.parentNode.insertBefore(self.placeholderElement,rowEl);self.moveRow(row,false);}}}.bind(self);if(!this.hasHandle){rowEl=row.getElement();rowEl.addEventListener("mousedown",function(e){if(e.which===1){self.checkTimeout=setTimeout(function(){self.startMove(e,row);},self.checkPeriod);}});rowEl.addEventListener("mouseup",function(e){if(e.which===1){if(self.checkTimeout){clearTimeout(self.checkTimeout);}}});this.bindTouchEvents(row,row.getElement());}row.modules.moveRow=config;};MoveRows.prototype.initializeCell=function(cell){var self=this,cellEl=cell.getElement();cellEl.addEventListener("mousedown",function(e){if(e.which===1){self.checkTimeout=setTimeout(function(){self.startMove(e,cell.row);},self.checkPeriod);}});cellEl.addEventListener("mouseup",function(e){if(e.which===1){if(self.checkTimeout){clearTimeout(self.checkTimeout);}}});this.bindTouchEvents(cell.row,cell.getElement());};MoveRows.prototype.bindTouchEvents=function(row,element){var self=this,startYMove=false,//shifting center position of the cell
dir=false,currentRow,nextRow,prevRow,nextRowHeight,prevRowHeight,nextRowHeightLast,prevRowHeightLast;element.addEventListener("touchstart",function(e){self.checkTimeout=setTimeout(function(){self.touchMove=true;currentRow=row;nextRow=row.nextRow();nextRowHeight=nextRow?nextRow.getHeight()/2:0;prevRow=row.prevRow();prevRowHeight=prevRow?prevRow.getHeight()/2:0;nextRowHeightLast=0;prevRowHeightLast=0;startYMove=false;self.startMove(e,row);},self.checkPeriod);});this.moving,this.toRow,this.toRowAfter;element.addEventListener("touchmove",function(e){var halfCol,diff,moveToRow;if(self.moving){e.preventDefault();self.moveHover(e);if(!startYMove){startYMove=e.touches[0].pageY;}diff=e.touches[0].pageY-startYMove;if(diff>0){if(nextRow&&diff-nextRowHeightLast>nextRowHeight){moveToRow=nextRow;if(moveToRow!==row){startYMove=e.touches[0].pageY;moveToRow.getElement().parentNode.insertBefore(self.placeholderElement,moveToRow.getElement().nextSibling);self.moveRow(moveToRow,true);}}}else{if(prevRow&&-diff-prevRowHeightLast>prevRowHeight){moveToRow=prevRow;if(moveToRow!==row){startYMove=e.touches[0].pageY;moveToRow.getElement().parentNode.insertBefore(self.placeholderElement,moveToRow.getElement());self.moveRow(moveToRow,false);}}}if(moveToRow){currentRow=moveToRow;nextRow=moveToRow.nextRow();nextRowHeightLast=nextRowHeight;nextRowHeight=nextRow?nextRow.getHeight()/2:0;prevRow=moveToRow.prevRow();prevRowHeightLast=prevRowHeight;prevRowHeight=prevRow?prevRow.getHeight()/2:0;}}});element.addEventListener("touchend",function(e){if(self.checkTimeout){clearTimeout(self.checkTimeout);}if(self.moving){self.endMove(e);self.touchMove=false;}});};MoveRows.prototype._bindMouseMove=function(){var self=this;self.table.rowManager.getDisplayRows().forEach(function(row){if((row.type==="row"||row.type==="group")&&row.modules.moveRow.mousemove){row.getElement().addEventListener("mousemove",row.modules.moveRow.mousemove);}});};MoveRows.prototype._unbindMouseMove=function(){var self=this;self.table.rowManager.getDisplayRows().forEach(function(row){if((row.type==="row"||row.type==="group")&&row.modules.moveRow.mousemove){row.getElement().removeEventListener("mousemove",row.modules.moveRow.mousemove);}});};MoveRows.prototype.startMove=function(e,row){var element=row.getElement();this.setStartPosition(e,row);this.moving=row;this.table.element.classList.add("tabulator-block-select");//create placeholder
this.placeholderElement.style.width=row.getWidth()+"px";this.placeholderElement.style.height=row.getHeight()+"px";if(!this.connection){element.parentNode.insertBefore(this.placeholderElement,element);element.parentNode.removeChild(element);}else{this.table.element.classList.add("tabulator-movingrow-sending");this.connectToTables(row);}//create hover element
this.hoverElement=element.cloneNode(true);this.hoverElement.classList.add("tabulator-moving");if(this.connection){document.body.appendChild(this.hoverElement);this.hoverElement.style.left="0";this.hoverElement.style.top="0";this.hoverElement.style.width=this.table.element.clientWidth+"px";this.hoverElement.style.whiteSpace="nowrap";this.hoverElement.style.overflow="hidden";this.hoverElement.style.pointerEvents="none";}else{this.table.rowManager.getTableElement().appendChild(this.hoverElement);this.hoverElement.style.left="0";this.hoverElement.style.top="0";this._bindMouseMove();}document.body.addEventListener("mousemove",this.moveHover);document.body.addEventListener("mouseup",this.endMove);this.moveHover(e);};MoveRows.prototype.setStartPosition=function(e,row){var pageX=this.touchMove?e.touches[0].pageX:e.pageX,pageY=this.touchMove?e.touches[0].pageY:e.pageY,element,position;element=row.getElement();if(this.connection){position=element.getBoundingClientRect();this.startX=position.left-pageX+window.scrollX;this.startY=position.top-pageY+window.scrollY;}else{this.startY=pageY-element.getBoundingClientRect().top;}};MoveRows.prototype.endMove=function(e){if(!e||e.which===1||this.touchMove){this._unbindMouseMove();if(!this.connection){this.placeholderElement.parentNode.insertBefore(this.moving.getElement(),this.placeholderElement.nextSibling);this.placeholderElement.parentNode.removeChild(this.placeholderElement);}this.hoverElement.parentNode.removeChild(this.hoverElement);this.table.element.classList.remove("tabulator-block-select");if(this.toRow){this.table.rowManager.moveRow(this.moving,this.toRow,this.toRowAfter);}this.moving=false;this.toRow=false;this.toRowAfter=false;document.body.removeEventListener("mousemove",this.moveHover);document.body.removeEventListener("mouseup",this.endMove);if(this.connection){this.table.element.classList.remove("tabulator-movingrow-sending");this.disconnectFromTables();}}};MoveRows.prototype.moveRow=function(row,after){this.toRow=row;this.toRowAfter=after;};MoveRows.prototype.moveHover=function(e){if(this.connection){this.moveHoverConnections.call(this,e);}else{this.moveHoverTable.call(this,e);}};MoveRows.prototype.moveHoverTable=function(e){var rowHolder=this.table.rowManager.getElement(),scrollTop=rowHolder.scrollTop,yPos=(this.touchMove?e.touches[0].pageY:e.pageY)-rowHolder.getBoundingClientRect().top+scrollTop,scrollPos;this.hoverElement.style.top=yPos-this.startY+"px";};MoveRows.prototype.moveHoverConnections=function(e){this.hoverElement.style.left=this.startX+(this.touchMove?e.touches[0].pageX:e.pageX)+"px";this.hoverElement.style.top=this.startY+(this.touchMove?e.touches[0].pageY:e.pageY)+"px";};//establish connection with other tables
MoveRows.prototype.connectToTables=function(row){var self=this,connections=this.table.modules.comms.getConnections(this.connection);this.table.options.movableRowsSendingStart.call(this.table,connections);this.table.modules.comms.send(this.connection,"moveRow","connect",{row:row});};//disconnect from other tables
MoveRows.prototype.disconnectFromTables=function(){var self=this,connections=this.table.modules.comms.getConnections(this.connection);this.table.options.movableRowsSendingStop.call(this.table,connections);this.table.modules.comms.send(this.connection,"moveRow","disconnect");};//accept incomming connection
MoveRows.prototype.connect=function(table,row){var self=this;if(!this.connectedTable){this.connectedTable=table;this.connectedRow=row;this.table.element.classList.add("tabulator-movingrow-receiving");self.table.rowManager.getDisplayRows().forEach(function(row){if(row.type==="row"&&row.modules.moveRow&&row.modules.moveRow.mouseup){row.getElement().addEventListener("mouseup",row.modules.moveRow.mouseup);}});self.tableRowDropEvent=self.tableRowDrop.bind(self);self.table.element.addEventListener("mouseup",self.tableRowDropEvent);this.table.options.movableRowsReceivingStart.call(this.table,row,table);return true;}else{console.warn("Move Row Error - Table cannot accept connection, already connected to table:",this.connectedTable);return false;}};//close incomming connection
MoveRows.prototype.disconnect=function(table){var self=this;if(table===this.connectedTable){this.connectedTable=false;this.connectedRow=false;this.table.element.classList.remove("tabulator-movingrow-receiving");self.table.rowManager.getDisplayRows().forEach(function(row){if(row.type==="row"&&row.modules.moveRow&&row.modules.moveRow.mouseup){row.getElement().removeEventListener("mouseup",row.modules.moveRow.mouseup);}});self.table.element.removeEventListener("mouseup",self.tableRowDropEvent);this.table.options.movableRowsReceivingStop.call(this.table,table);}else{console.warn("Move Row Error - trying to disconnect from non connected table");}};MoveRows.prototype.dropComplete=function(table,row,success){var sender=false;if(success){switch(_typeof(this.table.options.movableRowsSender)){case"string":sender=this.senders[this.table.options.movableRowsSender];break;case"function":sender=this.table.options.movableRowsSender;break;}if(sender){sender.call(this,this.moving.getComponent(),row?row.getComponent():undefined,table);}else{if(this.table.options.movableRowsSender){console.warn("Mover Row Error - no matching sender found:",this.table.options.movableRowsSender);}}this.table.options.movableRowsSent.call(this.table,this.moving.getComponent(),row?row.getComponent():undefined,table);}else{this.table.options.movableRowsSentFailed.call(this.table,this.moving.getComponent(),row?row.getComponent():undefined,table);}this.endMove();};MoveRows.prototype.tableRowDrop=function(e,row){var receiver=false,success=false;e.stopImmediatePropagation();switch(_typeof(this.table.options.movableRowsReceiver)){case"string":receiver=this.receivers[this.table.options.movableRowsReceiver];break;case"function":receiver=this.table.options.movableRowsReceiver;break;}if(receiver){success=receiver.call(this,this.connectedRow.getComponent(),row?row.getComponent():undefined,this.connectedTable);}else{console.warn("Mover Row Error - no matching receiver found:",this.table.options.movableRowsReceiver);}if(success){this.table.options.movableRowsReceived.call(this.table,this.connectedRow.getComponent(),row?row.getComponent():undefined,this.connectedTable);}else{this.table.options.movableRowsReceivedFailed.call(this.table,this.connectedRow.getComponent(),row?row.getComponent():undefined,this.connectedTable);}this.table.modules.comms.send(this.connectedTable,"moveRow","dropcomplete",{row:row,success:success});};MoveRows.prototype.receivers={insert:function insert(fromRow,toRow,fromTable){this.table.addRow(fromRow.getData(),undefined,toRow);return true;},add:function add(fromRow,toRow,fromTable){this.table.addRow(fromRow.getData());return true;},update:function update(fromRow,toRow,fromTable){if(toRow){toRow.update(fromRow.getData());return true;}return false;},replace:function replace(fromRow,toRow,fromTable){if(toRow){this.table.addRow(fromRow.getData(),undefined,toRow);toRow.delete();return true;}return false;}};MoveRows.prototype.senders={delete:function _delete(fromRow,toRow,toTable){fromRow.delete();}};MoveRows.prototype.commsReceived=function(table,action,data){switch(action){case"connect":return this.connect(table,data.row);break;case"disconnect":return this.disconnect(table);break;case"dropcomplete":return this.dropComplete(table,data.row,data.success);break;}};Tabulator.prototype.registerModule("moveRow",MoveRows);var Mutator=function Mutator(table){this.table=table;//hold Tabulator object
this.allowedTypes=["","data","edit","clipboard"];//list of muatation types
this.enabled=true;};//initialize column mutator
Mutator.prototype.initializeColumn=function(column){var self=this,match=false,config={};this.allowedTypes.forEach(function(type){var key="mutator"+(type.charAt(0).toUpperCase()+type.slice(1)),mutator;if(column.definition[key]){mutator=self.lookupMutator(column.definition[key]);if(mutator){match=true;config[key]={mutator:mutator,params:column.definition[key+"Params"]||{}};}}});if(match){column.modules.mutate=config;}};Mutator.prototype.lookupMutator=function(value){var mutator=false;//set column mutator
switch(typeof value==='undefined'?'undefined':_typeof(value)){case"string":if(this.mutators[value]){mutator=this.mutators[value];}else{console.warn("Mutator Error - No such mutator found, ignoring: ",value);}break;case"function":mutator=value;break;}return mutator;};//apply mutator to row
Mutator.prototype.transformRow=function(data,type,update){var self=this,key="mutator"+(type.charAt(0).toUpperCase()+type.slice(1)),value;if(this.enabled){self.table.columnManager.traverse(function(column){var mutator,params,component;if(column.modules.mutate){mutator=column.modules.mutate[key]||column.modules.mutate.mutator||false;if(mutator){value=column.getFieldValue(data);if(!update||update&&typeof value!=="undefined"){component=column.getComponent();params=typeof mutator.params==="function"?mutator.params(value,data,type,component):mutator.params;column.setFieldValue(data,mutator.mutator(value,data,type,params,component));}}}});}return data;};//apply mutator to new cell value
Mutator.prototype.transformCell=function(cell,value){var mutator=cell.column.modules.mutate.mutatorEdit||cell.column.modules.mutate.mutator||false;if(mutator){return mutator.mutator(value,cell.row.getData(),"edit",mutator.params,cell.getComponent());}else{return value;}};Mutator.prototype.enable=function(){this.enabled=true;};Mutator.prototype.disable=function(){this.enabled=false;};//default mutators
Mutator.prototype.mutators={};Tabulator.prototype.registerModule("mutator",Mutator);var Page=function Page(table){this.table=table;//hold Tabulator object
this.mode="local";this.progressiveLoad=false;this.size=0;this.page=1;this.count=5;this.max=1;this.displayIndex=0;//index in display pipeline
this.pageSizes=[];this.createElements();};Page.prototype.createElements=function(){var button;this.element=document.createElement("span");this.element.classList.add("tabulator-paginator");this.pagesElement=document.createElement("span");this.pagesElement.classList.add("tabulator-pages");button=document.createElement("button");button.classList.add("tabulator-page");button.setAttribute("type","button");button.setAttribute("role","button");button.setAttribute("aria-label","");button.setAttribute("title","");this.firstBut=button.cloneNode(true);this.firstBut.setAttribute("data-page","first");this.prevBut=button.cloneNode(true);this.prevBut.setAttribute("data-page","prev");this.nextBut=button.cloneNode(true);this.nextBut.setAttribute("data-page","next");this.lastBut=button.cloneNode(true);this.lastBut.setAttribute("data-page","last");if(this.table.options.paginationSizeSelector){this.pageSizeSelect=document.createElement("select");this.pageSizeSelect.classList.add("tabulator-page-size");}};Page.prototype.generatePageSizeSelectList=function(){var _this36=this;var pageSizes=[];if(this.pageSizeSelect){if(Array.isArray(this.table.options.paginationSizeSelector)){pageSizes=this.table.options.paginationSizeSelector;this.pageSizes=pageSizes;if(this.pageSizes.indexOf(this.size)==-1){pageSizes.unshift(this.size);}}else{if(this.pageSizes.indexOf(this.size)==-1){pageSizes=[];for(var i=1;i<5;i++){pageSizes.push(this.size*i);}this.pageSizes=pageSizes;}else{pageSizes=this.pageSizes;}}while(this.pageSizeSelect.firstChild){this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);}pageSizes.forEach(function(item){var itemEl=document.createElement("option");itemEl.value=item;itemEl.innerHTML=item;_this36.pageSizeSelect.appendChild(itemEl);});this.pageSizeSelect.value=this.size;}};//setup pageination
Page.prototype.initialize=function(hidden){var self=this,pageSelectLabel;//update param names
for(var key in self.table.options.paginationDataSent){self.paginationDataSentNames[key]=self.table.options.paginationDataSent[key];}for(var _key2 in self.table.options.paginationDataReceived){self.paginationDataReceivedNames[_key2]=self.table.options.paginationDataReceived[_key2];}//build pagination element
//bind localizations
self.table.modules.localize.bind("pagination|first",function(value){self.firstBut.innerHTML=value;});self.table.modules.localize.bind("pagination|first_title",function(value){self.firstBut.setAttribute("aria-label",value);self.firstBut.setAttribute("title",value);});self.table.modules.localize.bind("pagination|prev",function(value){self.prevBut.innerHTML=value;});self.table.modules.localize.bind("pagination|prev_title",function(value){self.prevBut.setAttribute("aria-label",value);self.prevBut.setAttribute("title",value);});self.table.modules.localize.bind("pagination|next",function(value){self.nextBut.innerHTML=value;});self.table.modules.localize.bind("pagination|next_title",function(value){self.nextBut.setAttribute("aria-label",value);self.nextBut.setAttribute("title",value);});self.table.modules.localize.bind("pagination|last",function(value){self.lastBut.innerHTML=value;});self.table.modules.localize.bind("pagination|last_title",function(value){self.lastBut.setAttribute("aria-label",value);self.lastBut.setAttribute("title",value);});//click bindings
self.firstBut.addEventListener("click",function(){self.setPage(1);});self.prevBut.addEventListener("click",function(){self.previousPage();});self.nextBut.addEventListener("click",function(){self.nextPage().then(function(){}).catch(function(){});});self.lastBut.addEventListener("click",function(){self.setPage(self.max);});if(self.table.options.paginationElement){self.element=self.table.options.paginationElement;}if(this.pageSizeSelect){pageSelectLabel=document.createElement("label");self.table.modules.localize.bind("pagination|page_size",function(value){self.pageSizeSelect.setAttribute("aria-label",value);self.pageSizeSelect.setAttribute("title",value);pageSelectLabel.innerHTML=value;});self.element.appendChild(pageSelectLabel);self.element.appendChild(self.pageSizeSelect);self.pageSizeSelect.addEventListener("change",function(e){self.setPageSize(self.pageSizeSelect.value);self.setPage(1).then(function(){}).catch(function(){});});}//append to DOM
self.element.appendChild(self.firstBut);self.element.appendChild(self.prevBut);self.element.appendChild(self.pagesElement);self.element.appendChild(self.nextBut);self.element.appendChild(self.lastBut);if(!self.table.options.paginationElement&&!hidden){self.table.footerManager.append(self.element,self);}//set default values
self.mode=self.table.options.pagination;self.size=self.table.options.paginationSize||Math.floor(self.table.rowManager.getElement().clientHeight/24);self.count=self.table.options.paginationButtonCount;self.generatePageSizeSelectList();};Page.prototype.initializeProgressive=function(mode){this.initialize(true);this.mode="progressive_"+mode;this.progressiveLoad=true;};Page.prototype.setDisplayIndex=function(index){this.displayIndex=index;};Page.prototype.getDisplayIndex=function(){return this.displayIndex;};//calculate maximum page from number of rows
Page.prototype.setMaxRows=function(rowCount){if(!rowCount){this.max=1;}else{this.max=Math.ceil(rowCount/this.size);}if(this.page>this.max){this.page=this.max;}};//reset to first page without triggering action
Page.prototype.reset=function(force){if(this.mode=="local"||force){this.page=1;}return true;};//set the maxmum page
Page.prototype.setMaxPage=function(max){max=parseInt(max);this.max=max||1;if(this.page>this.max){this.page=this.max;this.trigger();}};//set current page number
Page.prototype.setPage=function(page){var _this37=this;return new Promise(function(resolve,reject){page=parseInt(page);if(page>0&&page<=_this37.max){_this37.page=page;_this37.trigger().then(function(){resolve();}).catch(function(){reject();});}else{console.warn("Pagination Error - Requested page is out of range of 1 - "+_this37.max+":",page);reject();}});};Page.prototype.setPageToRow=function(row){var _this38=this;return new Promise(function(resolve,reject){var rows=_this38.table.rowManager.getDisplayRows(_this38.displayIndex-1);var index=rows.indexOf(row);if(index>-1){var page=Math.ceil((index+1)/_this38.size);_this38.setPage(page).then(function(){resolve();}).catch(function(){reject();});}else{console.warn("Pagination Error - Requested row is not visible");reject();}});};Page.prototype.setPageSize=function(size){size=parseInt(size);if(size>0){this.size=size;}if(this.pageSizeSelect){// this.pageSizeSelect.value = size;
this.generatePageSizeSelectList();}};//setup the pagination buttons
Page.prototype._setPageButtons=function(){var self=this;var leftSize=Math.floor((this.count-1)/2);var rightSize=Math.ceil((this.count-1)/2);var min=this.max-this.page+leftSize+1<this.count?this.max-this.count+1:Math.max(this.page-leftSize,1);var max=this.page<=rightSize?Math.min(this.count,this.max):Math.min(this.page+rightSize,this.max);while(self.pagesElement.firstChild){self.pagesElement.removeChild(self.pagesElement.firstChild);}if(self.page==1){self.firstBut.disabled=true;self.prevBut.disabled=true;}else{self.firstBut.disabled=false;self.prevBut.disabled=false;}if(self.page==self.max){self.lastBut.disabled=true;self.nextBut.disabled=true;}else{self.lastBut.disabled=false;self.nextBut.disabled=false;}for(var i=min;i<=max;i++){if(i>0&&i<=self.max){self.pagesElement.appendChild(self._generatePageButton(i));}}this.footerRedraw();};Page.prototype._generatePageButton=function(page){var self=this,button=document.createElement("button");button.classList.add("tabulator-page");if(page==self.page){button.classList.add("active");}button.setAttribute("type","button");button.setAttribute("role","button");button.setAttribute("aria-label","Show Page "+page);button.setAttribute("title","Show Page "+page);button.setAttribute("data-page",page);button.textContent=page;button.addEventListener("click",function(e){self.setPage(page);});return button;};//previous page
Page.prototype.previousPage=function(){var _this39=this;return new Promise(function(resolve,reject){if(_this39.page>1){_this39.page--;_this39.trigger().then(function(){resolve();}).catch(function(){reject();});}else{console.warn("Pagination Error - Previous page would be less than page 1:",0);reject();}});};//next page
Page.prototype.nextPage=function(){var _this40=this;return new Promise(function(resolve,reject){if(_this40.page<_this40.max){_this40.page++;_this40.trigger().then(function(){resolve();}).catch(function(){reject();});}else{if(!_this40.progressiveLoad){console.warn("Pagination Error - Next page would be greater than maximum page of "+_this40.max+":",_this40.max+1);}reject();}});};//return current page number
Page.prototype.getPage=function(){return this.page;};//return max page number
Page.prototype.getPageMax=function(){return this.max;};Page.prototype.getPageSize=function(size){return this.size;};Page.prototype.getMode=function(){return this.mode;};//return appropriate rows for current page
Page.prototype.getRows=function(data){var output,start,end;if(this.mode=="local"){output=[];start=this.size*(this.page-1);end=start+parseInt(this.size);this._setPageButtons();for(var i=start;i<end;i++){if(data[i]){output.push(data[i]);}}return output;}else{this._setPageButtons();return data.slice(0);}};Page.prototype.trigger=function(){var _this41=this;var left;return new Promise(function(resolve,reject){switch(_this41.mode){case"local":left=_this41.table.rowManager.scrollLeft;_this41.table.rowManager.refreshActiveData("page");_this41.table.rowManager.scrollHorizontal(left);_this41.table.options.pageLoaded.call(_this41.table,_this41.getPage());resolve();break;case"remote":case"progressive_load":case"progressive_scroll":_this41.table.modules.ajax.blockActiveRequest();_this41._getRemotePage().then(function(){resolve();}).catch(function(){reject();});break;default:console.warn("Pagination Error - no such pagination mode:",_this41.mode);reject();}});};Page.prototype._getRemotePage=function(){var _this42=this;var self=this,oldParams,pageParams;return new Promise(function(resolve,reject){if(!self.table.modExists("ajax",true)){reject();}//record old params and restore after request has been made
oldParams=Tabulator.prototype.helpers.deepClone(self.table.modules.ajax.getParams()||{});pageParams=self.table.modules.ajax.getParams();//configure request params
pageParams[_this42.paginationDataSentNames.page]=self.page;//set page size if defined
if(_this42.size){pageParams[_this42.paginationDataSentNames.size]=_this42.size;}//set sort data if defined
if(_this42.table.options.ajaxSorting&&_this42.table.modExists("sort")){var sorters=self.table.modules.sort.getSort();sorters.forEach(function(item){delete item.column;});pageParams[_this42.paginationDataSentNames.sorters]=sorters;}//set filter data if defined
if(_this42.table.options.ajaxFiltering&&_this42.table.modExists("filter")){var filters=self.table.modules.filter.getFilters(true,true);pageParams[_this42.paginationDataSentNames.filters]=filters;}self.table.modules.ajax.setParams(pageParams);self.table.modules.ajax.sendRequest(_this42.progressiveLoad).then(function(data){self._parseRemoteData(data);resolve();}).catch(function(e){reject();});self.table.modules.ajax.setParams(oldParams);});};Page.prototype._parseRemoteData=function(data){var self=this,left,data,margin;if(typeof data[this.paginationDataReceivedNames.last_page]==="undefined"){console.warn("Remote Pagination Error - Server response missing '"+this.paginationDataReceivedNames.last_page+"' property");}if(data[this.paginationDataReceivedNames.data]){this.max=parseInt(data[this.paginationDataReceivedNames.last_page])||1;if(this.progressiveLoad){switch(this.mode){case"progressive_load":this.table.rowManager.addRows(data[this.paginationDataReceivedNames.data]);if(this.page<this.max){setTimeout(function(){self.nextPage().then(function(){}).catch(function(){});},self.table.options.ajaxProgressiveLoadDelay);}break;case"progressive_scroll":data=this.table.rowManager.getData().concat(data[this.paginationDataReceivedNames.data]);this.table.rowManager.setData(data,true);margin=this.table.options.ajaxProgressiveLoadScrollMargin||this.table.rowManager.element.clientHeight*2;if(self.table.rowManager.element.scrollHeight<=self.table.rowManager.element.clientHeight+margin){self.nextPage().then(function(){}).catch(function(){});}break;}}else{left=this.table.rowManager.scrollLeft;this.table.rowManager.setData(data[this.paginationDataReceivedNames.data]);this.table.rowManager.scrollHorizontal(left);this.table.columnManager.scrollHorizontal(left);this.table.options.pageLoaded.call(this.table,this.getPage());}}else{console.warn("Remote Pagination Error - Server response missing '"+this.paginationDataReceivedNames.data+"' property");}};//handle the footer element being redrawn
Page.prototype.footerRedraw=function(){var footer=this.table.footerManager.element;if(Math.ceil(footer.clientWidth)-footer.scrollWidth<0){this.pagesElement.style.display='none';}else{this.pagesElement.style.display='';if(Math.ceil(footer.clientWidth)-footer.scrollWidth<0){this.pagesElement.style.display='none';}}};//set the paramter names for pagination requests
Page.prototype.paginationDataSentNames={"page":"page","size":"size","sorters":"sorters",// "sort_dir":"sort_dir",
"filters":"filters"};//set the property names for pagination responses
Page.prototype.paginationDataReceivedNames={"current_page":"current_page","last_page":"last_page","data":"data"};Tabulator.prototype.registerModule("page",Page);var Persistence=function Persistence(table){this.table=table;//hold Tabulator object
this.mode="";this.id="";this.persistProps=["field","width","visible"];};//setup parameters
Persistence.prototype.initialize=function(mode,id){//determine persistent layout storage type
this.mode=mode!==true?mode:typeof window.localStorage!=='undefined'?"local":"cookie";//set storage tag
this.id="tabulator-"+(id||this.table.element.getAttribute("id")||"");};//load saved definitions
Persistence.prototype.load=function(type,current){var data=this.retreiveData(type);if(current){data=data?this.mergeDefinition(current,data):current;}return data;};//retreive data from memory
Persistence.prototype.retreiveData=function(type){var data="",id=this.id+(type==="columns"?"":"-"+type);switch(this.mode){case"local":data=localStorage.getItem(id);break;case"cookie"://find cookie
var cookie=document.cookie,cookiePos=cookie.indexOf(id+"="),end=void 0;//if cookie exists, decode and load column data into tabulator
if(cookiePos>-1){cookie=cookie.substr(cookiePos);end=cookie.indexOf(";");if(end>-1){cookie=cookie.substr(0,end);}data=cookie.replace(id+"=","");}break;default:console.warn("Persistance Load Error - invalid mode selected",this.mode);}return data?JSON.parse(data):false;};//merge old and new column defintions
Persistence.prototype.mergeDefinition=function(oldCols,newCols){var self=this,output=[];// oldCols = oldCols || [];
newCols=newCols||[];newCols.forEach(function(column,to){var from=self._findColumn(oldCols,column);if(from){from.width=column.width;from.visible=column.visible;if(from.columns){from.columns=self.mergeDefinition(from.columns,column.columns);}output.push(from);}});oldCols.forEach(function(column,i){var from=self._findColumn(newCols,column);if(!from){if(output.length>i){output.splice(i,0,column);}else{output.push(column);}}});return output;};//find matching columns
Persistence.prototype._findColumn=function(columns,subject){var type=subject.columns?"group":subject.field?"field":"object";return columns.find(function(col){switch(type){case"group":return col.title===subject.title&&col.columns.length===subject.columns.length;break;case"field":return col.field===subject.field;break;case"object":return col===subject;break;}});};//save data
Persistence.prototype.save=function(type){var data={};switch(type){case"columns":data=this.parseColumns(this.table.columnManager.getColumns());break;case"filter":data=this.table.modules.filter.getFilters();break;case"sort":data=this.validateSorters(this.table.modules.sort.getSort());break;}var id=this.id+(type==="columns"?"":"-"+type);this.saveData(id,data);};//ensure sorters contain no function data
Persistence.prototype.validateSorters=function(data){data.forEach(function(item){item.column=item.field;delete item.field;});return data;};//save data to chosed medium
Persistence.prototype.saveData=function(id,data){data=JSON.stringify(data);switch(this.mode){case"local":localStorage.setItem(id,data);break;case"cookie":var expireDate=new Date();expireDate.setDate(expireDate.getDate()+10000);//save cookie
document.cookie=id+"="+data+"; expires="+expireDate.toUTCString();break;default:console.warn("Persistance Save Error - invalid mode selected",this.mode);}};//build premission list
Persistence.prototype.parseColumns=function(columns){var self=this,definitions=[];columns.forEach(function(column){var def={};if(column.isGroup){def.title=column.getDefinition().title;def.columns=self.parseColumns(column.getColumns());}else{def.title=column.getDefinition().title;def.field=column.getField();def.width=column.getWidth();def.visible=column.visible;}definitions.push(def);});return definitions;};Tabulator.prototype.registerModule("persistence",Persistence);var ReactiveData=function ReactiveData(table){this.table=table;//hold Tabulator object
this.data=false;this.blocked=false;//block reactivity while performing update
this.origFuncs={};// hold original data array functions to allow replacement after data is done with
};ReactiveData.prototype.watchData=function(data){var self=this,pushFunc;self.unwatchData();self.data=data;//override array push function
self.origFuncs.push=data.push;Object.defineProperty(self.data,"push",{enumerable:false,value:function value(){var args=Array.from(arguments);if(!self.blocked){args.forEach(function(arg){self.table.rowManager.addRowActual(arg,false);});}return self.origFuncs.push.apply(data,arguments);}});//override array unshift function
self.origFuncs.unshift=data.unshift;Object.defineProperty(self.data,"unshift",{enumerable:false,value:function value(){var args=Array.from(arguments);if(!self.blocked){args.forEach(function(arg){self.table.rowManager.addRowActual(arg,true);});}return self.origFuncs.unshift.apply(data,arguments);}});//override array shift function
self.origFuncs.shift=data.shift;Object.defineProperty(self.data,"shift",{enumerable:false,value:function value(){var row;if(!self.blocked){if(self.data.length){row=self.table.rowManager.getRowFromDataObject(self.data[0]);if(row){row.deleteActual();}}}return self.origFuncs.shift.call(data);}});//override array pop function
self.origFuncs.pop=data.pop;Object.defineProperty(self.data,"pop",{enumerable:false,value:function value(){var row;if(!self.blocked){if(self.data.length){row=self.table.rowManager.getRowFromDataObject(self.data[self.data.length-1]);if(row){row.deleteActual();}}}return self.origFuncs.pop.call(data);}});//override array splice function
self.origFuncs.splice=data.splice;Object.defineProperty(self.data,"splice",{enumerable:false,value:function value(){var args=Array.from(arguments),start=args[0]<0?data.length+args[0]:args[0],end=args[1],newRows=args[2]?args.slice(2):false,startRow;if(!self.blocked){//add new rows
if(newRows){startRow=data[start]?self.table.rowManager.getRowFromDataObject(data[start]):false;if(startRow){newRows.forEach(function(rowData){self.table.rowManager.addRowActual(rowData,true,startRow,true);});}else{newRows=newRows.slice().reverse();newRows.forEach(function(rowData){self.table.rowManager.addRowActual(rowData,true,false,true);});}}//delete removed rows
if(end!==0){var oldRows=data.slice(start,typeof args[1]==="undefined"?args[1]:start+end);oldRows.forEach(function(rowData){var row=self.table.rowManager.getRowFromDataObject(rowData);if(row){row.deleteActual(true);}});}if(newRows||end!==0){self.table.rowManager.reRenderInPosition();}}return self.origFuncs.splice.apply(data,arguments);}});};ReactiveData.prototype.unwatchData=function(){if(this.data!==false){for(var key in this.origFuncs){Object.defineProperty(self.data,key,{enumerable:false,value:origFuncs.push});}}};ReactiveData.prototype.watchRow=function(row){var self=this,data=row.getData();this.blocked=true;for(var key in data){this.watchKey(row,data,key);}this.blocked=false;};ReactiveData.prototype.watchKey=function(row,data,key){var self=this,props=Object.getOwnPropertyDescriptor(data,key),value=data[key];Object.defineProperty(data,key,{set:function set(newValue){value=newValue;if(!self.blocked){var update={};update[key]=newValue;row.updateData(update);}if(props.set){props.set(newValue);}},get:function get(){if(props.get){props.get();}return value;}});};ReactiveData.prototype.unwatchRow=function(row){var data=row.getData();for(var key in data){Object.defineProperty(data,key,{value:data[key]});}};ReactiveData.prototype.block=function(){this.blocked=true;};ReactiveData.prototype.unblock=function(){this.blocked=false;};Tabulator.prototype.registerModule("reactiveData",ReactiveData);var ResizeColumns=function ResizeColumns(table){this.table=table;//hold Tabulator object
this.startColumn=false;this.startX=false;this.startWidth=false;this.handle=null;this.prevHandle=null;};ResizeColumns.prototype.initializeColumn=function(type,column,element){var self=this,variableHeight=false,mode=this.table.options.resizableColumns;//set column resize mode
if(type==="header"){variableHeight=column.definition.formatter=="textarea"||column.definition.variableHeight;column.modules.resize={variableHeight:variableHeight};}if(mode===true||mode==type){var handle=document.createElement('div');handle.className="tabulator-col-resize-handle";var prevHandle=document.createElement('div');prevHandle.className="tabulator-col-resize-handle prev";handle.addEventListener("click",function(e){e.stopPropagation();});var handleDown=function handleDown(e){var nearestColumn=column.getLastColumn();if(nearestColumn&&self._checkResizability(nearestColumn)){self.startColumn=column;self._mouseDown(e,nearestColumn,handle);}};handle.addEventListener("mousedown",handleDown);handle.addEventListener("touchstart",handleDown);//reszie column on  double click
handle.addEventListener("dblclick",function(e){if(self._checkResizability(column)){column.reinitializeWidth(true);}});prevHandle.addEventListener("click",function(e){e.stopPropagation();});var prevHandleDown=function prevHandleDown(e){var nearestColumn,colIndex,prevColumn;nearestColumn=column.getFirstColumn();if(nearestColumn){colIndex=self.table.columnManager.findColumnIndex(nearestColumn);prevColumn=colIndex>0?self.table.columnManager.getColumnByIndex(colIndex-1):false;if(prevColumn&&self._checkResizability(prevColumn)){self.startColumn=column;self._mouseDown(e,prevColumn,prevHandle);}}};prevHandle.addEventListener("mousedown",prevHandleDown);prevHandle.addEventListener("touchstart",prevHandleDown);//resize column on double click
prevHandle.addEventListener("dblclick",function(e){var nearestColumn,colIndex,prevColumn;nearestColumn=column.getFirstColumn();if(nearestColumn){colIndex=self.table.columnManager.findColumnIndex(nearestColumn);prevColumn=colIndex>0?self.table.columnManager.getColumnByIndex(colIndex-1):false;if(prevColumn&&self._checkResizability(prevColumn)){prevColumn.reinitializeWidth(true);}}});element.appendChild(handle);element.appendChild(prevHandle);}};ResizeColumns.prototype._checkResizability=function(column){return typeof column.definition.resizable!="undefined"?column.definition.resizable:this.table.options.resizableColumns;};ResizeColumns.prototype._mouseDown=function(e,column,handle){var self=this;self.table.element.classList.add("tabulator-block-select");function mouseMove(e){column.setWidth(self.startWidth+((typeof e.screenX==="undefined"?e.touches[0].screenX:e.screenX)-self.startX));if(!self.table.browserSlow&&column.modules.resize&&column.modules.resize.variableHeight){column.checkCellHeights();}}function mouseUp(e){//block editor from taking action while resizing is taking place
if(self.startColumn.modules.edit){self.startColumn.modules.edit.blocked=false;}if(self.table.browserSlow&&column.modules.resize&&column.modules.resize.variableHeight){column.checkCellHeights();}document.body.removeEventListener("mouseup",mouseUp);document.body.removeEventListener("mousemove",mouseMove);handle.removeEventListener("touchmove",mouseMove);handle.removeEventListener("touchend",mouseUp);self.table.element.classList.remove("tabulator-block-select");if(self.table.options.persistentLayout&&self.table.modExists("persistence",true)){self.table.modules.persistence.save("columns");}self.table.options.columnResized.call(self.table,column.getComponent());}e.stopPropagation();//prevent resize from interfereing with movable columns
//block editor from taking action while resizing is taking place
if(self.startColumn.modules.edit){self.startColumn.modules.edit.blocked=true;}self.startX=typeof e.screenX==="undefined"?e.touches[0].screenX:e.screenX;self.startWidth=column.getWidth();document.body.addEventListener("mousemove",mouseMove);document.body.addEventListener("mouseup",mouseUp);handle.addEventListener("touchmove",mouseMove);handle.addEventListener("touchend",mouseUp);};Tabulator.prototype.registerModule("resizeColumns",ResizeColumns);var ResizeRows=function ResizeRows(table){this.table=table;//hold Tabulator object
this.startColumn=false;this.startY=false;this.startHeight=false;this.handle=null;this.prevHandle=null;};ResizeRows.prototype.initializeRow=function(row){var self=this,rowEl=row.getElement();var handle=document.createElement('div');handle.className="tabulator-row-resize-handle";var prevHandle=document.createElement('div');prevHandle.className="tabulator-row-resize-handle prev";handle.addEventListener("click",function(e){e.stopPropagation();});var handleDown=function handleDown(e){self.startRow=row;self._mouseDown(e,row,handle);};handle.addEventListener("mousedown",handleDown);handle.addEventListener("touchstart",handleDown);prevHandle.addEventListener("click",function(e){e.stopPropagation();});var prevHandleDown=function prevHandleDown(e){var prevRow=self.table.rowManager.prevDisplayRow(row);if(prevRow){self.startRow=prevRow;self._mouseDown(e,prevRow,prevHandle);}};prevHandle.addEventListener("mousedown",prevHandleDown);prevHandle.addEventListener("touchstart",prevHandleDown);rowEl.appendChild(handle);rowEl.appendChild(prevHandle);};ResizeRows.prototype._mouseDown=function(e,row,handle){var self=this;self.table.element.classList.add("tabulator-block-select");function mouseMove(e){row.setHeight(self.startHeight+((typeof e.screenY==="undefined"?e.touches[0].screenY:e.screenY)-self.startY));}function mouseUp(e){// //block editor from taking action while resizing is taking place
// if(self.startColumn.modules.edit){
// 	self.startColumn.modules.edit.blocked = false;
// }
document.body.removeEventListener("mouseup",mouseMove);document.body.removeEventListener("mousemove",mouseMove);handle.removeEventListener("touchmove",mouseMove);handle.removeEventListener("touchend",mouseUp);self.table.element.classList.remove("tabulator-block-select");self.table.options.rowResized.call(this.table,row.getComponent());}e.stopPropagation();//prevent resize from interfereing with movable columns
//block editor from taking action while resizing is taking place
// if(self.startColumn.modules.edit){
// 	self.startColumn.modules.edit.blocked = true;
// }
self.startY=typeof e.screenY==="undefined"?e.touches[0].screenY:e.screenY;self.startHeight=row.getHeight();document.body.addEventListener("mousemove",mouseMove);document.body.addEventListener("mouseup",mouseUp);handle.addEventListener("touchmove",mouseMove);handle.addEventListener("touchend",mouseUp);};Tabulator.prototype.registerModule("resizeRows",ResizeRows);var ResizeTable=function ResizeTable(table){this.table=table;//hold Tabulator object
this.binding=false;this.observer=false;};ResizeTable.prototype.initialize=function(row){var table=this.table,observer;if(typeof ResizeObserver!=="undefined"&&table.rowManager.getRenderMode()==="virtual"){this.observer=new ResizeObserver(function(entry){table.redraw();});this.observer.observe(table.element);}else{this.binding=function(){table.redraw();};window.addEventListener("resize",this.binding);}};ResizeTable.prototype.clearBindings=function(row){if(this.binding){window.removeEventListener("resize",this.binding);}if(this.observer){this.observer.unobserve(this.table.element);}};Tabulator.prototype.registerModule("resizeTable",ResizeTable);var ResponsiveLayout=function ResponsiveLayout(table){this.table=table;//hold Tabulator object
this.columns=[];this.hiddenColumns=[];this.mode="";this.index=0;this.collapseFormatter=[];this.collapseStartOpen=true;};//generate resposive columns list
ResponsiveLayout.prototype.initialize=function(){var self=this,columns=[];this.mode=this.table.options.responsiveLayout;this.collapseFormatter=this.table.options.responsiveLayoutCollapseFormatter||this.formatCollapsedData;this.collapseStartOpen=this.table.options.responsiveLayoutCollapseStartOpen;this.hiddenColumns=[];//detemine level of responsivity for each column
this.table.columnManager.columnsByIndex.forEach(function(column,i){if(column.modules.responsive){if(column.modules.responsive.order&&column.modules.responsive.visible){column.modules.responsive.index=i;columns.push(column);if(!column.visible&&self.mode==="collapse"){self.hiddenColumns.push(column);}}}});//sort list by responsivity
columns=columns.reverse();columns=columns.sort(function(a,b){var diff=b.modules.responsive.order-a.modules.responsive.order;return diff||b.modules.responsive.index-a.modules.responsive.index;});this.columns=columns;if(this.mode==="collapse"){this.generateCollapsedContent();}};//define layout information
ResponsiveLayout.prototype.initializeColumn=function(column){var def=column.getDefinition();column.modules.responsive={order:typeof def.responsive==="undefined"?1:def.responsive,visible:def.visible===false?false:true};};ResponsiveLayout.prototype.layoutRow=function(row){var rowEl=row.getElement(),el=document.createElement("div");el.classList.add("tabulator-responsive-collapse");if(!rowEl.classList.contains("tabulator-calcs")){row.modules.responsiveLayout={element:el};if(!this.collapseStartOpen){el.style.display='none';}rowEl.appendChild(el);this.generateCollapsedRowContent(row);}};//update column visibility
ResponsiveLayout.prototype.updateColumnVisibility=function(column,visible){var index;if(column.modules.responsive){column.modules.responsive.visible=visible;this.initialize();}};ResponsiveLayout.prototype.hideColumn=function(column){column.hide(false,true);if(this.mode==="collapse"){this.hiddenColumns.unshift(column);this.generateCollapsedContent();}};ResponsiveLayout.prototype.showColumn=function(column){var index;column.show(false,true);//set column width to prevent calculation loops on uninitialized columns
column.setWidth(column.getWidth());if(this.mode==="collapse"){index=this.hiddenColumns.indexOf(column);if(index>-1){this.hiddenColumns.splice(index,1);}this.generateCollapsedContent();}};//redraw columns to fit space
ResponsiveLayout.prototype.update=function(){var self=this,working=true;while(working){var width=self.table.modules.layout.getMode()=="fitColumns"?self.table.columnManager.getFlexBaseWidth():self.table.columnManager.getWidth();var diff=self.table.columnManager.element.clientWidth-width;if(diff<0){//table is too wide
var column=self.columns[self.index];if(column){self.hideColumn(column);self.index++;}else{working=false;}}else{//table has spare space
var _column=self.columns[self.index-1];if(_column){if(diff>0){if(diff>=_column.getWidth()){self.showColumn(_column);self.index--;}else{working=false;}}else{working=false;}}else{working=false;}}if(!self.table.rowManager.activeRowsCount){self.table.rowManager.renderEmptyScroll();}}};ResponsiveLayout.prototype.generateCollapsedContent=function(){var self=this,rows=this.table.rowManager.getDisplayRows();rows.forEach(function(row){self.generateCollapsedRowContent(row);});};ResponsiveLayout.prototype.generateCollapsedRowContent=function(row){var el,contents;if(row.modules.responsiveLayout){el=row.modules.responsiveLayout.element;while(el.firstChild){el.removeChild(el.firstChild);}contents=this.collapseFormatter(this.generateCollapsedRowData(row));if(contents){el.appendChild(contents);}}};ResponsiveLayout.prototype.generateCollapsedRowData=function(row){var self=this,data=row.getData(),output={},mockCellComponent;this.hiddenColumns.forEach(function(column){var value=column.getFieldValue(data);if(column.definition.title&&column.field){if(column.modules.format&&self.table.options.responsiveLayoutCollapseUseFormatters){mockCellComponent={value:false,data:{},getValue:function getValue(){return value;},getData:function getData(){return data;},getElement:function getElement(){return document.createElement("div");},getRow:function getRow(){return row.getComponent();},getColumn:function getColumn(){return column.getComponent();}};output[column.definition.title]=column.modules.format.formatter.call(self.table.modules.format,mockCellComponent,column.modules.format.params);}else{output[column.definition.title]=value;}}});return output;};ResponsiveLayout.prototype.formatCollapsedData=function(data){var list=document.createElement("table"),listContents="";for(var key in data){listContents+="<tr><td><strong>"+key+"</strong></td><td>"+data[key]+"</td></tr>";}list.innerHTML=listContents;return Object.keys(data).length?list:"";};Tabulator.prototype.registerModule("responsiveLayout",ResponsiveLayout);var SelectRow=function SelectRow(table){this.table=table;//hold Tabulator object
this.selecting=false;//flag selecting in progress
this.lastClickedRow=false;//last clicked row
this.selectPrev=[];//hold previously selected element for drag drop selection
this.selectedRows=[];//hold selected rows
};SelectRow.prototype.clearSelectionData=function(silent){this.selecting=false;this.lastClickedRow=false;this.selectPrev=[];this.selectedRows=[];if(!silent){this._rowSelectionChanged();}};SelectRow.prototype.initializeRow=function(row){var self=this,element=row.getElement();// trigger end of row selection
var endSelect=function endSelect(){setTimeout(function(){self.selecting=false;},50);document.body.removeEventListener("mouseup",endSelect);};row.modules.select={selected:false};//set row selection class
if(self.table.options.selectableCheck.call(this.table,row.getComponent())){element.classList.add("tabulator-selectable");element.classList.remove("tabulator-unselectable");if(self.table.options.selectable&&self.table.options.selectable!="highlight"){if(self.table.options.selectableRangeMode&&self.table.options.selectableRangeMode==="click"){element.addEventListener("click",function(e){if(e.shiftKey){self.lastClickedRow=self.lastClickedRow||row;var lastClickedRowIdx=self.table.rowManager.getDisplayRowIndex(self.lastClickedRow);var rowIdx=self.table.rowManager.getDisplayRowIndex(row);var fromRowIdx=lastClickedRowIdx<=rowIdx?lastClickedRowIdx:rowIdx;var toRowIdx=lastClickedRowIdx>=rowIdx?lastClickedRowIdx:rowIdx;var rows=self.table.rowManager.getDisplayRows().slice(0);var toggledRows=rows.splice(fromRowIdx,toRowIdx-fromRowIdx+1);if(e.ctrlKey){toggledRows.forEach(function(toggledRow){if(toggledRow!==self.lastClickedRow){self.toggleRow(toggledRow);}});self.lastClickedRow=row;}else{self.deselectRows();self.selectRows(toggledRows);}}else if(e.ctrlKey){self.toggleRow(row);self.lastClickedRow=row;}else{self.deselectRows();self.selectRows(row);self.lastClickedRow=row;}});}else{element.addEventListener("click",function(e){if(!self.selecting){self.toggleRow(row);}});element.addEventListener("mousedown",function(e){if(e.shiftKey){self.selecting=true;self.selectPrev=[];document.body.addEventListener("mouseup",endSelect);document.body.addEventListener("keyup",endSelect);self.toggleRow(row);return false;}});element.addEventListener("mouseenter",function(e){if(self.selecting){self.toggleRow(row);if(self.selectPrev[1]==row){self.toggleRow(self.selectPrev[0]);}}});element.addEventListener("mouseout",function(e){if(self.selecting){self.selectPrev.unshift(row);}});}}}else{element.classList.add("tabulator-unselectable");element.classList.remove("tabulator-selectable");}};//toggle row selection
SelectRow.prototype.toggleRow=function(row){if(this.table.options.selectableCheck.call(this.table,row.getComponent())){if(row.modules.select.selected){this._deselectRow(row);}else{this._selectRow(row);}}};//select a number of rows
SelectRow.prototype.selectRows=function(rows){var self=this;switch(typeof rows==='undefined'?'undefined':_typeof(rows)){case"undefined":self.table.rowManager.rows.forEach(function(row){self._selectRow(row,true,true);});self._rowSelectionChanged();break;case"boolean":if(rows===true){self.table.rowManager.activeRows.forEach(function(row){self._selectRow(row,true,true);});self._rowSelectionChanged();}break;default:if(Array.isArray(rows)){rows.forEach(function(row){self._selectRow(row,true,true);});self._rowSelectionChanged();}else{self._selectRow(rows,false,true);}break;}};//select an individual row
SelectRow.prototype._selectRow=function(rowInfo,silent,force){var index;//handle max row count
if(!isNaN(this.table.options.selectable)&&this.table.options.selectable!==true&&!force){if(this.selectedRows.length>=this.table.options.selectable){if(this.table.options.selectableRollingSelection){this._deselectRow(this.selectedRows[0]);}else{return false;}}}var row=this.table.rowManager.findRow(rowInfo);if(row){if(this.selectedRows.indexOf(row)==-1){row.modules.select.selected=true;row.getElement().classList.add("tabulator-selected");this.selectedRows.push(row);if(!silent){this.table.options.rowSelected.call(this.table,row.getComponent());this._rowSelectionChanged();}}}else{if(!silent){console.warn("Selection Error - No such row found, ignoring selection:"+rowInfo);}}};SelectRow.prototype.isRowSelected=function(row){return this.selectedRows.indexOf(row)!==-1;};//deselect a number of rows
SelectRow.prototype.deselectRows=function(rows){var self=this,rowCount;if(typeof rows=="undefined"){rowCount=self.selectedRows.length;for(var i=0;i<rowCount;i++){self._deselectRow(self.selectedRows[0],true);}self._rowSelectionChanged();}else{if(Array.isArray(rows)){rows.forEach(function(row){self._deselectRow(row,true);});self._rowSelectionChanged();}else{self._deselectRow(rows);}}};//deselect an individual row
SelectRow.prototype._deselectRow=function(rowInfo,silent){var self=this,row=self.table.rowManager.findRow(rowInfo),index;if(row){index=self.selectedRows.findIndex(function(selectedRow){return selectedRow==row;});if(index>-1){row.modules.select.selected=false;row.getElement().classList.remove("tabulator-selected");self.selectedRows.splice(index,1);if(!silent){self.table.options.rowDeselected.call(this.table,row.getComponent());self._rowSelectionChanged();}}}else{if(!silent){console.warn("Deselection Error - No such row found, ignoring selection:"+rowInfo);}}};SelectRow.prototype.getSelectedData=function(){var data=[];this.selectedRows.forEach(function(row){data.push(row.getData());});return data;};SelectRow.prototype.getSelectedRows=function(){var rows=[];this.selectedRows.forEach(function(row){rows.push(row.getComponent());});return rows;};SelectRow.prototype._rowSelectionChanged=function(){this.table.options.rowSelectionChanged.call(this.table,this.getSelectedData(),this.getSelectedRows());};Tabulator.prototype.registerModule("selectRow",SelectRow);var Sort=function Sort(table){this.table=table;//hold Tabulator object
this.sortList=[];//holder current sort
this.changed=false;//has the sort changed since last render
};//initialize column header for sorting
Sort.prototype.initializeColumn=function(column,content){var self=this,sorter=false,colEl,arrowEl;switch(_typeof(column.definition.sorter)){case"string":if(self.sorters[column.definition.sorter]){sorter=self.sorters[column.definition.sorter];}else{console.warn("Sort Error - No such sorter found: ",column.definition.sorter);}break;case"function":sorter=column.definition.sorter;break;}column.modules.sort={sorter:sorter,dir:"none",params:column.definition.sorterParams||{},startingDir:column.definition.headerSortStartingDir||"asc",tristate:column.definition.headerSortTristate};if(column.definition.headerSort!==false){colEl=column.getElement();colEl.classList.add("tabulator-sortable");arrowEl=document.createElement("div");arrowEl.classList.add("tabulator-arrow");//create sorter arrow
content.appendChild(arrowEl);//sort on click
colEl.addEventListener("click",function(e){var dir="",sorters=[],match=false;if(column.modules.sort){if(column.modules.sort.tristate){if(column.modules.sort.dir=="none"){dir=column.modules.sort.startingDir;}else{if(column.modules.sort.dir==column.modules.sort.startingDir){dir=column.modules.sort.dir=="asc"?"desc":"asc";}else{dir="none";}}}else{switch(column.modules.sort.dir){case"asc":dir="desc";break;case"desc":dir="asc";break;default:dir=column.modules.sort.startingDir;}}if(self.table.options.columnHeaderSortMulti&&(e.shiftKey||e.ctrlKey)){sorters=self.getSort();match=sorters.findIndex(function(sorter){return sorter.field===column.getField();});if(match>-1){sorters[match].dir=dir;if(match!=sorters.length-1){match=sorters.splice(match,1)[0];if(dir!="none"){sorters.push(match);}}}else{if(dir!="none"){sorters.push({column:column,dir:dir});}}//add to existing sort
self.setSort(sorters);}else{if(dir=="none"){self.clear();}else{//sort by column only
self.setSort(column,dir);}}self.table.rowManager.sorterRefresh(!self.sortList.length);}});}};//check if the sorters have changed since last use
Sort.prototype.hasChanged=function(){var changed=this.changed;this.changed=false;return changed;};//return current sorters
Sort.prototype.getSort=function(){var self=this,sorters=[];self.sortList.forEach(function(item){if(item.column){sorters.push({column:item.column.getComponent(),field:item.column.getField(),dir:item.dir});}});return sorters;};//change sort list and trigger sort
Sort.prototype.setSort=function(sortList,dir){var self=this,newSortList=[];if(!Array.isArray(sortList)){sortList=[{column:sortList,dir:dir}];}sortList.forEach(function(item){var column;column=self.table.columnManager.findColumn(item.column);if(column){item.column=column;newSortList.push(item);self.changed=true;}else{console.warn("Sort Warning - Sort field does not exist and is being ignored: ",item.column);}});self.sortList=newSortList;if(this.table.options.persistentSort&&this.table.modExists("persistence",true)){this.table.modules.persistence.save("sort");}};//clear sorters
Sort.prototype.clear=function(){this.setSort([]);};//find appropriate sorter for column
Sort.prototype.findSorter=function(column){var row=this.table.rowManager.activeRows[0],sorter="string",field,value;if(row){row=row.getData();field=column.getField();if(field){value=column.getFieldValue(row);switch(typeof value==='undefined'?'undefined':_typeof(value)){case"undefined":sorter="string";break;case"boolean":sorter="boolean";break;default:if(!isNaN(value)&&value!==""){sorter="number";}else{if(value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)){sorter="alphanum";}}break;}}}return this.sorters[sorter];};//work through sort list sorting data
Sort.prototype.sort=function(data){var self=this,lastSort,sortList;sortList=this.table.options.sortOrderReverse?self.sortList.slice().reverse():self.sortList;if(self.table.options.dataSorting){self.table.options.dataSorting.call(self.table,self.getSort());}self.clearColumnHeaders();if(!self.table.options.ajaxSorting){sortList.forEach(function(item,i){if(item.column&&item.column.modules.sort){//if no sorter has been defined, take a guess
if(!item.column.modules.sort.sorter){item.column.modules.sort.sorter=self.findSorter(item.column);}self._sortItem(data,item.column,item.dir,sortList,i);}self.setColumnHeader(item.column,item.dir);});}else{sortList.forEach(function(item,i){self.setColumnHeader(item.column,item.dir);});}if(self.table.options.dataSorted){self.table.options.dataSorted.call(self.table,self.getSort(),self.table.rowManager.getComponents(true));}};//clear sort arrows on columns
Sort.prototype.clearColumnHeaders=function(){this.table.columnManager.getRealColumns().forEach(function(column){if(column.modules.sort){column.modules.sort.dir="none";column.getElement().setAttribute("aria-sort","none");}});};//set the column header sort direction
Sort.prototype.setColumnHeader=function(column,dir){column.modules.sort.dir=dir;column.getElement().setAttribute("aria-sort",dir);};//sort each item in sort list
Sort.prototype._sortItem=function(data,column,dir,sortList,i){var self=this;var params=typeof column.modules.sort.params==="function"?column.modules.sort.params(column.getComponent(),dir):column.modules.sort.params;data.sort(function(a,b){var result=self._sortRow(a,b,column,dir,params);//if results match recurse through previous searchs to be sure
if(result===0&&i){for(var j=i-1;j>=0;j--){result=self._sortRow(a,b,sortList[j].column,sortList[j].dir,params);if(result!==0){break;}}}return result;});};//process individual rows for a sort function on active data
Sort.prototype._sortRow=function(a,b,column,dir,params){var el1Comp,el2Comp,colComp;//switch elements depending on search direction
var el1=dir=="asc"?a:b;var el2=dir=="asc"?b:a;a=column.getFieldValue(el1.getData());b=column.getFieldValue(el2.getData());a=typeof a!=="undefined"?a:"";b=typeof b!=="undefined"?b:"";el1Comp=el1.getComponent();el2Comp=el2.getComponent();return column.modules.sort.sorter.call(this,a,b,el1Comp,el2Comp,column.getComponent(),dir,params);};//default data sorters
Sort.prototype.sorters={//sort numbers
number:function number(a,b,aRow,bRow,column,dir,params){var alignEmptyValues=params.alignEmptyValues;var decimal=params.decimalSeparator||".";var thousand=params.thousandSeparator||",";var emptyAlign=0;a=parseFloat(String(a).split(thousand).join("").split(decimal).join("."));b=parseFloat(String(b).split(thousand).join("").split(decimal).join("."));//handle non numeric values
if(isNaN(a)){emptyAlign=isNaN(b)?0:-1;}else if(isNaN(b)){emptyAlign=1;}else{//compare valid values
return a-b;}//fix empty values in position
if(alignEmptyValues==="top"&&dir==="desc"||alignEmptyValues==="bottom"&&dir==="asc"){emptyAlign*=-1;}return emptyAlign;},//sort strings
string:function string(a,b,aRow,bRow,column,dir,params){var alignEmptyValues=params.alignEmptyValues;var emptyAlign=0;var locale;//handle empty values
if(!a){emptyAlign=!b?0:-1;}else if(!b){emptyAlign=1;}else{//compare valid values
switch(_typeof(params.locale)){case"boolean":if(params.locale){locale=this.table.modules.localize.getLocale();}break;case"string":locale=params.locale;break;}return String(a).toLowerCase().localeCompare(String(b).toLowerCase(),locale);}//fix empty values in position
if(alignEmptyValues==="top"&&dir==="desc"||alignEmptyValues==="bottom"&&dir==="asc"){emptyAlign*=-1;}return emptyAlign;},//sort date
date:function date(a,b,aRow,bRow,column,dir,params){if(!params.format){params.format="DD/MM/YYYY";}return this.sorters.datetime.call(this,a,b,aRow,bRow,column,dir,params);},//sort hh:mm formatted times
time:function time(a,b,aRow,bRow,column,dir,params){if(!params.format){params.format="hh:mm";}return this.sorters.datetime.call(this,a,b,aRow,bRow,column,dir,params);},//sort datetime
datetime:function datetime(a,b,aRow,bRow,column,dir,params){var format=params.format||"DD/MM/YYYY hh:mm:ss",alignEmptyValues=params.alignEmptyValues,emptyAlign=0;if(typeof moment!="undefined"){a=moment(a,format);b=moment(b,format);if(!a.isValid()){emptyAlign=!b.isValid()?0:-1;}else if(!b.isValid()){emptyAlign=1;}else{//compare valid values
return a-b;}//fix empty values in position
if(alignEmptyValues==="top"&&dir==="desc"||alignEmptyValues==="bottom"&&dir==="asc"){emptyAlign*=-1;}return emptyAlign;}else{console.error("Sort Error - 'datetime' sorter is dependant on moment.js");}},//sort booleans
boolean:function boolean(a,b,aRow,bRow,column,dir,params){var el1=a===true||a==="true"||a==="True"||a===1?1:0;var el2=b===true||b==="true"||b==="True"||b===1?1:0;return el1-el2;},//sort if element contains any data
array:function array(a,b,aRow,bRow,column,dir,params){var el1=0;var el2=0;var type=params.type||"length";var alignEmptyValues=params.alignEmptyValues;var emptyAlign=0;function calc(value){switch(type){case"length":return value.length;break;case"sum":return value.reduce(function(c,d){return c+d;});break;case"max":return Math.max.apply(null,value);break;case"min":return Math.min.apply(null,value);break;case"avg":return value.reduce(function(c,d){return c+d;})/value.length;break;}}//handle non array values
if(!Array.isArray(a)){alignEmptyValues=!Array.isArray(b)?0:-1;}else if(!Array.isArray(b)){alignEmptyValues=1;}else{//compare valid values
el1=a?calc(a):0;el2=b?calc(b):0;return el1-el2;}//fix empty values in position
if(alignEmptyValues==="top"&&dir==="desc"||alignEmptyValues==="bottom"&&dir==="asc"){emptyAlign*=-1;}return emptyAlign;},//sort if element contains any data
exists:function exists(a,b,aRow,bRow,column,dir,params){var el1=typeof a=="undefined"?0:1;var el2=typeof b=="undefined"?0:1;return el1-el2;},//sort alpha numeric strings
alphanum:function alphanum(as,bs,aRow,bRow,column,dir,params){var a,b,a1,b1,i=0,L,rx=/(\d+)|(\D+)/g,rd=/\d/;var alignEmptyValues=params.alignEmptyValues;var emptyAlign=0;//handle empty values
if(!as&&as!==0){emptyAlign=!bs&&bs!==0?0:-1;}else if(!bs&&bs!==0){emptyAlign=1;}else{if(isFinite(as)&&isFinite(bs))return as-bs;a=String(as).toLowerCase();b=String(bs).toLowerCase();if(a===b)return 0;if(!(rd.test(a)&&rd.test(b)))return a>b?1:-1;a=a.match(rx);b=b.match(rx);L=a.length>b.length?b.length:a.length;while(i<L){a1=a[i];b1=b[i++];if(a1!==b1){if(isFinite(a1)&&isFinite(b1)){if(a1.charAt(0)==="0")a1="."+a1;if(b1.charAt(0)==="0")b1="."+b1;return a1-b1;}else return a1>b1?1:-1;}}return a.length>b.length;}//fix empty values in position
if(alignEmptyValues==="top"&&dir==="desc"||alignEmptyValues==="bottom"&&dir==="asc"){emptyAlign*=-1;}return emptyAlign;}};Tabulator.prototype.registerModule("sort",Sort);var Validate=function Validate(table){this.table=table;};//validate
Validate.prototype.initializeColumn=function(column){var self=this,config=[],validator;if(column.definition.validator){if(Array.isArray(column.definition.validator)){column.definition.validator.forEach(function(item){validator=self._extractValidator(item);if(validator){config.push(validator);}});}else{validator=this._extractValidator(column.definition.validator);if(validator){config.push(validator);}}column.modules.validate=config.length?config:false;}};Validate.prototype._extractValidator=function(value){var parts,type,params;switch(typeof value==='undefined'?'undefined':_typeof(value)){case"string":parts=value.split(":",2);type=parts.shift();params=parts[0];return this._buildValidator(type,params);break;case"function":return this._buildValidator(value);break;case"object":return this._buildValidator(value.type,value.parameters);break;}};Validate.prototype._buildValidator=function(type,params){var func=typeof type=="function"?type:this.validators[type];if(!func){console.warn("Validator Setup Error - No matching validator found:",type);return false;}else{return{type:typeof type=="function"?"function":type,func:func,params:params};}};Validate.prototype.validate=function(validators,cell,value){var self=this,valid=[];if(validators){validators.forEach(function(item){if(!item.func.call(self,cell,value,item.params)){valid.push({type:item.type,parameters:item.params});}});}return valid.length?valid:true;};Validate.prototype.validators={//is integer
integer:function integer(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}value=Number(value);return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;},//is float
float:function float(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}value=Number(value);return typeof value==='number'&&isFinite(value)&&value%1!==0;},//must be a number
numeric:function numeric(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}return!isNaN(value);},//must be a string
string:function string(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}return isNaN(value);},//maximum value
max:function max(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}return parseFloat(value)<=parameters;},//minimum value
min:function min(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}return parseFloat(value)>=parameters;},//minimum string length
minLength:function minLength(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}return String(value).length>=parameters;},//maximum string length
maxLength:function maxLength(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}return String(value).length<=parameters;},//in provided value list
in:function _in(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}if(typeof parameters=="string"){parameters=parameters.split("|");}return value===""||parameters.indexOf(value)>-1;},//must match provided regex
regex:function regex(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}var reg=new RegExp(parameters);return reg.test(value);},//value must be unique in this column
unique:function unique(cell,value,parameters){if(value===""||value===null||typeof value==="undefined"){return true;}var unique=true;var cellData=cell.getData();var column=cell.getColumn()._getSelf();this.table.rowManager.rows.forEach(function(row){var data=row.getData();if(data!==cellData){if(value==column.getFieldValue(data)){unique=false;}}});return unique;},//must have a value
required:function required(cell,value,parameters){return value!==""&value!==null&&typeof value!=="undefined";}};Tabulator.prototype.registerModule("validate",Validate);return Tabulator;});
},{}],"js/frostbite2019/overview-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderOverviewTable = void 0;

var _tabulatorTables = _interopRequireDefault(require("tabulator-tables"));

var _data = require("./data");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ----
// function definitions
// ----
// this is called in two places: before constructing the Tabulator table, and
// inside a resize event listener
function adjustTableSettings(columnDefinitions) {
  if (window.innerWidth < 640) {
    columnDefinitions[0].field = "shortName";
  } else {
    columnDefinitions[0].field = "stage";
  }
} // This function gets passed to a formatter in the columns definition array.
// Defining it here keeps that column definition more neat.


function colorStarterRows(cell, formatterParams) {
  var cellValue = cell.getValue();

  if (cellValue) {
    var rowElement = cell.getRow().getElement();
    rowElement.classList.remove("light-yellow");
    rowElement.classList.remove("dark-yellow");
    rowElement.classList.add(rowElement.classList.contains("tabulator-row-odd") ? "light-yellow" : "dark-yellow");
  }

  return cellValue;
} // another column formatter


function formatAsPercent(cell, formatterParams) {
  return Math.round(cell.getValue() * 100) + "%";
} // ----
// general/overall summary table (tabulator)
// ----


var RenderOverviewTable = function RenderOverviewTable() {
  // Append percentages, a simple derived value, in decimal format.
  // Do not convert to a string that includes the % sign,
  // because that messes up the table's sorting.
  _data.stageStats.forEach(function (e) {
    e.gamesPlayedPercent = e.gamesPlayed / _data.globalStats.totalGames;
    e.setsPlayedPercent = e.setsPlayed / _data.globalStats.totalSets;
    e.gamesBannedPercent = e.gamesBanned / _data.globalStats.totalBans;
    e.setsBannedPercent = e.setsBanned / _data.globalStats.setsWithBanRecorded;
  });

  var stageStatsColumns = [{
    title: "Stage",
    field: "stage",
    widthGrow: 2,
    headerSortStartingDir: "desc",
    resizable: false,
    frozen: true
  }, {
    title: "Starter",
    field: "starter",
    widthGrow: 0,
    widthShrink: 1,
    visible: false,
    resizable: false,
    formatter: colorStarterRows
  }, {
    title: "Games Played",
    widthGrow: 1,
    columns: [{
      title: "#",
      field: "gamesPlayed",
      headerSortStartingDir: "desc",
      resizable: false
    }, {
      title: "%",
      field: "gamesPlayedPercent",
      headerSortStartingDir: "desc",
      resizable: false,
      formatter: formatAsPercent
    }]
  }, {
    title: "Times Banned",
    widthGrow: 1,
    resizable: false,
    columns: [{
      title: "#",
      field: "gamesBanned",
      headerSortStartingDir: "desc",
      resizable: false
    }, {
      title: "%",
      field: "gamesBannedPercent",
      headerSortStartingDir: "desc",
      resizable: false,
      formatter: formatAsPercent
    }]
  }, {
    title: "Sets Played In",
    widthGrow: 1,
    resizable: false,
    columns: [{
      title: "#",
      field: "setsPlayed",
      headerSortStartingDir: "desc",
      resizable: false
    }, {
      title: "%",
      field: "setsPlayedPercent",
      headerSortStartingDir: "desc",
      resizable: false,
      formatter: formatAsPercent
    }]
  }, {
    title: "Sets Banned In",
    widthGrow: 1,
    resizable: false,
    columns: [{
      title: "#",
      field: "setsBanned",
      headerSortStartingDir: "desc",
      resizable: false
    }, {
      title: "%",
      field: "setsBannedPercent",
      headerSortStartingDir: "desc",
      resizable: false,
      formatter: formatAsPercent
    }]
  }];
  adjustTableSettings(stageStatsColumns);
  var stageStatsTable = new _tabulatorTables.default("#overview-table", {
    data: _data.stageStats,
    layout: window.innerWidth < 640 ? "fitDataFill" : "fitColumns",
    initialSort: [{
      column: "gamesPlayed",
      dir: "desc"
    }],
    columns: stageStatsColumns
  });
  window.addEventListener('resize', function () {
    adjustTableSettings(stageStatsColumns);
    stageStatsTable.setColumns(stageStatsColumns);
    stageStatsTable.layout = window.innerWidth < 640 ? "fitDataFill" : "fitColumns";
    console.log("resize triggered, layout: " + stageStatsTable.layout);
    stageStatsTable.redraw(true);
  });
  var ulElem = document.querySelector("#other-stats");
  ulElem.innerHTML = "\n    <span>Total games: ".concat(_data.globalStats.totalGames, "</span>\n    <span>Total number of bans recorded: ").concat(_data.globalStats.totalBans, "</span>\n    <span>Total sets: ").concat(_data.globalStats.totalSets, "</span>\n    <span>Sets with bans recorded: ").concat(_data.globalStats.setsWithBanRecorded, "</span>\n    ");
};

exports.RenderOverviewTable = RenderOverviewTable;
},{"tabulator-tables":"../node_modules/tabulator-tables/dist/js/tabulator.js","./data":"js/frostbite2019/data.js"}],"js/frostbite2019/banrate-charts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderBanRateCharts = void 0;

var _chart = _interopRequireDefault(require("chart.js"));

var _chartjsPluginDeferred = _interopRequireDefault(require("chartjs-plugin-deferred"));

var _data = require("./data");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RenderBanRateCharts = function RenderBanRateCharts() {
  var dataSortedByBanned = Array.from(_data.stageStats).sort(function (a, b) {
    if (a.setsBanned > b.setsBanned) return -1;
    if (a.setsBanned < b.setsBanned) return 1;
    return 0;
  });
  var shortLabelsBanned = dataSortedByBanned.map(function (a) {
    return a.shortName;
  });
  var stageLabelsBanned = dataSortedByBanned.map(function (a) {
    return a.stage;
  });
  var gamesBannedBars = new _chart.default(document.getElementById("games-banned-bars").getContext('2d'), {
    type: 'horizontalBar',
    data: {
      labels: window.screen.width < 640 ? shortLabelsBanned : stageLabelsBanned,
      datasets: [{
        data: dataSortedByBanned.map(function (a) {
          return a.gamesBanned;
        }),
        backgroundColor: 'RGBA(171, 0, 14, .8)',
        hoverBackgroundColor: 'RGBA(130, 16, 15, 1)',
        datalabels: {
          display: false
        }
      }]
    },
    options: {
      title: {
        text: 'Total Times Banned'
      },
      legend: {
        display: false
      },
      plugins: {
        datalabels: {}
      }
    }
  });
  var setsBannedBars = new _chart.default(document.getElementById("sets-banned-bars").getContext('2d'), {
    type: 'horizontalBar',
    data: {
      labels: window.screen.width < 640 ? shortLabelsBanned : stageLabelsBanned,
      datasets: [{
        data: dataSortedByBanned.map(function (a) {
          return a.setsBanned / _data.globalStats.setsWithBanRecorded * 100;
        }),
        backgroundColor: 'RGBA(171, 0, 14, .8)',
        hoverBackgroundColor: 'RGBA(130, 16, 15, 1)',
        datalabels: {
          display: false
        }
      }]
    },
    options: {
      title: {
        text: 'Banned In % Of Sets'
      },
      legend: {
        display: false
      },
      plugins: {
        datalabels: {}
      }
    }
  });
};

exports.RenderBanRateCharts = RenderBanRateCharts;
},{"chart.js":"../node_modules/chart.js/src/chart.js","chartjs-plugin-deferred":"../node_modules/chartjs-plugin-deferred/dist/chartjs-plugin-deferred.js","./data":"js/frostbite2019/data.js"}],"js/frostbite2019/ban-pairs-charts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderBanPairsCharts = void 0;

var _tabulatorTables = _interopRequireDefault(require("tabulator-tables"));

var _data = require("./data");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RenderBanPairsCharts = function RenderBanPairsCharts() {
  // there *might* be a more elegant way to do this with .map or whatever,
  // but I'm out of time
  var pairCountColumns = [{
    title: "",
    field: "stageA",
    frozen: true,
    widthGrow: 2,
    minWidth: 180,
    resizable: false
  }];
  var pairPercentColumns = Array.from(pairCountColumns); // potential danger for bugs: the ordering in banPairs array is NOT guaranteed
  // to match the ordering in stages array

  for (var i = 0; i < _data.stages.length; i++) {
    pairCountColumns.push({
      title: _data.shortNames[i],
      field: _data.stages[i],
      headerVertical: "flip",
      align: "right",
      resizable: false
    });
    pairPercentColumns.push({
      title: _data.shortNames[i],
      field: _data.stages[i],
      headerVertical: "flip",
      align: "right",
      resizable: false,
      formatter: function formatter(cell, formatterParams) {
        var result = Number(cell.getValue() / 577 * 36).toFixed(2);
        cell.getElement().style.backgroundColor = "RGBA(130, 16, 15, ".concat(result / 8, ")");
        return result;
      }
    });
  }

  var barPairsTableCount = new _tabulatorTables.default("#ban-pairs-table-count", {
    data: _data.banPairs,
    layout: window.innerWidth < 640 ? "fitDataFill" : "fitColumns",
    columns: pairCountColumns
  });
  var barPairsTablePercent = new _tabulatorTables.default("#ban-pairs-table-percent", {
    data: _data.banPairs,
    layout: "fitDataFill",
    columns: pairPercentColumns
  });
};

exports.RenderBanPairsCharts = RenderBanPairsCharts;
},{"tabulator-tables":"../node_modules/tabulator-tables/dist/js/tabulator.js","./data":"js/frostbite2019/data.js"}],"../node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*!
 * @license
 * chartjs-plugin-datalabels
 * http://chartjs.org/
 * Version: 0.5.0
 *
 * Copyright 2018 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/chartjs-plugin-datalabels/blob/master/LICENSE.md
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('chart.js')) :
typeof define === 'function' && define.amd ? define(['chart.js'], factory) :
(global.ChartDataLabels = factory(global.Chart));
}(this, (function (Chart) { 'use strict';

Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;

var helpers = Chart.helpers;

var devicePixelRatio = (function() {
	if (typeof window !== 'undefined') {
		if (window.devicePixelRatio) {
			return window.devicePixelRatio;
		}

		// devicePixelRatio is undefined on IE10
		// https://stackoverflow.com/a/20204180/8837887
		// https://github.com/chartjs/chartjs-plugin-datalabels/issues/85
		var screen = window.screen;
		if (screen) {
			return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
		}
	}

	return 1;
}());

var utils = {
	// @todo move this in Chart.helpers.toTextLines
	toTextLines: function(inputs) {
		var lines = [];
		var input;

		inputs = [].concat(inputs);
		while (inputs.length) {
			input = inputs.pop();
			if (typeof input === 'string') {
				lines.unshift.apply(lines, input.split('\n'));
			} else if (Array.isArray(input)) {
				inputs.push.apply(inputs, input);
			} else if (!helpers.isNullOrUndef(inputs)) {
				lines.unshift('' + input);
			}
		}

		return lines;
	},

	// @todo move this method in Chart.helpers.canvas.toFont (deprecates helpers.fontString)
	// @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
	toFontString: function(font) {
		if (!font || helpers.isNullOrUndef(font.size) || helpers.isNullOrUndef(font.family)) {
			return null;
		}

		return (font.style ? font.style + ' ' : '')
			+ (font.weight ? font.weight + ' ' : '')
			+ font.size + 'px '
			+ font.family;
	},

	// @todo move this in Chart.helpers.canvas.textSize
	// @todo cache calls of measureText if font doesn't change?!
	textSize: function(ctx, lines, font) {
		var items = [].concat(lines);
		var ilen = items.length;
		var prev = ctx.font;
		var width = 0;
		var i;

		ctx.font = font.string;

		for (i = 0; i < ilen; ++i) {
			width = Math.max(ctx.measureText(items[i]).width, width);
		}

		ctx.font = prev;

		return {
			height: ilen * font.lineHeight,
			width: width
		};
	},

	// @todo move this method in Chart.helpers.options.toFont
	parseFont: function(value) {
		var global = Chart.defaults.global;
		var size = helpers.valueOrDefault(value.size, global.defaultFontSize);
		var font = {
			family: helpers.valueOrDefault(value.family, global.defaultFontFamily),
			lineHeight: helpers.options.toLineHeight(value.lineHeight, size),
			size: size,
			style: helpers.valueOrDefault(value.style, global.defaultFontStyle),
			weight: helpers.valueOrDefault(value.weight, null),
			string: ''
		};

		font.string = utils.toFontString(font);
		return font;
	},

	/**
	 * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
	 * @todo move this method in Chart.helpers.bound
	 * https://doc.qt.io/qt-5/qtglobal.html#qBound
	 */
	bound: function(min, value, max) {
		return Math.max(min, Math.min(value, max));
	},

	/**
	 * Returns an array of pair [value, state] where state is:
	 * * -1: value is only in a0 (removed)
	 * *  1: value is only in a1 (added)
	 */
	arrayDiff: function(a0, a1) {
		var prev = a0.slice();
		var updates = [];
		var i, j, ilen, v;

		for (i = 0, ilen = a1.length; i < ilen; ++i) {
			v = a1[i];
			j = prev.indexOf(v);

			if (j === -1) {
				updates.push([v, 1]);
			} else {
				prev.splice(j, 1);
			}
		}

		for (i = 0, ilen = prev.length; i < ilen; ++i) {
			updates.push([prev[i], -1]);
		}

		return updates;
	},

	/**
	 * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
	 */
	rasterize: function(v) {
		return Math.round(v * devicePixelRatio) / devicePixelRatio;
	}
};

function orient(point, origin) {
	var x0 = origin.x;
	var y0 = origin.y;

	if (x0 === null) {
		return {x: 0, y: -1};
	}
	if (y0 === null) {
		return {x: 1, y: 0};
	}

	var dx = point.x - x0;
	var dy = point.y - y0;
	var ln = Math.sqrt(dx * dx + dy * dy);

	return {
		x: ln ? dx / ln : 0,
		y: ln ? dy / ln : -1
	};
}

function aligned(x, y, vx, vy, align) {
	switch (align) {
	case 'center':
		vx = vy = 0;
		break;
	case 'bottom':
		vx = 0;
		vy = 1;
		break;
	case 'right':
		vx = 1;
		vy = 0;
		break;
	case 'left':
		vx = -1;
		vy = 0;
		break;
	case 'top':
		vx = 0;
		vy = -1;
		break;
	case 'start':
		vx = -vx;
		vy = -vy;
		break;
	case 'end':
		// keep natural orientation
		break;
	default:
		// clockwise rotation (in degree)
		align *= (Math.PI / 180);
		vx = Math.cos(align);
		vy = Math.sin(align);
		break;
	}

	return {
		x: x,
		y: y,
		vx: vx,
		vy: vy
	};
}

// Line clipping (CohenSutherland algorithm)
// https://en.wikipedia.org/wiki/CohenSutherland_algorithm

var R_INSIDE = 0;
var R_LEFT = 1;
var R_RIGHT = 2;
var R_BOTTOM = 4;
var R_TOP = 8;

function region(x, y, rect) {
	var res = R_INSIDE;

	if (x < rect.left) {
		res |= R_LEFT;
	} else if (x > rect.right) {
		res |= R_RIGHT;
	}
	if (y < rect.top) {
		res |= R_TOP;
	} else if (y > rect.bottom) {
		res |= R_BOTTOM;
	}

	return res;
}

function clipped(segment, area) {
	var x0 = segment.x0;
	var y0 = segment.y0;
	var x1 = segment.x1;
	var y1 = segment.y1;
	var r0 = region(x0, y0, area);
	var r1 = region(x1, y1, area);
	var r, x, y;

	// eslint-disable-next-line no-constant-condition
	while (true) {
		if (!(r0 | r1) || (r0 & r1)) {
			// both points inside or on the same side: no clipping
			break;
		}

		// at least one point is outside
		r = r0 || r1;

		if (r & R_TOP) {
			x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
			y = area.top;
		} else if (r & R_BOTTOM) {
			x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
			y = area.bottom;
		} else if (r & R_RIGHT) {
			y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
			x = area.right;
		} else if (r & R_LEFT) {
			y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
			x = area.left;
		}

		if (r === r0) {
			x0 = x;
			y0 = y;
			r0 = region(x0, y0, area);
		} else {
			x1 = x;
			y1 = y;
			r1 = region(x1, y1, area);
		}
	}

	return {
		x0: x0,
		x1: x1,
		y0: y0,
		y1: y1
	};
}

function compute(range, config) {
	var anchor = config.anchor;
	var segment = range;
	var x, y;

	if (config.clamp) {
		segment = clipped(segment, config.area);
	}

	if (anchor === 'start') {
		x = segment.x0;
		y = segment.y0;
	} else if (anchor === 'end') {
		x = segment.x1;
		y = segment.y1;
	} else {
		x = (segment.x0 + segment.x1) / 2;
		y = (segment.y0 + segment.y1) / 2;
	}

	return aligned(x, y, range.vx, range.vy, config.align);
}

var positioners = {
	arc: function(vm, config) {
		var angle = (vm.startAngle + vm.endAngle) / 2;
		var vx = Math.cos(angle);
		var vy = Math.sin(angle);
		var r0 = vm.innerRadius;
		var r1 = vm.outerRadius;

		return compute({
			x0: vm.x + vx * r0,
			y0: vm.y + vy * r0,
			x1: vm.x + vx * r1,
			y1: vm.y + vy * r1,
			vx: vx,
			vy: vy
		}, config);
	},

	point: function(vm, config) {
		var v = orient(vm, config.origin);
		var rx = v.x * vm.radius;
		var ry = v.y * vm.radius;

		return compute({
			x0: vm.x - rx,
			y0: vm.y - ry,
			x1: vm.x + rx,
			y1: vm.y + ry,
			vx: v.x,
			vy: v.y
		}, config);
	},

	rect: function(vm, config) {
		var v = orient(vm, config.origin);
		var x = vm.x;
		var y = vm.y;
		var sx = 0;
		var sy = 0;

		if (vm.horizontal) {
			x = Math.min(vm.x, vm.base);
			sx = Math.abs(vm.base - vm.x);
		} else {
			y = Math.min(vm.y, vm.base);
			sy = Math.abs(vm.base - vm.y);
		}

		return compute({
			x0: x,
			y0: y + sy,
			x1: x + sx,
			y1: y,
			vx: v.x,
			vy: v.y
		}, config);
	},

	fallback: function(vm, config) {
		var v = orient(vm, config.origin);

		return compute({
			x0: vm.x,
			y0: vm.y,
			x1: vm.x,
			y1: vm.y,
			vx: v.x,
			vy: v.y
		}, config);
	}
};

var helpers$1 = Chart.helpers;
var rasterize = utils.rasterize;

function boundingRects(model) {
	var borderWidth = model.borderWidth || 0;
	var padding = model.padding;
	var th = model.size.height;
	var tw = model.size.width;
	var tx = -tw / 2;
	var ty = -th / 2;

	return {
		frame: {
			x: tx - padding.left - borderWidth,
			y: ty - padding.top - borderWidth,
			w: tw + padding.width + borderWidth * 2,
			h: th + padding.height + borderWidth * 2
		},
		text: {
			x: tx,
			y: ty,
			w: tw,
			h: th
		}
	};
}

function getScaleOrigin(el) {
	var horizontal = el._model.horizontal;
	var scale = el._scale || (horizontal && el._xScale) || el._yScale;

	if (!scale) {
		return null;
	}

	if (scale.xCenter !== undefined && scale.yCenter !== undefined) {
		return {x: scale.xCenter, y: scale.yCenter};
	}

	var pixel = scale.getBasePixel();
	return horizontal ?
		{x: pixel, y: null} :
		{x: null, y: pixel};
}

function getPositioner(el) {
	if (el instanceof Chart.elements.Arc) {
		return positioners.arc;
	}
	if (el instanceof Chart.elements.Point) {
		return positioners.point;
	}
	if (el instanceof Chart.elements.Rectangle) {
		return positioners.rect;
	}
	return positioners.fallback;
}

function drawFrame(ctx, rect, model) {
	var bgColor = model.backgroundColor;
	var borderColor = model.borderColor;
	var borderWidth = model.borderWidth;

	if (!bgColor && (!borderColor || !borderWidth)) {
		return;
	}

	ctx.beginPath();

	helpers$1.canvas.roundedRect(
		ctx,
		rasterize(rect.x) + borderWidth / 2,
		rasterize(rect.y) + borderWidth / 2,
		rasterize(rect.w) - borderWidth,
		rasterize(rect.h) - borderWidth,
		model.borderRadius);

	ctx.closePath();

	if (bgColor) {
		ctx.fillStyle = bgColor;
		ctx.fill();
	}

	if (borderColor && borderWidth) {
		ctx.strokeStyle = borderColor;
		ctx.lineWidth = borderWidth;
		ctx.lineJoin = 'miter';
		ctx.stroke();
	}
}

function textGeometry(rect, align, font) {
	var h = font.lineHeight;
	var w = rect.w;
	var x = rect.x;
	var y = rect.y + h / 2;

	if (align === 'center') {
		x += w / 2;
	} else if (align === 'end' || align === 'right') {
		x += w;
	}

	return {
		h: h,
		w: w,
		x: x,
		y: y
	};
}

function drawTextLine(ctx, text, cfg) {
	var shadow = ctx.shadowBlur;
	var stroked = cfg.stroked;
	var x = rasterize(cfg.x);
	var y = rasterize(cfg.y);
	var w = rasterize(cfg.w);

	if (stroked) {
		ctx.strokeText(text, x, y, w);
	}

	if (cfg.filled) {
		if (shadow && stroked) {
			// Prevent drawing shadow on both the text stroke and fill, so
			// if the text is stroked, remove the shadow for the text fill.
			ctx.shadowBlur = 0;
		}

		ctx.fillText(text, x, y, w);

		if (shadow && stroked) {
			ctx.shadowBlur = shadow;
		}
	}
}

function drawText(ctx, lines, rect, model) {
	var align = model.textAlign;
	var color = model.color;
	var filled = !!color;
	var font = model.font;
	var ilen = lines.length;
	var strokeColor = model.textStrokeColor;
	var strokeWidth = model.textStrokeWidth;
	var stroked = strokeColor && strokeWidth;
	var i;

	if (!ilen || (!filled && !stroked)) {
		return;
	}

	// Adjust coordinates based on text alignment and line height
	rect = textGeometry(rect, align, font);

	ctx.font = font.string;
	ctx.textAlign = align;
	ctx.textBaseline = 'middle';
	ctx.shadowBlur = model.textShadowBlur;
	ctx.shadowColor = model.textShadowColor;

	if (filled) {
		ctx.fillStyle = color;
	}
	if (stroked) {
		ctx.lineJoin = 'round';
		ctx.lineWidth = strokeWidth;
		ctx.strokeStyle = strokeColor;
	}

	for (i = 0, ilen = lines.length; i < ilen; ++i) {
		drawTextLine(ctx, lines[i], {
			stroked: stroked,
			filled: filled,
			w: rect.w,
			x: rect.x,
			y: rect.y + rect.h * i
		});
	}
}

var Label = function(config, ctx, el, index) {
	var me = this;

	me._config = config;
	me._index = index;
	me._model = null;
	me._rects = null;
	me._ctx = ctx;
	me._el = el;
};

helpers$1.extend(Label.prototype, {
	/**
	 * @private
	 */
	_modelize: function(display, lines, config, context) {
		var me = this;
		var index = me._index;
		var resolve = helpers$1.options.resolve;
		var font = utils.parseFont(resolve([config.font, {}], context, index));
		var color = resolve([config.color, Chart.defaults.global.defaultFontColor], context, index);

		return {
			align: resolve([config.align, 'center'], context, index),
			anchor: resolve([config.anchor, 'center'], context, index),
			area: context.chart.chartArea,
			backgroundColor: resolve([config.backgroundColor, null], context, index),
			borderColor: resolve([config.borderColor, null], context, index),
			borderRadius: resolve([config.borderRadius, 0], context, index),
			borderWidth: resolve([config.borderWidth, 0], context, index),
			clamp: resolve([config.clamp, false], context, index),
			clip: resolve([config.clip, false], context, index),
			color: color,
			display: display,
			font: font,
			lines: lines,
			offset: resolve([config.offset, 0], context, index),
			opacity: resolve([config.opacity, 1], context, index),
			origin: getScaleOrigin(me._el),
			padding: helpers$1.options.toPadding(resolve([config.padding, 0], context, index)),
			positioner: getPositioner(me._el),
			rotation: resolve([config.rotation, 0], context, index) * (Math.PI / 180),
			size: utils.textSize(me._ctx, lines, font),
			textAlign: resolve([config.textAlign, 'start'], context, index),
			textShadowBlur: resolve([config.textShadowBlur, 0], context, index),
			textShadowColor: resolve([config.textShadowColor, color], context, index),
			textStrokeColor: resolve([config.textStrokeColor, color], context, index),
			textStrokeWidth: resolve([config.textStrokeWidth, 0], context, index)
		};
	},

	update: function(context) {
		var me = this;
		var model = null;
		var rects = null;
		var index = me._index;
		var config = me._config;
		var value, label, lines;

		// We first resolve the display option (separately) to avoid computing
		// other options in case the label is hidden (i.e. display: false).
		var display = helpers$1.options.resolve([config.display, true], context, index);

		if (display) {
			value = context.dataset.data[index];
			label = helpers$1.valueOrDefault(helpers$1.callback(config.formatter, [value, context]), value);
			lines = helpers$1.isNullOrUndef(label) ? [] : utils.toTextLines(label);

			if (lines.length) {
				model = me._modelize(display, lines, config, context);
				rects = boundingRects(model);
			}
		}

		me._model = model;
		me._rects = rects;
	},

	geometry: function() {
		return this._rects ? this._rects.frame : {};
	},

	rotation: function() {
		return this._model ? this._model.rotation : 0;
	},

	visible: function() {
		return this._model && this._model.opacity;
	},

	model: function() {
		return this._model;
	},

	draw: function(chart, center) {
		var me = this;
		var ctx = chart.ctx;
		var model = me._model;
		var rects = me._rects;
		var area;

		if (!this.visible()) {
			return;
		}

		ctx.save();

		if (model.clip) {
			area = model.area;
			ctx.beginPath();
			ctx.rect(
				area.left,
				area.top,
				area.right - area.left,
				area.bottom - area.top);
			ctx.clip();
		}

		ctx.globalAlpha = utils.bound(0, model.opacity, 1);
		ctx.translate(rasterize(center.x), rasterize(center.y));
		ctx.rotate(model.rotation);

		drawFrame(ctx, rects.frame, model);
		drawText(ctx, model.lines, rects.text, model);

		ctx.restore();
	}
});

var helpers$2 = Chart.helpers;

var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

function rotated(point, center, angle) {
	var cos = Math.cos(angle);
	var sin = Math.sin(angle);
	var cx = center.x;
	var cy = center.y;

	return {
		x: cx + cos * (point.x - cx) - sin * (point.y - cy),
		y: cy + sin * (point.x - cx) + cos * (point.y - cy)
	};
}

function projected(points, axis) {
	var min = MAX_INTEGER;
	var max = MIN_INTEGER;
	var origin = axis.origin;
	var i, pt, vx, vy, dp;

	for (i = 0; i < points.length; ++i) {
		pt = points[i];
		vx = pt.x - origin.x;
		vy = pt.y - origin.y;
		dp = axis.vx * vx + axis.vy * vy;
		min = Math.min(min, dp);
		max = Math.max(max, dp);
	}

	return {
		min: min,
		max: max
	};
}

function toAxis(p0, p1) {
	var vx = p1.x - p0.x;
	var vy = p1.y - p0.y;
	var ln = Math.sqrt(vx * vx + vy * vy);

	return {
		vx: (p1.x - p0.x) / ln,
		vy: (p1.y - p0.y) / ln,
		origin: p0,
		ln: ln
	};
}

var HitBox = function() {
	this._rotation = 0;
	this._rect = {
		x: 0,
		y: 0,
		w: 0,
		h: 0
	};
};

helpers$2.extend(HitBox.prototype, {
	center: function() {
		var r = this._rect;
		return {
			x: r.x + r.w / 2,
			y: r.y + r.h / 2
		};
	},

	update: function(center, rect, rotation) {
		this._rotation = rotation;
		this._rect = {
			x: rect.x + center.x,
			y: rect.y + center.y,
			w: rect.w,
			h: rect.h
		};
	},

	contains: function(point) {
		var me = this;
		var margin = 1;
		var rect = me._rect;

		point = rotated(point, me.center(), -me._rotation);

		return !(point.x < rect.x - margin
			|| point.y < rect.y - margin
			|| point.x > rect.x + rect.w + margin * 2
			|| point.y > rect.y + rect.h + margin * 2);
	},

	// Separating Axis Theorem
	// https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
	intersects: function(other) {
		var r0 = this._points();
		var r1 = other._points();
		var axes = [
			toAxis(r0[0], r0[1]),
			toAxis(r0[0], r0[3])
		];
		var i, pr0, pr1;

		if (this._rotation !== other._rotation) {
			// Only separate with r1 axis if the rotation is different,
			// else it's enough to separate r0 and r1 with r0 axis only!
			axes.push(
				toAxis(r1[0], r1[1]),
				toAxis(r1[0], r1[3])
			);
		}

		for (i = 0; i < axes.length; ++i) {
			pr0 = projected(r0, axes[i]);
			pr1 = projected(r1, axes[i]);

			if (pr0.max < pr1.min || pr1.max < pr0.min) {
				return false;
			}
		}

		return true;
	},

	/**
	 * @private
	 */
	_points: function() {
		var me = this;
		var rect = me._rect;
		var angle = me._rotation;
		var center = me.center();

		return [
			rotated({x: rect.x, y: rect.y}, center, angle),
			rotated({x: rect.x + rect.w, y: rect.y}, center, angle),
			rotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),
			rotated({x: rect.x, y: rect.y + rect.h}, center, angle)
		];
	}
});

function coordinates(view, model, geometry) {
	var point = model.positioner(view, model);
	var vx = point.vx;
	var vy = point.vy;

	if (!vx && !vy) {
		// if aligned center, we don't want to offset the center point
		return {x: point.x, y: point.y};
	}

	var w = geometry.w;
	var h = geometry.h;

	// take in account the label rotation
	var rotation = model.rotation;
	var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
	var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));

	// scale the unit vector (vx, vy) to get at least dx or dy equal to
	// w or h respectively (else we would calculate the distance to the
	// ellipse inscribed in the bounding rect)
	var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
	dx *= vx * vs;
	dy *= vy * vs;

	// finally, include the explicit offset
	dx += model.offset * vx;
	dy += model.offset * vy;

	return {
		x: point.x + dx,
		y: point.y + dy
	};
}

function collide(labels, collider) {
	var i, j, s0, s1;

	// IMPORTANT Iterate in the reverse order since items at the end of the
	// list have an higher weight/priority and thus should be less impacted
	// by the overlapping strategy.

	for (i = labels.length - 1; i >= 0; --i) {
		s0 = labels[i].$layout;

		for (j = i - 1; j >= 0 && s0._visible; --j) {
			s1 = labels[j].$layout;

			if (s1._visible && s0._box.intersects(s1._box)) {
				collider(s0, s1);
			}
		}
	}

	return labels;
}

function compute$1(labels) {
	var i, ilen, label, state, geometry, center;

	// Initialize labels for overlap detection
	for (i = 0, ilen = labels.length; i < ilen; ++i) {
		label = labels[i];
		state = label.$layout;

		if (state._visible) {
			geometry = label.geometry();
			center = coordinates(label._el._model, label.model(), geometry);
			state._box.update(center, geometry, label.rotation());
		}
	}

	// Auto hide overlapping labels
	return collide(labels, function(s0, s1) {
		var h0 = s0._hidable;
		var h1 = s1._hidable;

		if ((h0 && h1) || h1) {
			s1._visible = false;
		} else if (h0) {
			s0._visible = false;
		}
	});
}

var layout = {
	prepare: function(datasets) {
		var labels = [];
		var i, j, ilen, jlen, label;

		for (i = 0, ilen = datasets.length; i < ilen; ++i) {
			for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
				label = datasets[i][j];
				labels.push(label);
				label.$layout = {
					_box: new HitBox(),
					_hidable: false,
					_visible: true,
					_set: i,
					_idx: j
				};
			}
		}

		// TODO New `z` option: labels with a higher z-index are drawn
		// of top of the ones with a lower index. Lowest z-index labels
		// are also discarded first when hiding overlapping labels.
		labels.sort(function(a, b) {
			var sa = a.$layout;
			var sb = b.$layout;

			return sa._idx === sb._idx
				? sa._set - sb._set
				: sb._idx - sa._idx;
		});

		this.update(labels);

		return labels;
	},

	update: function(labels) {
		var dirty = false;
		var i, ilen, label, model, state;

		for (i = 0, ilen = labels.length; i < ilen; ++i) {
			label = labels[i];
			model = label.model();
			state = label.$layout;
			state._hidable = model && model.display === 'auto';
			state._visible = label.visible();
			dirty |= state._hidable;
		}

		if (dirty) {
			compute$1(labels);
		}
	},

	lookup: function(labels, point) {
		var i, state;

		// IMPORTANT Iterate in the reverse order since items at the end of
		// the list have an higher z-index, thus should be picked first.

		for (i = labels.length - 1; i >= 0; --i) {
			state = labels[i].$layout;

			if (state && state._visible && state._box.contains(point)) {
				return {
					dataset: state._set,
					label: labels[i]
				};
			}
		}

		return null;
	},

	draw: function(chart, labels) {
		var i, ilen, label, state, geometry, center;

		for (i = 0, ilen = labels.length; i < ilen; ++i) {
			label = labels[i];
			state = label.$layout;

			if (state._visible) {
				geometry = label.geometry();
				center = coordinates(label._el._view, label.model(), geometry);
				state._box.update(center, geometry, label.rotation());
				label.draw(chart, center);
			}
		}
	}
};

/**
 * @module Options
 */

var helpers$3 = Chart.helpers;

var defaults = {
	/**
	 * The label box alignment relative to `anchor` that can be expressed either by a number
	 * representing the clockwise angle (in degree) or by one of the following string presets:
	 * - 'start': before the anchor point, following the same direction
	 * - 'end': after the anchor point, following the same direction
	 * - 'center': centered on the anchor point
	 * - 'right': 0
	 * - 'bottom': 90
	 * - 'left': 180
	 * - 'top': 270
	 * @member {String|Number|Array|Function}
	 * @default 'center'
	 */
	align: 'center',

	/**
	 * The label box alignment relative to the element ('start'|'center'|'end')
	 * @member {String|Array|Function}
	 * @default 'center'
	 */
	anchor: 'center',

	/**
	 * The color used to draw the background of the surrounding frame.
	 * @member {String|Array|Function|null}
	 * @default null (no background)
	 */
	backgroundColor: null,

	/**
	 * The color used to draw the border of the surrounding frame.
	 * @member {String|Array|Function|null}
	 * @default null (no border)
	 */
	borderColor: null,

	/**
	 * The border radius used to add rounded corners to the surrounding frame.
	 * @member {Number|Array|Function}
	 * @default 0 (not rounded)
	 */
	borderRadius: 0,

	/**
	 * The border width of the surrounding frame.
	 * @member {Number|Array|Function}
	 * @default 0 (no border)
	 */
	borderWidth: 0,

	/**
	 * When `true`, the anchor position is calculated based on the visible
	 * geometry of the associated element (i.e. part inside the chart area).
	 * @see https://github.com/chartjs/chartjs-plugin-datalabels/issues/98
	 * @member {Boolean|Array|Function}
	 * @default false
	 */
	clamp: false,

	/**
	 * Clip the label drawing to the chart area.
	 * @member {Boolean|Array|Function}
	 * @default false (no clipping)
	 */
	clip: false,

	/**
	 * The color used to draw the label text.
	 * @member {String|Array|Function}
	 * @default undefined (use Chart.defaults.global.defaultFontColor)
	 */
	color: undefined,

	/**
	 * When `false`, the label is hidden and associated options are not
	 * calculated, else if `true`, the label is drawn. If `auto`, the
	 * label is automatically hidden if it appears under another label.
	 * @member {Boolean|String|Array|Function}
	 * @default true
	 */
	display: true,

	/**
	 * The font options used to draw the label text.
	 * @member {Object|Array|Function}
	 * @prop {String} font.family - defaults to Chart.defaults.global.defaultFontFamily
	 * @prop {Number} font.lineHeight - defaults to 1.2
	 * @prop {Number} font.size - defaults to Chart.defaults.global.defaultFontSize
	 * @prop {String} font.style - defaults to Chart.defaults.global.defaultFontStyle
	 * @prop {Number} font.weight - defaults to 'normal'
	 * @default Chart.defaults.global.defaultFont.*
	 */
	font: {
		family: undefined,
		lineHeight: 1.2,
		size: undefined,
		style: undefined,
		weight: null
	},

	/**
	 * Allows to customize the label text by transforming input data.
	 * @member {Function|null}
	 * @prop {*} value - The data value
	 * @prop {Object} context - The function unique argument:
	 * @prop {Chart} context.chart - The current chart
	 * @prop {Number} context.dataIndex - Index of the current data
	 * @prop {Object} context.dataset - The current dataset
	 * @prop {Number} context.datasetIndex - Index of the current dataset
	 * @default data[index]
	 */
	formatter: function(value) {
		if (helpers$3.isNullOrUndef(value)) {
			return null;
		}

		var label = value;
		var keys, klen, k;
		if (helpers$3.isObject(value)) {
			if (!helpers$3.isNullOrUndef(value.label)) {
				label = value.label;
			} else if (!helpers$3.isNullOrUndef(value.r)) {
				label = value.r;
			} else {
				label = '';
				keys = Object.keys(value);
				for (k = 0, klen = keys.length; k < klen; ++k) {
					label += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];
				}
			}
		}
		return '' + label;
	},

	/**
	 * Event listeners, where the property is the type of the event to listen and the value
	 * a callback with a unique `context` argument containing the same information as for
	 * scriptable options. If a callback explicitly returns `true`, the label is updated
	 * with the current context and the chart re-rendered. This allows to implement visual
	 * interactions with labels such as highlight, selection, etc.
	 *
	 * Event currently supported are:
	 * - 'click': a mouse click is detected within a label
	 * - 'enter': the mouse enters a label
	 * - 'leave': the mouse leaves a label
	 *
	 * @member {Object}
	 * @default {}
	 */
	listeners: {},

	/**
	 * The distance (in pixels) to pull the label away from the anchor point, the direction
	 * being determined by the `align` value (only applicable if `align` is `start` or `end`).
	 * @member {Number|Array|Function}
	 * @default 4
	 */
	offset: 4,

	/**
	 * The label global opacity, including the text, background, borders, etc., specified as
	 * a number between 0.0 (fully transparent) and 1.0 (fully opaque).
	 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalAlpha
	 * @member {Number|Array|Function}
	 * @default 1
	 */
	opacity: 1,

	/**
	 * The padding (in pixels) to apply between the text and the surrounding frame.
	 * @member {Number|Object|Array|Function}
	 * @prop {Number} padding.top - Space above the text.
	 * @prop {Number} padding.right - Space on the right of the text.
	 * @prop {Number} padding.bottom - Space below the text.
	 * @prop {Number} padding.left - Space on the left of the text.
	 * @default 4 (all values)
	 */
	padding: {
		top: 4,
		right: 4,
		bottom: 4,
		left: 4
	},

	/**
	 * Clockwise rotation of the label relative to its center.
	 * @member {Number|Array|Function}
	 * @default 0
	 */
	rotation: 0,

	/**
	 * Text alignment for multi-lines labels ('left'|'right'|'start'|'center'|'end').
	 * @member {String|Array|Function}
	 * @default 'start'
	 */
	textAlign: 'start',

	/**
	 * The stroke color used to draw the label text. If this options is
	 * not set (default), the value of the `color` option will be used.
	 * @member {String|Array|Function|null}
	 * @default color
	 */
	textStrokeColor: undefined,

	/**
	 * The width of the stroke for the label text.
	 * @member {Number|Array|Function}
	 * @default 0 (no stroke)
	 */
	textStrokeWidth: 0,

	/**
	 * The amount of blur applied to shadow under the label text.
	 * @member {Number|Array|Function}
	 * @default 0 (no shadow)
	 */
	textShadowBlur: 0,

	/**
	 * The color of the shadow under the label text.
	 * @member {String|Array|Function|null}
	 * @default `color`
	 */
	textShadowColor: undefined,
};

/**
 * @see https://github.com/chartjs/Chart.js/issues/4176
 */

var helpers$4 = Chart.helpers;
var EXPANDO_KEY = '$datalabels';

Chart.defaults.global.plugins.datalabels = defaults;

function configure(dataset, options) {
	var override = dataset.datalabels;
	var config = {};

	if (override === false) {
		return null;
	}
	if (override === true) {
		override = {};
	}

	return helpers$4.merge(config, [options, override]);
}

function dispatchEvent(chart, listeners, target) {
	var callback = listeners && listeners[target.dataset];
	if (!callback) {
		return;
	}

	var label = target.label;
	var context = label.$context;

	if (helpers$4.callback(callback, [context]) === true) {
		// Users are allowed to tweak the given context by injecting values that can be
		// used in scriptable options to display labels differently based on the current
		// event (e.g. highlight an hovered label). That's why we update the label with
		// the output context and schedule a new chart render by setting it dirty.
		chart[EXPANDO_KEY]._dirty = true;
		label.update(context);
	}
}

function dispatchMoveEvents(chart, listeners, previous, target) {
	var enter, leave;

	if (!previous && !target) {
		return;
	}

	if (!previous) {
		enter = true;
	} else if (!target) {
		leave = true;
	} else if (previous.label !== target.label) {
		leave = enter = true;
	}

	if (leave) {
		dispatchEvent(chart, listeners.leave, previous);
	}
	if (enter) {
		dispatchEvent(chart, listeners.enter, target);
	}
}

function handleMoveEvents(chart, event) {
	var expando = chart[EXPANDO_KEY];
	var listeners = expando._listeners;
	var previous, target;

	if (!listeners.enter && !listeners.leave) {
		return;
	}

	if (event.type === 'mousemove') {
		target = layout.lookup(expando._labels, event);
	} else if (event.type !== 'mouseout') {
		return;
	}

	previous = expando._hovered;
	expando._hovered = target;
	dispatchMoveEvents(chart, listeners, previous, target);
}

function handleClickEvents(chart, event) {
	var expando = chart[EXPANDO_KEY];
	var handlers = expando._listeners.click;
	var target = handlers && layout.lookup(expando._labels, event);
	if (target) {
		dispatchEvent(chart, handlers, target);
	}
}

Chart.defaults.global.plugins.datalabels = defaults;

var plugin = {
	id: 'datalabels',

	beforeInit: function(chart) {
		chart[EXPANDO_KEY] = {
			_actives: []
		};
	},

	beforeUpdate: function(chart) {
		var expando = chart[EXPANDO_KEY];
		expando._listened = false;
		expando._listeners = {};     // {event-type: {dataset-index: function}}
		expando._datasets = [];      // per dataset labels: [[Label]]
		expando._labels = [];        // layouted labels: [Label]
	},

	afterDatasetUpdate: function(chart, args, options) {
		var datasetIndex = args.index;
		var expando = chart[EXPANDO_KEY];
		var labels = expando._datasets[datasetIndex] = [];
		var visible = chart.isDatasetVisible(datasetIndex);
		var dataset = chart.data.datasets[datasetIndex];
		var config = configure(dataset, options);
		var elements = args.meta.data || [];
		var ilen = elements.length;
		var ctx = chart.ctx;
		var i, el, label;

		ctx.save();

		for (i = 0; i < ilen; ++i) {
			el = elements[i];

			if (visible && el && !el.hidden && !el._model.skip) {
				labels.push(label = new Label(config, ctx, el, i));
				label.update(label.$context = {
					active: false,
					chart: chart,
					dataIndex: i,
					dataset: dataset,
					datasetIndex: datasetIndex
				});
			} else {
				label = null;
			}

			el[EXPANDO_KEY] = label;
		}

		ctx.restore();

		// Store listeners at the chart level and per event type to optimize
		// cases where no listeners are registered for a specific event
		helpers$4.merge(expando._listeners, config.listeners || {}, {
			merger: function(key, target, source) {
				target[key] = target[key] || {};
				target[key][args.index] = source[key];
				expando._listened = true;
			}
		});
	},

	afterUpdate: function(chart, options) {
		chart[EXPANDO_KEY]._labels = layout.prepare(
			chart[EXPANDO_KEY]._datasets,
			options);
	},

	// Draw labels on top of all dataset elements
	// https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
	// https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
	afterDatasetsDraw: function(chart) {
		layout.draw(chart, chart[EXPANDO_KEY]._labels);
	},

	beforeEvent: function(chart, event) {
		// If there is no listener registered for this chart, `listened` will be false,
		// meaning we can immediately ignore the incoming event and avoid useless extra
		// computation for users who don't implement label interactions.
		if (chart[EXPANDO_KEY]._listened) {
			switch (event.type) {
			case 'mousemove':
			case 'mouseout':
				handleMoveEvents(chart, event);
				break;
			case 'click':
				handleClickEvents(chart, event);
				break;
			default:
			}
		}
	},

	afterEvent: function(chart) {
		var expando = chart[EXPANDO_KEY];
		var previous = expando._actives;
		var actives = expando._actives = chart.lastActive || [];  // public API?!
		var updates = utils.arrayDiff(previous, actives);
		var i, ilen, update, label;

		for (i = 0, ilen = updates.length; i < ilen; ++i) {
			update = updates[i];
			if (update[1]) {
				label = update[0][EXPANDO_KEY];
				if (label) {
					label.$context.active = (update[1] === 1);
					label.update(label.$context);
				}
			}
		}

		if (expando._dirty || updates.length) {
			layout.update(expando._labels);
			if (!chart.animating) {
				chart.render();
			}
		}

		delete expando._dirty;
	}
};

// TODO Remove at version 1, we shouldn't automatically register plugins.
// https://github.com/chartjs/chartjs-plugin-datalabels/issues/42
Chart.plugins.register(plugin);

return plugin;

})));

},{"chart.js":"../node_modules/chart.js/src/chart.js"}],"js/chart-settings.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colorSettings = void 0;

var _chart = _interopRequireDefault(require("chart.js"));

var _chartjsPluginDeferred = _interopRequireDefault(require("chartjs-plugin-deferred"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_chart.default.defaults.global.responsive = true;
_chart.default.defaults.global.maintainAspectRatio = false;
_chart.default.defaults.global.defaultFontColor = 'black';
_chart.default.defaults.global.defaultFontFamily = "'Noto Sans', 'Open Sans', 'Roboto', 'Droid Sans', 'Arial', sans-serif";
_chart.default.defaults.global.defaultFontSize = 16;
_chart.default.defaults.global.title.display = true;
_chart.default.defaults.global.title.fontSize = 20;
_chart.default.defaults.global.title.defaultFontFamily = "'Noto Sans', 'Open Sans', 'Roboto', 'Droid Sans', 'Arial', sans-serif";
_chart.default.defaults.global.legend.position = 'bottom';
_chart.default.defaults.global.plugins.deferred.yOffset = '50%';
_chart.default.defaults.global.plugins.datalabels.anchor = 'center';
_chart.default.defaults.global.plugins.datalabels.align = 'end';
_chart.default.defaults.global.plugins.datalabels.offset = 12;
_chart.default.defaults.global.plugins.datalabels.clamp = true;
_chart.default.defaults.global.plugins.datalabels.display = 'auto';
var colorSettings = {
  backgroundColor: ['rgba(255, 56, 55, .4)', 'rgba(48, 138, 255, .4)', 'rgba(255, 188, 22, .4)', 'rgba(41, 181, 72, .4)', 'rgba(250, 135, 55, .4)', 'rgba(46, 210, 235, .4)', 'rgba(255, 157, 182, .4)', 'rgba(148, 113, 255, .4)', 'rgba(135, 255, 205, .4)'],
  borderColor: ['rgba(255, 56, 55, 1)', 'rgba(48, 138, 255, 1)', 'rgba(255, 188, 22, 1)', 'rgba(41, 181, 72, 1)', 'rgba(250, 135, 55, 1)', 'rgba(46, 210, 235, 1)', 'rgba(255, 157, 182, 1)', 'rgba(148, 113, 255, 1)', 'rgba(135, 255, 205, 1)'],
  borderWidth: 1
};
exports.colorSettings = colorSettings;
},{"chart.js":"../node_modules/chart.js/src/chart.js","chartjs-plugin-deferred":"../node_modules/chartjs-plugin-deferred/dist/chartjs-plugin-deferred.js"}],"js/frostbite2019/starter-charts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderStarterCharts = void 0;

var _chart = _interopRequireDefault(require("chart.js"));

var _chartjsPluginDeferred = _interopRequireDefault(require("chartjs-plugin-deferred"));

var _chartjsPluginDatalabels = _interopRequireDefault(require("chartjs-plugin-datalabels"));

var _chartSettings = require("../chart-settings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MANUAL_DATA = {
  g1TotalGames: 535,
  g1TotalAgreed: 315,
  g1TotalStriked: 213,
  game3Played: 115,
  starterNames: ['Pokmon Stadium 2', 'Battlefield', 'Town And City', 'Smashville', 'Final Destination'],
  shortStarters: ['PS2', 'BF', 'SV', 'FD', 'T&C'],
  g1AgreedData: [270, 16, 10, 14, 5],
  g1StrikedData: [50, 62, 56, 30, 15]
};

var RenderStarterCharts = function RenderStarterCharts() {
  var selectionMethodPie = new _chart.default(document.getElementById("selection-method-pie").getContext('2d'), {
    type: 'pie',
    data: {
      labels: ["Striking", "Mutual Agreement"],
      datasets: [Object.assign({
        label: 'Sets',
        data: [MANUAL_DATA.g1TotalStriked, MANUAL_DATA.g1TotalAgreed]
      }, _chartSettings.colorSettings)]
    },
    options: {
      title: {
        text: 'Selection Method'
      },
      plugins: {
        datalabels: {
          formatter: function formatter(value, context) {
            return Math.round(value / MANUAL_DATA.g1TotalGames * 100) + "%";
          }
        }
      },
      legend: {
        reverse: true
      }
    }
  });
  var agreedStagePie = new _chart.default(document.getElementById("agreed-stage-pie").getContext('2d'), {
    type: 'pie',
    data: {
      labels: MANUAL_DATA.starterNames,
      datasets: [Object.assign({
        label: 'Sets',
        data: MANUAL_DATA.g1AgreedData,
        datalabels: {
          display: function display(context) {
            return context.dataIndex < context.dataset.data.length - 1;
          }
        }
      }, _chartSettings.colorSettings)]
    },
    options: {
      title: {
        text: 'Starters Via Agreement'
      },
      plugins: {
        datalabels: {
          formatter: function formatter(value, context) {
            return Math.round(value / MANUAL_DATA.g1TotalAgreed * 100) + "%";
          }
        }
      }
    }
  });
  var strikedStagePie = new _chart.default(document.getElementById("striked-stage-pie").getContext('2d'), {
    type: 'pie',
    data: {
      labels: MANUAL_DATA.starterNames,
      datasets: [Object.assign({
        label: 'Sets',
        data: MANUAL_DATA.g1StrikedData
      }, _chartSettings.colorSettings)]
    },
    options: {
      title: {
        text: 'Starters Via Striking'
      },
      plugins: {
        datalabels: {
          formatter: function formatter(value, context) {
            return Math.round(value / MANUAL_DATA.g1TotalStriked * 100) + "%";
          }
        }
      }
    }
  });
  var game1StackedBars = new _chart.default(document.getElementById("game1-stacked-bars").getContext('2d'), {
    type: 'horizontalBar',
    data: {
      labels: window.screen.width < 640 ? MANUAL_DATA.shortStarters : MANUAL_DATA.starterNames,
      datasets: [{
        label: 'Agreement',
        data: MANUAL_DATA.g1AgreedData,
        backgroundColor: 'RGBA(110, 105, 250, .8)',
        datalabels: {
          display: false
        }
      }, {
        label: 'Striking',
        data: MANUAL_DATA.g1StrikedData,
        backgroundColor: 'RGBA(148, 113, 255, .6)',
        datalabels: {
          display: false
        }
      }]
    },
    options: {
      title: {
        text: 'All Game 1s, Both Methods'
      },
      plugins: {
        datalabels: {}
      },
      scales: {
        xAxes: [{
          stacked: true
        }],
        yAxes: [{
          stacked: true
        }]
      }
    }
  });
};

exports.RenderStarterCharts = RenderStarterCharts;
},{"chart.js":"../node_modules/chart.js/src/chart.js","chartjs-plugin-deferred":"../node_modules/chartjs-plugin-deferred/dist/chartjs-plugin-deferred.js","chartjs-plugin-datalabels":"../node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js","../chart-settings":"js/chart-settings.js"}],"js/frostbite2019/main.js":[function(require,module,exports) {
"use strict";

require("../../css/main.scss");

var _drawer = require("@material/drawer");

var _topAppBar = require("@material/top-app-bar");

var _playrateCharts = require("./playrate-charts");

var _overviewTable = require("./overview-table");

var _banrateCharts = require("./banrate-charts");

var _banPairsCharts = require("./ban-pairs-charts");

var _starterCharts = require("./starter-charts");

// responsive top bar title / make the bar contents fit on phones
// Tabulator tables have their own resize listeners too, in overview_table.js
var barTitleElem = document.querySelector('.mdc-top-app-bar__title');

if (window.innerWidth < 640) {
  barTitleElem.innerHTML = "Stage Stats: Frostbite";
}

window.addEventListener('resize', function () {
  if (window.innerWidth < 640) {
    barTitleElem.innerHTML = "Stage Stats: Frostbite";
  } else {
    barTitleElem.innerHTML = "SSBU Stage Stats: Frostbite 2019";
  }
}); // material design components

var drawer = _drawer.MDCDrawer.attachTo(document.querySelector('.mdc-drawer'));

var topAppBar = _topAppBar.MDCTopAppBar.attachTo(document.getElementById('app-bar'));

topAppBar.setScrollTarget(document.getElementById('main-content'));
topAppBar.listen('MDCTopAppBar:nav', function () {
  drawer.open = !drawer.open;
}); // close modal drawer after hitting an item

var listEl = document.querySelector('.mdc-drawer .mdc-list');
var mainContentEl = document.querySelector('.main-content');
listEl.addEventListener('click', function (event) {
  drawer.open = false;
});
document.body.addEventListener('MDCDrawer:closed', function () {
  mainContentEl.querySelector('input, button').focus();
}); // charts

(0, _playrateCharts.RenderPlayRateCharts)();
(0, _overviewTable.RenderOverviewTable)();
(0, _banrateCharts.RenderBanRateCharts)();
(0, _banPairsCharts.RenderBanPairsCharts)();
(0, _starterCharts.RenderStarterCharts)();
},{"../../css/main.scss":"css/main.scss","@material/drawer":"../node_modules/@material/drawer/dist/mdc.drawer.js","@material/top-app-bar":"../node_modules/@material/top-app-bar/dist/mdc.topAppBar.js","./playrate-charts":"js/frostbite2019/playrate-charts.js","./overview-table":"js/frostbite2019/overview-table.js","./banrate-charts":"js/frostbite2019/banrate-charts.js","./ban-pairs-charts":"js/frostbite2019/ban-pairs-charts.js","./starter-charts":"js/frostbite2019/starter-charts.js"}],"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "59224" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","js/frostbite2019/main.js"], null)
//# sourceMappingURL=/main.9ad7e6de.js.map